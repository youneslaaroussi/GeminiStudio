# Motion Canvas (custom components) — comprehensive reference

When you create or edit Motion Canvas components (createComponent, editComponent), the code must be valid Motion Canvas TSX. The runtime is @motion-canvas/2d and @motion-canvas/core. This section is the authoritative reference; follow it to produce correct, compilable components.

## Component structure (required pattern)

- A **custom component** is a class extending Node (or Layout, Rect, Circle, etc. if you need that base). It must have:
  1. A **props interface** extending NodeProps (or LayoutProps, ShapeProps, etc.) with optional props typed as `propName?: SignalValue<Type>`. For colors use PossibleColor (or similar) inside SignalValue<>.
  2. For **every** prop that the component accepts, the class must have a **matching declared property**: use decorators `@initial(defaultValue)` (recommended) then `@signal()` for normal types or `@colorSignal()` for colors, then `public declare readonly propName: SimpleSignal<Type, this>` or `ColorSignal<this>`. Properties must be public, declare, and readonly. Example: `@initial(0) @signal() public declare readonly progress: SimpleSignal<number, this>;` and `@initial('#fff') @colorSignal() public declare readonly fillColor: ColorSignal<this>;`.
  3. **Constructor**: call `super({ ...props });` then build the visual subtree with `this.add(<Rect>...</Rect>)` (or Layout, Circle, etc.). Use createRef() and ref={} for any child you need to animate or read later. You may read this.propName() in the constructor to set initial layout.
  4. **Animation**: expose generator methods (e.g. `public *animate(duration: number) { yield* this.bar().scale.x(1, duration); }`) and call them from the scene with `yield* comp().animate(1);`.

- **input_defs** (for createComponent): When the component will be used on the timeline, each user-adjustable prop can be exposed as an input. Pass input_defs as a list of dicts: each dict has "name" (string, matches a prop name or your internal name), "type" ("string" | "number" | "boolean" | "color"), "default" (value matching that type), and optionally "label" (string). The component's @signal props should align with these so the timeline can drive them.

## Signals (core abstraction)

- **Signals** represent values that can change over time. createSignal(initial) for custom state. Every node property (position, fill, scale, rotation, opacity, etc.) is a signal.
- **Invocation**: signal() = read; signal(value) = set; signal(value, duration) = tween (use with yield* in a generator). Use a **function** for derived values: createSignal(() => other()) so it updates when dependencies change (lazy, cached).
- **Compound signals**: node.position.x() and node.position.y() for per-axis access; same for scale. Use for animating one axis: yield* node().position.x(100, 1).
- **DEFAULT**: signal(DEFAULT) resets to initial value; e.g. node.lineHeight(DEFAULT).
- **Colors**: Use @colorSignal() and ColorSignal<this> in components; pass hex strings or Color; interpolate with Color.lerp(a, b, t).

## Scene hierarchy and refs

- JSX creates **real Node instances** (no React, no virtual DOM). Build tree with view.add(<Node />) or node.add(<Child />). First child = back, last child = front.
- **References**: createRef<Type>() then ref={ref} on the node; ref() returns the instance. makeRef(object, key) assigns the created node to object[key] (e.g. makeRef(items, i) for arrays). createRefArray<Type>() appends each ref to the array. createRefMap() for named refs (labels.a(), labels.b()). ref is a callback that receives the node after creation.
- **Hierarchy helpers**: node.add(), node.insert(), node.remove(), node.removeChildren(), node.reparent(newParent); node.moveUp(), moveDown(), moveToTop(), moveToBottom(), moveTo(index), moveAbove(other), moveBelow(other). Query: node.findAll(predicate), findFirst, findLast, findAncestor; use is(Txt) for type predicates.

## Positioning and transform

- **Coordinate system**: origin (0,0) is **center** of frame. X: negative = left, positive = right. Y: **positive = down**, negative = up (y increases downward). position, scale, rotation are in **parent local space**. Use absolutePosition(), absoluteScale(), absoluteRotation() for world space; setting them converts to local. Matrices: localToWorld(), worldToLocal(), localToParent(), parentToWorld(), worldToParent() for point transforms.

## Tweening and animation

- **Property tween**: yield* node().position([100, 0], 2) or .to([200, 0], 2). Third arg = timing (e.g. easeInOutCubic), fourth = custom interpolation (e.g. Vector2.arcLerp).
- **Manual tween**: yield* tween(2, value => { ... }); value 0..1; use map(from, to, value) or easeInOutCubic(value, from, to).
- **Interpolation**: Color.lerp(a, b, t), Vector2.lerp, Vector2.arcLerp. spring(PlopSpring, from, to, settleTolerance?, callback) for spring physics; presets PlopSpring, SmoothSpring.
- **Save/restore**: node.save(); later yield* node.restore(duration) to tween back. State is stacked. all(...tweens) runs in parallel.

## Primitives (use inside components)

- **Rect**: fill, stroke, lineWidth, size ([w,h] or width/height), radius, position, scale, rotation, opacity; layout props if inside Layout.
- **Circle**: fill, stroke, lineWidth, size (diameter), position, etc.
- **Layout**: set layout prop; gap, padding, alignItems, justifyContent, direction; children laid out automatically.
- **Txt**: text, fontSize, fill, fontFamily, fontWeight, lineHeight, wrap.
- **Latex**: **tex** (string or array for animatable parts), **fill** (required — otherwise nothing shows), fontSize. For animatable parts use tex={['a^2','+','b^2']} or tex="{{a}} + {{b}}". In JS strings escape backslash: tex={'{{\\\\frac{1}{2}}}'} or tex="{{\\frac{1}{2}}}". Space between parts: use ['\\\\Delta','{y}'] not ['\\\\Delta','y'] (else \\Deltay).
- **Line**: points, lineWidth, stroke, startArrow, endArrow, arrowSize, start, end (0–1), startOffset, endOffset.
- **Spline**: points (array of [x,y]) or **Knot** children with position, startHandle, endHandle (relative to knot); lineWidth, stroke, fill, smoothness (0–1), closed. start/end (0–1) for draw animation. getPointAtPercentage(t) → { position, tangent }.
- **Path**: data (SVG path d string), lineWidth, stroke, fill; tween data for morph; getPointAtPercentage(t).
- **QuadBezier / CubicBezier**: p0, p1 [, p2, p3 for cubic], lineWidth, stroke, startArrow, endArrow, arrowSize, start, end (0–1). Points are compound signals (e.g. bezier().p0.x(200, 1)). Animate drawing by tweening end 0→1.

## Latex pitfalls

- **Always set fill** or the node shows nothing.
- Backslash: in JS expression use double backslash for LaTeX (\\\\frac); in JSX string attribute one is enough (\\frac).
- Missing space: parts are concatenated with no separator; use '{y}' so "\\Delta y" parses correctly.

## Path and Spline details

- **Path**: data = full SVG d string; tween data for morph; start/end and getPointAtPercentage like Line/Spline.
- **Spline**: Smooth curves through control points. Set lineWidth and stroke (or fill) or it won't be visible.
  - **points** (array of [x,y]): simplest; auto handles (Cardinal spline). smoothness (0–1) shapes the curve.
  - **Knot children**: finer control. `<Spline><Knot position={[x,y]} /><Knot position={...} startHandle={[dx,dy]} endHandle={[dx,dy]} /></Spline>`. Handles are **relative to the knot**. One handle only → the other is mirrored (flipped). Both startHandle and endHandle → **broken knot** (sharp corner). closed={true} to close the path.
  - **Knot auto**: blend user handles with auto-calculated (0 = user, 1 = auto). Use startHandleAuto / endHandleAuto for per-handle blend; animatable.
  - **Drawing**: start and end (0–1) are percentage of arclength to draw. Tween end 0→1 to animate drawing; start/end work with startOffset/endOffset.
  - **Motion along spline**: spline().getPointAtPercentage(t) returns { position, tangent }; use for placing/moving a node along the curve (tangent.degrees for rotation).
  - Animating knot positions only works when using Knot nodes, not the points property.
- **QuadBezier / CubicBezier**: Single Bézier curves (quad = one control point, cubic = two). Use for simple curves; use Spline for complex paths.
  - **QuadBezier**: p0, p1, p2. **CubicBezier**: p0, p1, p2, p3. All points are **compound signals** (e.g. bezier().p0.x(200, 1), bezier().p1.y(-50, 1)).
  - lineWidth, stroke; startArrow, endArrow, arrowSize for arrowheads. To **animate arrows appearing**, set arrowSize={0} with startArrow/endArrow and tween arrowSize to the desired size (arrowSize is animatable; the booleans are not).
  - **Drawing**: start, end (0–1). Tween end from 0 to 1 to animate drawing the curve.

## Do not / Always

- **Do not** use a normal function for the scene; use function* and yield* for tweens.
- **Do not** assume React (no useState, useEffect; JSX is one-shot node creation).
- **Do not** add a prop to the interface without the matching @initial/@signal (or @colorSignal) and declare readonly on the class — Motion Canvas requires both.
- **Do not** omit fill on Latex.
- **Do not** assume (0,0) is top-left or that positive y is up; origin is center, y down.
- **Always** provide **complete** TSX for createComponent/editComponent: full file with imports from '@motion-canvas/2d' and '@motion-canvas/core', exported component class (and optionally props interface). No partial snippets or invalid syntax.
- **Always** use valid TypeScript/JSX: correct decorators, types, and semicolons so the server-side compiler can compile the component.

## Imports (use these to avoid compile errors)

- **signal, initial, colorSignal**: import from **'@motion-canvas/2d'** (not from core).
- **createSignal, createRef, tween, SignalValue, SimpleSignal, etc.**: import from **'@motion-canvas/core'**.
- **Function components**: if you use a function that returns JSX (e.g. with createSignal for props), wrap it with **makeComponent** and import: `import { makeComponent } from '../../lib/makeComponent';` (do not import makeComponent from @motion-canvas/core — it is provided by the project).

## Example skeleton (createComponent)

```tsx
import { Node, NodeProps, Rect, Circle, Layout, signal, initial, colorSignal } from '@motion-canvas/2d';
import {
  SignalValue,
  SimpleSignal,
  ColorSignal,
  createRef,
  createSignal,
} from '@motion-canvas/core';

export interface MyWidgetProps extends NodeProps {
  value?: SignalValue<number>;
  color?: SignalValue<string>;
}

export class MyWidget extends Node {
  @initial(0) @signal() public declare readonly value: SimpleSignal<number, this>;
  @initial('#68ABDF') @colorSignal() public declare readonly color: ColorSignal<this>;
  private readonly bar = createRef<Rect>();

  public constructor(props?: MyWidgetProps) {
    super({ ...props });
    this.add(
      <Layout layout gap={10}>
        <Rect ref={this.bar} width={() => this.value() * 2} height={20} fill={this.color} />
        <Circle size={24} fill={this.color} />
      </Layout>
    );
  }

  public *grow(duration: number) {
    yield* this.value(1, duration);
  }
}
```

## Input variables vs. animation (critical distinction)

**input_defs** (input variables) are **static values** set on the timeline. They are NOT animatable — they do not change over the course of the clip's playback. You cannot tween or keyframe an input variable. When a user drags a component onto the timeline, inputs are set once (e.g. in the inspector panel) and remain constant.

If a user wants **animated behavior** (e.g. typewriter text, a counter counting up, a progress bar filling, pulsing opacity, or any value that changes over time):

1. **Use generator methods and signals inside the component**, not input variables.
2. Input variables can control **parameters** of the animation (speed, delay, target value, easing) but the animation itself must be driven by a generator that yields tweens on signals.
3. For a **typewriter effect**: store the full text as an input variable, then use a generator method that reveals characters over time via a signal (e.g. a `progress` signal that controls how many characters of the text are visible). The component's `Txt` node reads a derived signal: `text={() => this.fullText().slice(0, Math.floor(this.progress() * this.fullText().length))}`.
4. For **counting / filling / any temporal change**: expose a `*animate(duration)` generator that tweens a signal from 0 to 1 (or any range). Use input variables only for static config like `targetValue`, `speed`, `color`, `fontSize`.

**Pattern**: inputs = what to show and how fast; generators + signals = the actual motion.

```tsx
// WRONG: trying to animate via input variable (will not work — value is static)
// input_defs: [{ name: "progress", type: "number", default: 0 }]
// The user cannot keyframe this.

// CORRECT: input controls speed, generator drives animation
export interface ProgressBarProps extends NodeProps {
  speed?: SignalValue<number>;       // input: how fast
  fillColor?: SignalValue<string>;   // input: what color
}

export class ProgressBar extends Node {
  @initial(1) @signal() public declare readonly speed: SimpleSignal<number, this>;
  @initial('#4CAF50') @colorSignal() public declare readonly fillColor: ColorSignal<this>;

  // Internal animated signal — NOT an input
  private readonly progress = createSignal(0);
  private readonly bar = createRef<Rect>();

  public constructor(props?: ProgressBarProps) {
    super({ ...props });
    this.add(
      <Rect width={200} height={20} radius={4} fill="#333">
        <Rect
          ref={this.bar}
          width={() => this.progress() * 200}
          height={20}
          radius={4}
          fill={this.fillColor}
        />
      </Rect>
    );
  }

  // Animation via generator — this is what makes it move
  public *fill(duration?: number) {
    yield* this.progress(1, duration ?? this.speed());
  }
}
```

When providing code to createComponent or editComponent, supply complete, valid TSX that compiles. Match input_defs to the component's signal props (name, type, default, label) so the timeline can control them.

## Shaders (experimental)

- The agent can add shaders to components. Shaders allow custom WebGL effects on any node via the **shaders** property.
- **Simple use**: pass a string (GLSL fragment shader code): `shaders={myShader}`. Import the GLSL file: `import myShader from './myShader.glsl';`.
- **With custom uniforms**: pass an object: `shaders={{ fragment: myShader, uniforms: { myFloat: 0.5, myVec2: new Vector2(2, 5), myColor: new Color('blue') } }}`. Uniform types: number → float, [n,n] or Vector2 → vec2, [n,n,n] → vec3, [n,n,n,n] or Color → vec4, BBox → vec4, Spacing → vec4.
- **GLSL preprocessor**: use `#include "path"` for relative files or `#include "@motion-canvas/core/shaders/common.glsl"` for package files. Include common.glsl to get default uniforms: time, deltaTime, framerate, frame, resolution, sourceTexture, destinationTexture, sourceUV, destinationUV, sourceMatrix, destinationMatrix, outColor.
- **Source vs destination**: sourceTexture = the node being rendered; destinationTexture = what's already on screen. Sample with sourceUV and destinationUV; combine like globalCompositeOperation.
- **Caching**: Nodes with shaders are automatically cached. Use **cachePadding** if the effect extends beyond the node's logical size. For view-wide effects, increase view cachePadding.
- Example (invert colors): fragment shader sets `outColor.rgb = 1.0 - texture(sourceTexture, sourceUV).rgb;` after including common.glsl.

## Spawners (reactive children)

- **Spawners** are functions that return children; they recompute when dependencies change (reactive). Use when the number or identity of children depends on signals.
- **Non-reactive (wrong)**: `{range(count()).map(() => <Circle />)}` — changing count does not update the tree.
- **Reactive (correct)**: `{() => range(count()).map(() => <Circle size={32} fill="white" />)}` — wrap in a function so it re-runs when count() changes.
- **Performance**: Creating many nodes each frame is costly. For large reactive lists, use an **object pool**: pre-create nodes (e.g. `const pool = range(64).map(i => <Circle ... />)`), then in the spawner return `pool.slice(0, count())`. Only the spawner function should read the pool; use parent's helper methods to get refs to spawned children (e.g. `layout().childrenAs<Circle>()`). Do not hold refs to spawned children across spawn updates — they can be invalidated.
- **Note**: Spawners are built on signals (lazy evaluation); future versions may reimplement with effects. Prefer effects when that API is available for new code.

## Random values

- **Reproducible randomness**: use **useRandom()** from '@motion-canvas/core' (do **not** import `random` — it is not exported). In class components, call it in the constructor or a field: `private readonly _random = useRandom();` then use `this._random.nextInt(0, 10)`. In scene generators: `const random = useRandom(); const n = random.nextInt(0, 10);`
  - **Custom seed**: `useRandom(123)` for a fixed sequence. The default seed is stored in the scene meta file.
- **API**: see Random in Motion Canvas core (nextInt, nextFloat, etc.). Use for varied heights, positions, or visual variety while keeping the animation deterministic.
