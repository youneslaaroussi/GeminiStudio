# Motion Canvas (custom components) — comprehensive reference

When you create or edit Motion Canvas components (createComponent, editComponent), the code must be valid Motion Canvas TSX. The runtime is @motion-canvas/2d and @motion-canvas/core. This section is the authoritative reference; follow it to produce correct, compilable components.

## Component structure (required pattern)

- A **custom component** is a class extending Node (or Layout, Rect, Circle, etc. if you need that base). It must have:
  1. A **props interface** extending NodeProps (or LayoutProps, ShapeProps, etc.) with optional props typed as `propName?: SignalValue<Type>`. For colors use PossibleColor (or similar) inside SignalValue<>.
  2. For **every** prop that the component accepts, the class must have a **matching declared property**: use decorators `@initial(defaultValue)` (recommended) then `@signal()` for normal types or `@colorSignal()` for colors, then `public declare readonly propName: SimpleSignal<Type, this>` or `ColorSignal<this>`. Properties must be public, declare, and readonly. Example: `@initial(0) @signal() public declare readonly progress: SimpleSignal<number, this>;` and `@initial('#fff') @colorSignal() public declare readonly fillColor: ColorSignal<this>;`.
  3. **Constructor**: call `super({ ...props });` then build the visual subtree with `this.add(<Rect>...</Rect>)` (or Layout, Circle, etc.). Use createRef() and ref={} for any child you need to animate or read later. You may read this.propName() in the constructor to set initial layout.
  4. **Timeline animation (required for components used on the timeline)**: The timeline calls **only** the method **animate(duration?: number)**. You **must** implement `public *animate(duration?: number): ThreadGenerator`. Use any internal names you like (e.g. *reveal(), *fall(), *run()) and have animate delegate: e.g. `public *animate(duration?: number) { yield* this.reveal(duration ?? 1); }` or `public *animate(duration?: number) { yield* this.fall(duration ?? 5); }`. If the component has no animation, implement `public *animate() {}` or `public *animate(_duration?: number) { yield* waitFor(0); }`.

- **input_defs** (for createComponent): When the component will be used on the timeline, each user-adjustable prop can be exposed as an input. Pass input_defs as a list of dicts: each dict has "name" (string, matches a prop name or your internal name), "type" ("string" | "number" | "boolean" | "color"), "default" (value matching that type), and optionally "label" (string). The component's @signal props should align with these so the timeline can drive them.

## Signals (core abstraction)

- **Signals** represent values that can change over time. createSignal(initial) for custom state. Every node property (position, fill, scale, rotation, opacity, etc.) is a signal.
- **Invocation**: signal() = read; signal(value) = set; signal(value, duration) = tween (use with yield* in a generator). Use a **function** for derived values: createSignal(() => other()) so it updates when dependencies change (lazy, cached).
- **Compound signals**: node.position.x() and node.position.y() for per-axis access; same for scale. Use for animating one axis: yield* node().position.x(100, 1).
- **DEFAULT**: signal(DEFAULT) resets to initial value; e.g. node.lineHeight(DEFAULT).
- **Colors**: Use @colorSignal() and ColorSignal<this> in components; pass hex strings or Color; interpolate with Color.lerp(a, b, t).

## Scene hierarchy and refs

- JSX creates **real Node instances** (no React, no virtual DOM). Build tree with view.add(<Node />) or node.add(<Child />). First child = back, last child = front.
- **References**: createRef<Type>() then ref={ref} on the node; ref() returns the instance. makeRef(object, key) assigns the created node to object[key] (e.g. makeRef(items, i) for arrays). createRefArray<Type>() appends each ref to the array. createRefMap() for named refs (labels.a(), labels.b()). ref is a callback that receives the node after creation.
- **Hierarchy helpers**: node.add(), node.insert(), node.remove(), node.removeChildren(), node.reparent(newParent); node.moveUp(), moveDown(), moveToTop(), moveToBottom(), moveTo(index), moveAbove(other), moveBelow(other). Query: node.findAll(predicate), findFirst, findLast, findAncestor; use is(Txt) for type predicates.

## Positioning and transform

- **Coordinate system**: origin (0,0) is **center** of frame. X: negative = left, positive = right. Y: **positive = down**, negative = up (y increases downward). position, scale, rotation are in **parent local space**. Use absolutePosition(), absoluteScale(), absoluteRotation() for world space; setting them converts to local. Matrices: localToWorld(), worldToLocal(), localToParent(), parentToWorld(), worldToParent() for point transforms.

## Tweening and animation

- **Property tween**: yield* node().position([100, 0], 2) or .to([200, 0], 2). Third arg = timing (e.g. easeInOutCubic), fourth = custom interpolation (e.g. Vector2.arcLerp).
- **Manual tween**: yield* tween(2, value => { ... }); value 0..1; use map(from, to, value) or easeInOutCubic(value, from, to).
- **Interpolation**: Color.lerp(a, b, t), Vector2.lerp, Vector2.arcLerp. spring(PlopSpring, from, to, settleTolerance?, callback) for spring physics; presets PlopSpring, SmoothSpring.
- **Save/restore**: node.save(); later yield* node.restore(duration) to tween back. State is stacked. all(...tweens) runs in parallel.

## Primitives (use inside components)

- **Rect**: fill, stroke, lineWidth, size ([w,h] or width/height), radius, position, scale, rotation, opacity; layout props if inside Layout.
- **Circle**: fill, stroke, lineWidth, size (diameter), position, etc.
- **Layout**: set layout prop; gap, padding, alignItems, justifyContent, direction; children laid out automatically.
- **Txt**: text, fontSize, fill, fontFamily, fontWeight, lineHeight, wrap. Use **fontFamily** only with one of the project's available fonts (see below).
- **Code**: code (string or CODE-tagged template), fontSize, fill. Use **CODE** so signals update: code={CODE`const ${nameSignal} = 7;`}. **Code.createSignal**(initial) for reactive code. Animate: code().code(newCode, duration); code().code.append(text, duration) / prepend; code().code.insert([line,col], text, duration), replace(range, text, duration), remove(range, duration); code().code.edit(duration)`...${insert('...')}...${replace('a','b')}...`; code().selection(ranges, duration). Ranges: word(line, col, length), lines(start, end). Find: code().findFirstRange('str'), findAllRanges(/re/). Project has Code.defaultHighlighter = LezerHighlighter(@lezer/javascript) with dialect 'jsx ts'. Other languages: set **highlighter** on node (e.g. LezerHighlighter(parser) for @lezer/python, @lezer/rust, etc.).
- **Latex**: **tex** (string or array for animatable parts), **fill** (required — otherwise nothing shows), fontSize. Animating: tex={['a^2','+','b^2']} or tex="{{a}} + {{b}}"; tween with yield* texRef().tex(['2','+','3'], 1). In JS strings escape backslash: tex={'{{\\\\frac{1}{2}}}'} or tex="{{\\frac{1}{2}}}". Space between parts: use ['\\\\Delta','{y}'] not ['\\\\Delta','y'] (else \\Deltay).
- **Line**: points, lineWidth, stroke, startArrow, endArrow, arrowSize, start, end (0–1), startOffset, endOffset.
- **Spline**: points (array of [x,y]) or **Knot** children with position, startHandle, endHandle (relative to knot); lineWidth, stroke, fill, smoothness (0–1), closed. start/end (0–1) for draw animation. getPointAtPercentage(t) → { position, tangent }.
- **Path**: data (SVG path d string), lineWidth, stroke, fill; tween data for morph; getPointAtPercentage(t).
- **QuadBezier / CubicBezier**: p0, p1 [, p2, p3 for cubic], lineWidth, stroke, startArrow, endArrow, arrowSize, start, end (0–1). Points are compound signals (e.g. bezier().p0.x(200, 1)). Animate drawing by tweening end 0→1.

## Available fonts (use exact fontFamily string)

The project has these fonts loaded; use the **exact** family string in Txt or component fontFamily so text renders correctly (e.g. fontFamily="Inter Variable", fontFamily="Poppins", fontFamily="JetBrains Mono"). Do not use generic names like "sans-serif" or unlisted fonts.

Variable: Inter Variable, Open Sans Variable, Montserrat Variable, IBM Plex Sans Variable, Public Sans Variable, DM Sans Variable, Noto Sans Variable, Plus Jakarta Sans Variable, Mulish Variable, Nunito Sans Variable, Nunito Variable, Merriweather Variable, Roboto Variable, Work Sans Variable, Space Grotesk Variable, Manrope Variable, Outfit Variable, Raleway Variable, Playfair Display Variable, Crimson Pro Variable, Literata Variable, Vollkorn Variable, Lora Variable.

Fixed-weight: Poppins, Roboto, Montserrat, Playfair Display, Raleway, Lato, Ubuntu, Cabin, Rubik, Quicksand, Comfortaa, Kalam, Pacifico, Bebas Neue, Oswald, Anton, Righteous, Lobster, Dancing Script, Barlow, Fira Sans, IBM Plex Sans, Source Sans Pro, Noto Sans, Work Sans, Space Grotesk, Manrope, Outfit, DM Sans, Plus Jakarta Sans, Mulish, Nunito, Nunito Sans, Merriweather, Public Sans, Crimson Pro, Literata, Libre Baskerville, Spectral, Crimson Text, Vollkorn, Lora, Alegreya, Cormorant, PT Serif.

Monospace (code): JetBrains Mono.

## Code (syntax highlighting)

- **CODE** tag: code={CODE`...${signal}...`} so signals update; plain template strings capture once.
- **Code.createSignal**(initial); animate via code property: code().code(val, dur), code().code.append(text, dur), .insert([line,col], text, dur), .replace(range, text, dur), .remove(range, dur), .edit(dur)`...`, .selection(ranges, dur). Ranges: word(line, col, len), lines(start, end). findFirstRange('s'), findAllRanges(/re/).
- **Grammars**: Project uses **@lezer/javascript** (JS/TS/JSX). Other languages: install grammar (e.g. npm i @lezer/python, @lezer/rust) and set **highlighter** on the Code node: highlighter={new LezerHighlighter(parser)}. Available: @lezer/javascript, @lezer/python, @lezer/rust, @lezer/cpp, @lezer/html, @lezer/css, @lezer/json, @lezer/markdown, @lezer/go, @lezer/java, @lezer/php, @lezer/xml, @lezer/yaml, @lezer/sass, @lezer/clojure, @lezer/julia.

## Latex pitfalls

- **Always set fill** or the node shows nothing.
- Backslash: in JS expression use double backslash for LaTeX (\\\\frac); in JSX string attribute one is enough (\\frac).
- Missing space: parts are concatenated with no separator; use '{y}' so "\\Delta y" parses correctly.

## Path and Spline details

- **Path**: data = full SVG d string; tween data for morph; start/end and getPointAtPercentage like Line/Spline.
- **Spline**: Smooth curves through control points. Set lineWidth and stroke (or fill) or it won't be visible.
  - **points** (array of [x,y]): simplest; auto handles (Cardinal spline). smoothness (0–1) shapes the curve.
  - **Knot children**: finer control. `<Spline><Knot position={[x,y]} /><Knot position={...} startHandle={[dx,dy]} endHandle={[dx,dy]} /></Spline>`. Handles are **relative to the knot**. One handle only → the other is mirrored (flipped). Both startHandle and endHandle → **broken knot** (sharp corner). closed={true} to close the path.
  - **Knot auto**: blend user handles with auto-calculated (0 = user, 1 = auto). Use startHandleAuto / endHandleAuto for per-handle blend; animatable.
  - **Drawing**: start and end (0–1) are percentage of arclength to draw. Tween end 0→1 to animate drawing; start/end work with startOffset/endOffset.
  - **Motion along spline**: spline().getPointAtPercentage(t) returns { position, tangent }; use for placing/moving a node along the curve (tangent.degrees for rotation).
  - Animating knot positions only works when using Knot nodes, not the points property.
- **QuadBezier / CubicBezier**: Single Bézier curves (quad = one control point, cubic = two). Use for simple curves; use Spline for complex paths.
  - **QuadBezier**: p0, p1, p2. **CubicBezier**: p0, p1, p2, p3. All points are **compound signals** (e.g. bezier().p0.x(200, 1), bezier().p1.y(-50, 1)).
  - lineWidth, stroke; startArrow, endArrow, arrowSize for arrowheads. To **animate arrows appearing**, set arrowSize={0} with startArrow/endArrow and tween arrowSize to the desired size (arrowSize is animatable; the booleans are not).
  - **Drawing**: start, end (0–1). Tween end from 0 to 1 to animate drawing the curve.

## Do not / Always

- **Do not** use a normal function for the scene; use function* and yield* for tweens.
- **Do not** assume React (no useState, useEffect; JSX is one-shot node creation).
- **Do not** add a prop to the interface without the matching @initial/@signal (or @colorSignal) and declare readonly on the class — Motion Canvas requires both.
- **Do not** omit fill on Latex.
- **Do not** assume (0,0) is top-left or that positive y is up; origin is center, y down.
- **Always** provide **complete** TSX for createComponent/editComponent: full file with imports from '@motion-canvas/2d' and '@motion-canvas/core', exported component class (and optionally props interface). No partial snippets or invalid syntax.
- **Always** use valid TypeScript/JSX: correct decorators, types, and semicolons so the server-side compiler can compile the component.
- **Always** implement **animate(duration?)** for components used on the timeline — the timeline calls no other method (no reveal, fall, run, etc.). Have animate delegate to your internal logic.

## Imports (use these to avoid compile errors)

- **signal, initial, colorSignal**: import from **'@motion-canvas/2d'** (not from core).
- **createSignal, createRef, tween, SignalValue, SimpleSignal, etc.**: import from **'@motion-canvas/core'**.
- **Function components**: if you use a function that returns JSX (e.g. with createSignal for props), wrap it with **makeComponent** and import: `import { makeComponent } from '../../lib/makeComponent';` (do not import makeComponent from @motion-canvas/core — it is provided by the project).

## Example skeleton (createComponent)

```tsx
import { Node, NodeProps, Rect, Circle, Layout, signal, initial, colorSignal } from '@motion-canvas/2d';
import {
  SignalValue,
  SimpleSignal,
  ColorSignal,
  createRef,
  createSignal,
} from '@motion-canvas/core';

export interface MyWidgetProps extends NodeProps {
  value?: SignalValue<number>;
  color?: SignalValue<string>;
}

export class MyWidget extends Node {
  @initial(0) @signal() public declare readonly value: SimpleSignal<number, this>;
  @initial('#68ABDF') @colorSignal() public declare readonly color: ColorSignal<this>;
  private readonly bar = createRef<Rect>();

  public constructor(props?: MyWidgetProps) {
    super({ ...props });
    this.add(
      <Layout layout gap={10}>
        <Rect ref={this.bar} width={() => this.value() * 2} height={20} fill={this.color} />
        <Circle size={24} fill={this.color} />
      </Layout>
    );
  }

  public *grow(duration: number) {
    yield* this.value(1, duration);
  }
}
```

## Input variables vs. animation (critical distinction)

**input_defs** (input variables) are **static values** set on the timeline. They are NOT animatable — they do not change over the course of the clip's playback. You cannot tween or keyframe an input variable. When a user drags a component onto the timeline, inputs are set once (e.g. in the inspector panel) and remain constant.

**Timeline entry point**: The timeline calls **only** `animate(duration?)`. You must implement `public *animate(duration?: number)`; it can delegate to any internal method (e.g. `yield* this.fill(duration);`). Do not rely on other names (reveal, fall, run, fill, etc.) — only `animate` is invoked.

If a user wants **animated behavior** (e.g. typewriter text, a counter counting up, a progress bar filling, pulsing opacity, or any value that changes over time):

1. **Use generator methods and signals inside the component**, not input variables.
2. Input variables can control **parameters** of the animation (speed, delay, target value, easing) but the animation itself must be driven by a generator that yields tweens on signals.
3. For a **typewriter effect**: store the full text as an input variable, then use a generator method that reveals characters over time via a signal (e.g. a `progress` signal that controls how many characters of the text are visible). The component's `Txt` node reads a derived signal: `text={() => this.fullText().slice(0, Math.floor(this.progress() * this.fullText().length))}`. Implement `*animate(duration?) { yield* this.reveal(duration); }`.
4. For **counting / filling / any temporal change**: implement `*animate(duration?)` that tweens a signal (e.g. delegate to an internal `*fill(duration?)`). Use input variables only for static config like `targetValue`, `speed`, `color`, `fontSize`.

**Pattern**: inputs = what to show and how fast; generators + signals = the actual motion; **animate(duration?)** = the single entry point the timeline calls.

```tsx
// WRONG: trying to animate via input variable (will not work — value is static)
// input_defs: [{ name: "progress", type: "number", default: 0 }]
// The user cannot keyframe this.

// CORRECT: input controls speed, generator drives animation
export interface ProgressBarProps extends NodeProps {
  speed?: SignalValue<number>;       // input: how fast
  fillColor?: SignalValue<string>;   // input: what color
}

export class ProgressBar extends Node {
  @initial(1) @signal() public declare readonly speed: SimpleSignal<number, this>;
  @initial('#4CAF50') @colorSignal() public declare readonly fillColor: ColorSignal<this>;

  // Internal animated signal — NOT an input
  private readonly progress = createSignal(0);
  private readonly bar = createRef<Rect>();

  public constructor(props?: ProgressBarProps) {
    super({ ...props });
    this.add(
      <Rect width={200} height={20} radius={4} fill="#333">
        <Rect
          ref={this.bar}
          width={() => this.progress() * 200}
          height={20}
          radius={4}
          fill={this.fillColor}
        />
      </Rect>
    );
  }

  // Internal animation logic
  public *fill(duration?: number) {
    yield* this.progress(1, duration ?? this.speed());
  }

  // Timeline only calls animate — delegate to fill
  public *animate(duration?: number) {
    yield* this.fill(duration);
  }
}
```

When providing code to createComponent or editComponent, supply complete, valid TSX that compiles. Match input_defs to the component's signal props (name, type, default, label) so the timeline can control them.

## Shaders (experimental)

- Shaders allow custom WebGL effects on any node via the **shaders** property.
- **IMPORTANT**: Custom components are single `.tsx` files — you **cannot** import `.glsl` files. Instead, **inline the GLSL as a string constant** in the component file. Do NOT use `import ... from './shader.glsl'` or `#include` directives — those only work for pre-bundled shaders.
- **Inline shader**: Define the GLSL as a template literal or string constant. You must manually declare any uniforms you use (the `#include "common.glsl"` preprocessor does not work with inline strings).
- **Default uniforms** (declare these at the top of your inline GLSL when needed):
  ```
  in vec2 sourceUV;
  in vec2 destinationUV;
  in vec2 screenUV;
  out vec4 outColor;
  uniform float time;
  uniform float deltaTime;
  uniform float framerate;
  uniform int frame;
  uniform vec2 resolution;
  uniform sampler2D sourceTexture;
  uniform sampler2D destinationTexture;
  ```
- **Simple use**: pass the inline string directly: `shaders={myShader}` where `myShader` is a `const myShader = \`#version 300 es\nprecision highp float;\n...\`;`.
- **With custom uniforms**: pass an object: `shaders={{ fragment: myShader, uniforms: { myFloat: 0.5, myVec2: new Vector2(2, 5), myColor: new Color('blue') } }}`. Uniform types: number → float, [n,n] or Vector2 → vec2, [n,n,n] → vec3, [n,n,n,n] or Color → vec4, BBox → vec4, Spacing → vec4.
- **Source vs destination**: sourceTexture = the node being rendered; destinationTexture = what's already on screen. Sample with sourceUV and destinationUV; combine like globalCompositeOperation.
- **Caching**: Nodes with shaders are automatically cached. Use **cachePadding** if the effect extends beyond the node's logical size. For view-wide effects, increase view cachePadding.
- **Example** (invert colors):
  ```
  const invertShader = `#version 300 es
  precision highp float;
  in vec2 sourceUV;
  out vec4 outColor;
  uniform sampler2D sourceTexture;
  void main() {
      vec4 c = texture(sourceTexture, sourceUV);
      outColor = vec4(1.0 - c.rgb, c.a);
  }`;
  ```
  Then use: `<Rect shaders={invertShader} ... />`

## Spawners (reactive children)

- **Spawners** are functions that return children; they recompute when dependencies change (reactive). Use when the number or identity of children depends on signals.
- **Non-reactive (wrong)**: `{range(count()).map(() => <Circle />)}` — changing count does not update the tree.
- **Reactive (correct)**: `{() => range(count()).map(() => <Circle size={32} fill="white" />)}` — wrap in a function so it re-runs when count() changes.
- **Performance**: Creating many nodes each frame is costly. For large reactive lists, use an **object pool**: pre-create nodes (e.g. `const pool = range(64).map(i => <Circle ... />)`), then in the spawner return `pool.slice(0, count())`. Only the spawner function should read the pool; use parent's helper methods to get refs to spawned children (e.g. `layout().childrenAs<Circle>()`). Do not hold refs to spawned children across spawn updates — they can be invalidated.
- **Note**: Spawners are built on signals (lazy evaluation); future versions may reimplement with effects. Prefer effects when that API is available for new code.

## Random values

- **Reproducible randomness**: use **useRandom()** from '@motion-canvas/core' (do **not** import `random` — it is not exported). In class components, call it in the constructor or a field: `private readonly _random = useRandom();` then use `this._random.nextInt(0, 10)`. In scene generators: `const random = useRandom(); const n = random.nextInt(0, 10);`
  - **Custom seed**: `useRandom(123)` for a fixed sequence. The default seed is stored in the scene meta file.
- **API**: see Random in Motion Canvas core (nextInt, nextFloat, etc.). Use for varied heights, positions, or visual variety while keeping the animation deterministic.

## Geographic / map path data (d3-geo)

The **scene compiler** includes **d3-geo**. In custom components you can import and use it to generate SVG path strings from GeoJSON for map/region outlines.

- **Import**: `import { geoMercator, geoPath } from 'd3-geo';`
- **Data**: Fetch GeoJSON (e.g. Natural Earth countries) and filter by property. Example URL: `https://raw.githubusercontent.com/nvkelso/natural-earth-vector/master/geojson/ne_110m_admin_0_countries.geojson`. Filter: `features.filter(f => f.properties?.CONTINENT === 'Africa')` (or another continent/country).
- **Projection**: `const projection = geoMercator().fitExtent([[-200, -100], [200, 100]], featureCollection);` — fits the geo object in 400×200 with center (0,0).
- **Path string**: `const path = geoPath().projection(projection); const pathString = path(featureCollection);`
- **Async**: Fetch is async. Use a signal for the path data (e.g. `pathData`), default `''`. In constructor or a method, `fetch(url).then(r => r.json()).then(fc => { ... pathData(path(fc)); });`. Use that signal for **Path**'s `data` prop.
- **Path node**: `<Path data={() => this.pathData()} stroke={...} lineWidth={...} end={0} />`. Animate outline by tweening `pathRef().end(1, duration)` in `*animate()`.
- **Scale**: Use `scale={mapWidth/400}` on the Path (or a parent) so coordinates [-200,200]×[-100,100] fit the desired map size. Ocean = **Rect** behind the path.

## Charts and data viz (d3-shape, d3-scale)

The **scene compiler** includes **d3-shape** and **d3-scale**. Use them to generate SVG path strings and map data values to pixel coordinates. Feed results into Motion Canvas **Path**, **Line**, or **Rect** nodes — no DOM; compute then render.

- **Imports**: `import { arc, pie, line, area } from 'd3-shape';` and `import { scaleLinear, scaleBand, scaleOrdinal } from 'd3-scale';`
- **Scales (d3-scale)**: Pure functions. `scaleLinear().domain([0, 100]).range([0, 800])` maps data to pixels. `scaleBand().domain(['A','B','C']).range([0, 300]).padding(0.1)` for bar positions/widths. `scaleOrdinal().domain(categories).range(['#a','#b','#c'])` for categorical colors. Call the scale with a data value to get position/size/color.
- **Pie/arc (d3-shape)**: `pie()(values)` returns arcs with startAngle/endAngle (radians). `arc()({ innerRadius, outerRadius, startAngle, endAngle })` returns an SVG path string; use e.g. `const arcGen = arc().innerRadius(0).outerRadius(r);` then `arcGen(arc)` per slice. Use one **Path** per slice with `data={arcGen(arc)}`; animate by tweening **end** 0→1 or by recomputing with updated endAngle.
- **Line/area (d3-shape)**: `line().x(d => xScale(d.x)).y(d => yScale(d.y))(data)` returns path string for a line; use with **Path**. `area()` same but with .y0() for baseline (area chart). Animate drawing with Path **end** 0→1.
- **Bar charts**: Use scaleBand for x positions and widths; create **Rect** nodes at `(x(d), 0)`, size `(bandwidth, yScale(d.value))`. Animate height by tweening scale.y or the height signal from 0.
- **Pattern**: Compute path strings or positions in constructor or from a signal; use signals for Path **data** or for node positions/sizes so updates are reactive.

## Hierarchy layouts (d3-hierarchy)

The **scene compiler** includes **d3-hierarchy** for tree, treemap, and pack layouts. It computes x, y, and size; you create Motion Canvas nodes at those positions.

- **Import**: `import { hierarchy, tree, treemap, pack } from 'd3-hierarchy';`
- **Data**: `hierarchy(data, childrenAccessor)` builds a tree from nested data (default children: d => d.children). Then call a layout: `.size([width, height])` and `layout(root)` to assign each node .x, .y, .dx, .dy (or .r for pack).
- **Tree**: `tree().size([w, h])(root)` — nodes get .x, .y. Use **Line** or **Spline** for links (parent x,y to child x,y); use **Circle** or **Txt** at node.x, node.y.
- **Treemap**: `treemap().size([w,h]).padding(n)(root)` — nodes get .x0, .y0, .x1, .y1 (rectangle). Create **Rect** with position (center of rect), size (x1-x0, y1-y0).
- **Pack**: `pack().size([w,h]).padding(n)(root)` — nodes get .x, .y, .r`. Create **Circle** at (node.x, node.y) with size 2*node.r.
- **Pattern**: Layout runs once (or when data signal changes); create nodes in a spawner or in constructor from root.descendants() and root.links(). No DOM — only read layout results and add MC nodes.

## Procedural noise (simplex-noise)

The **scene compiler** includes **simplex-noise**. Use it for organic motion, flowing backgrounds, or variation — it returns numbers only; drive signals or positions from it.

- **Import**: `import { createNoise2D } from 'simplex-noise';` (or createNoise3D, createNoise4D for more dimensions).
- **Create**: `const noise2D = createNoise2D();` — optionally pass a random function for seeding (e.g. from useRandom() for reproducibility).
- **Sample**: `noise2D(x, y)` returns about -1 to 1. Use for offset: e.g. `position.x(baseX + noise2D(t, 0) * amount)`. Animate by passing time or a signal as first arg.
- **Use in signals**: e.g. `createSignal(() => baseY + noise2D(this.time(), 0) * 20)` so position updates when time changes. Good for gentle floating, terrain, or blob outlines.

## Color scales and manipulation (chroma-js)

The **scene compiler** includes **chroma-js**. Use it for color scales, interpolation, and contrast — returns hex/rgb strings you pass to fill/stroke.

- **Import**: `import chroma from 'chroma-js';`
- **Scale**: `chroma.scale(['#fff', '#f00']).mode('lab')(t)` — t 0..1 returns hex. Use for gradients along a path or over time. `chroma.scale('Spectral').domain([0, max])(value)` for data-driven colors.
- **Manipulate**: `chroma('#abc').darken(0.5).hex()`, `.brighten()`, `.saturate()`, `.alpha(0.8)` — chain and `.hex()` or `.css()` for Motion Canvas fill/stroke.
- **Pattern**: Call chroma in a function passed to a signal (e.g. fill={() => chroma.scale(colors)(progress())}) or compute once and pass the string. No DOM — use result as **fill** or **stroke** on Rect, Circle, Path, Txt, etc.
