/** Generated by scripts/generate-motion-canvas-types.ts - do not edit manually */

export const MOTION_CANVAS_TYPES: { path: string; content: string }[] = [
  { path: "node_modules/@motion-canvas/2d/package.json", content: "{\"name\":\"@motion-canvas/2d\",\"types\":\"./lib/index.d.ts\"}" },
  { path: "node_modules/@motion-canvas/2d/lib/code/CodeCursor.d.ts", content: "import { Vector2 } from '@motion-canvas/core';\nimport { Code } from '../components';\nimport { CodeScope } from './CodeScope';\nexport interface CodeFragmentDrawingInfo {\n    text: string;\n    position: Vector2;\n    characterSize: Vector2;\n    cursor: Vector2;\n    fill: string;\n    time: number;\n    alpha: number;\n}\n/**\n * A stateful class for recursively traversing a code scope.\n *\n * @internal\n */\nexport declare class CodeCursor {\n    private readonly node;\n    cursor: Vector2;\n    beforeCursor: Vector2;\n    afterCursor: Vector2;\n    beforeIndex: number;\n    afterIndex: number;\n    private context;\n    private monoWidth;\n    private maxWidth;\n    private lineHeight;\n    private fallbackFill;\n    private caches;\n    private highlighter;\n    private selection;\n    private selectionProgress;\n    private globalProgress;\n    private fragmentDrawingInfo;\n    private fontHeight;\n    private verticalOffset;\n    constructor(node: Code);\n    /**\n     * Prepare the cursor for the next traversal.\n     *\n     * @param context - The context used to measure and draw the code.\n     */\n    setupMeasure(context: CanvasRenderingContext2D): void;\n    setupDraw(context: CanvasRenderingContext2D): void;\n    /**\n     * Measure the desired size of the code scope.\n     *\n     * @remarks\n     * The result can be retrieved with {@link getSize}.\n     *\n     * @param scope - The code scope to measure.\n     */\n    measureSize(scope: CodeScope): void;\n    /**\n     * Get the size measured by the cursor.\n     */\n    getSize(): {\n        x: number;\n        y: number;\n    };\n    /**\n     * Get the drawing information created by the cursor.\n     */\n    getDrawingInfo(): {\n        fragments: CodeFragmentDrawingInfo[];\n        verticalOffset: number;\n        fontHeight: number;\n    };\n    /**\n     * Draw the given code scope.\n     *\n     * @param scope - The code scope to draw.\n     */\n    drawScope(scope: CodeScope): void;\n    private drawToken;\n    private calculateWidth;\n    private calculateMaxWidth;\n    private currentProgress;\n    private processSelection;\n    private isSelected;\n}\n//# sourceMappingURL=CodeCursor.d.ts.map" },
  { path: "node_modules/@motion-canvas/2d/lib/code/CodeDiffer.d.ts", content: "import { CodeScope, CodeTag } from './CodeScope';\nimport { CodeTokenizer } from './CodeTokenizer';\n/**\n * A function that compares two code snippets and returns a list of\n * {@link CodeTag}s describing a transition between them.\n */\nexport type CodeDiffer = (\n/**\n * The original code scope.\n */\nfrom: CodeScope, \n/**\n * The new code scope.\n */\nto: CodeScope, \n/**\n * The inherited tokenizer to use.\n */\ntokenize: CodeTokenizer) => CodeTag[];\n/**\n * Default diffing function utilizing {@link code.patienceDiff}.\n *\n * @param from - The original code scope.\n * @param to - The new code scope.\n * @param tokenize - The inherited tokenizer to use.\n */\nexport declare function defaultDiffer(from: CodeScope, to: CodeScope, tokenize: CodeTokenizer): CodeTag[];\n//# sourceMappingURL=CodeDiffer.d.ts.map" },
  { path: "node_modules/@motion-canvas/2d/lib/code/CodeFragment.d.ts", content: "import { CodeMetrics } from './CodeMetrics';\nexport interface CodeFragment {\n    before: CodeMetrics;\n    after: CodeMetrics;\n}\nexport interface RawCodeFragment {\n    before: string;\n    after: string;\n}\nexport type PossibleCodeFragment = CodeFragment | CodeMetrics | RawCodeFragment | string;\nexport declare function metricsToFragment(value: CodeMetrics): CodeFragment;\nexport declare function parseCodeFragment(value: PossibleCodeFragment, context: CanvasRenderingContext2D, monoWidth: number): CodeFragment;\n/**\n * Create a code fragment that represents an insertion of code.\n *\n * @remarks\n * Can be used in conjunction with {@link code.CodeSignalHelpers.edit}.\n *\n * @param code - The code to insert.\n */\nexport declare function insert(code: string): RawCodeFragment;\n/**\n * Create a code fragment that represents a change from one piece of code to\n * another.\n *\n * @remarks\n * Can be used in conjunction with {@link code.CodeSignalHelpers.edit}.\n *\n * @param before - The code to change from.\n * @param after - The code to change to.\n */\nexport declare function replace(before: string, after: string): RawCodeFragment;\n/**\n * Create a code fragment that represents a removal of code.\n *\n * @remarks\n * Can be used in conjunction with {@link code.CodeSignalHelpers.edit}.\n *\n * @param code - The code to remove.\n */\nexport declare function remove(code: string): RawCodeFragment;\n//# sourceMappingURL=CodeFragment.d.ts.map" },
  { path: "node_modules/@motion-canvas/2d/lib/code/CodeHighlighter.d.ts", content: "/**\n * Describes the result of a highlight operation.\n */\nexport interface HighlightResult {\n    /**\n     * The color of the code at the given index.\n     */\n    color: string | null;\n    /**\n     * The number of characters to skip ahead.\n     *\n     * @remarks\n     * This should be used to skip to the end of the currently highlighted token.\n     * The returned style will be used for the skipped characters, and they will\n     * be drawn as one continuous string keeping emojis and ligatures intact.\n     *\n     * The returned value is the number of characters to skip ahead, not the\n     * index of the end of the token.\n     */\n    skipAhead: number;\n}\n/**\n * Describes custom highlighters used by the Code node.\n *\n * @typeParam T - The type of the cache used by the highlighter.\n */\nexport interface CodeHighlighter<T = unknown> {\n    /**\n     * Initializes the highlighter.\n     *\n     * @remarks\n     * This method is called when collecting async resources for the node.\n     * It can be called multiple times so caching the initialization is\n     * recommended.\n     *\n     * If initialization is asynchronous, a promise should be registered using\n     * {@link DependencyContext.collectPromise} and the value of `false` should\n     * be returned. The hook will be called again when the promise resolves.\n     * This process can be repeated until the value of `true` is returned which\n     * will mark the highlighter as ready.\n     */\n    initialize(): boolean;\n    /**\n     * Prepares the code for highlighting.\n     *\n     * @remarks\n     * This method is called each time the code changes. It can be used to do\n     * any preprocessing of the code before highlighting. The result of this\n     * method is cached and passed to {@link highlight} when the code is\n     * highlighted.\n     *\n     * @param code - The code to prepare.\n     */\n    prepare(code: string): T;\n    /**\n     * Highlights the code at the given index.\n     *\n     * @param index - The index of the code to highlight.\n     * @param cache - The result of {@link prepare}.\n     */\n    highlight(index: number, cache: T): HighlightResult;\n    /**\n     * Tokenize the code.\n     *\n     * @param code - The code to tokenize.\n     */\n    tokenize(code: string): string[];\n}\n//# sourceMappingURL=CodeHighlighter.d.ts.map" },
  { path: "node_modules/@motion-canvas/2d/lib/code/CodeMetrics.d.ts", content: "export interface CodeMetrics {\n    content: string;\n    newRows: number;\n    endColumn: number;\n    firstWidth: number;\n    maxWidth: number;\n    lastWidth: number;\n}\nexport declare function measureString(context: CanvasRenderingContext2D, monoWidth: number, value: string): CodeMetrics;\nexport declare function isCodeMetrics(value: any): value is CodeMetrics;\n//# sourceMappingURL=CodeMetrics.d.ts.map" },
  { path: "node_modules/@motion-canvas/2d/lib/code/CodeRange.d.ts", content: "export type CodePoint = [number, number];\nexport type CodeRange = [CodePoint, CodePoint];\nexport declare function isCodeRange(value: unknown): value is CodeRange;\n/**\n * Create a code range that spans the given lines.\n *\n * @param from - The line from which the range starts.\n * @param to - The line at which the range ends. If omitted, the range will\n *             cover only one line.\n */\nexport declare function lines(from: number, to?: number): CodeRange;\n/**\n * Create a code range that highlights the given word.\n *\n * @param line - The line at which the word appears.\n * @param from - The column at which the word starts.\n * @param length - The length of the word. If omitted, the range will cover the\n *                 rest of the line.\n */\nexport declare function word(line: number, from: number, length?: number): CodeRange;\n/**\n * Create a custom selection range.\n *\n * @param startLine - The line at which the selection starts.\n * @param startColumn - The column at which the selection starts.\n * @param endLine - The line at which the selection ends.\n * @param endColumn - The column at which the selection ends.\n */\nexport declare function pointToPoint(startLine: number, startColumn: number, endLine: number, endColumn: number): CodeRange;\nexport declare function isPointInCodeRange(point: CodePoint, range: CodeRange): boolean;\nexport declare function consolidateCodeRanges(ranges: CodeRange[]): CodeRange[];\nexport declare function inverseCodeRange(ranges: CodeRange[]): CodeRange[];\n/**\n * Find all code ranges that match the given pattern.\n *\n * @param code - The code to search in.\n * @param pattern - Either a string or a regular expression to search for.\n * @param limit - An optional limit on the number of ranges to find.\n */\nexport declare function findAllCodeRanges(code: string, pattern: string | RegExp, limit?: number): CodeRange[];\n//# sourceMappingURL=CodeRange.d.ts.map" },
  { path: "node_modules/@motion-canvas/2d/lib/code/CodeScope.d.ts", content: "import { SignalValue } from '@motion-canvas/core';\nimport { PossibleCodeFragment } from './CodeFragment';\nexport interface CodeScope {\n    progress: SignalValue<number>;\n    fragments: CodeTag[];\n}\nexport type PossibleCodeScope = CodeScope | CodeTag[] | string;\nexport type CodeTag = SignalValue<PossibleCodeFragment | CodeScope | CodeTag[]>;\nexport declare function CODE(strings: TemplateStringsArray, ...tags: CodeTag[]): CodeTag[];\nexport declare function isCodeScope(value: any): value is CodeScope;\nexport declare function parseCodeScope(value: PossibleCodeScope): CodeScope;\ntype IsAfterPredicate = ((scope: CodeScope) => boolean) | boolean;\nexport declare function resolveScope(scope: CodeScope, isAfter: IsAfterPredicate): string;\nexport declare function resolveCodeTag(wrapped: CodeTag, after: boolean, isAfter?: IsAfterPredicate): string;\nexport {};\n//# sourceMappingURL=CodeScope.d.ts.map" },
  { path: "node_modules/@motion-canvas/2d/lib/code/CodeSelection.d.ts", content: "import { CodePoint, CodeRange } from './CodeRange';\nexport type CodeSelection = CodeRange[];\nexport type PossibleCodeSelection = CodeRange | CodeRange[];\nexport declare function parseCodeSelection(value: PossibleCodeSelection): CodeSelection;\nexport declare function isPointInCodeSelection(point: CodePoint, selection: CodeSelection): boolean;\n//# sourceMappingURL=CodeSelection.d.ts.map" },
  { path: "node_modules/@motion-canvas/2d/lib/code/CodeSignal.d.ts", content: "import { Signal, SignalContext, SignalValue, ThreadGenerator, TimingFunction } from '@motion-canvas/core';\nimport { CodeHighlighter } from './CodeHighlighter';\nimport { CodePoint, CodeRange } from './CodeRange';\nimport { CodeScope, CodeTag, PossibleCodeScope } from './CodeScope';\ninterface CodeModifier<TOwner> {\n    (code: CodeTag): TOwner;\n    (code: CodeTag, duration: number): ThreadGenerator;\n    (duration?: number): TagGenerator;\n}\ninterface CodeInsert<TOwner> {\n    (point: CodePoint, code: CodeTag): TOwner;\n    (point: CodePoint, code: CodeTag, duration: number): ThreadGenerator;\n    (point: CodePoint, duration?: number): TagGenerator;\n}\ninterface CodeRemove<TOwner> {\n    (range: CodeRange): TOwner;\n    (range: CodeRange, duration: number): ThreadGenerator;\n}\ninterface CodeReplace<TOwner> {\n    (range: CodeRange, code: CodeTag): TOwner;\n    (range: CodeRange, code: CodeTag, duration: number): ThreadGenerator;\n    (range: CodeRange, duration?: number): TagGenerator;\n}\ntype TagGenerator = (strings: TemplateStringsArray, ...tags: CodeTag[]) => ThreadGenerator;\nexport interface CodeSignalHelpers<TOwner> {\n    edit(duration?: number): TagGenerator;\n    append: CodeModifier<TOwner>;\n    prepend: CodeModifier<TOwner>;\n    insert: CodeInsert<TOwner>;\n    remove: CodeRemove<TOwner>;\n    replace: CodeReplace<TOwner>;\n}\nexport type CodeSignal<TOwner> = Signal<PossibleCodeScope, CodeScope, TOwner, CodeSignalContext<TOwner>> & CodeSignalHelpers<TOwner>;\nexport declare class CodeSignalContext<TOwner> extends SignalContext<PossibleCodeScope, CodeScope, TOwner> implements CodeSignalHelpers<TOwner> {\n    private readonly highlighter?;\n    private readonly progress;\n    constructor(initial: SignalValue<PossibleCodeScope>, owner: TOwner, highlighter?: SignalValue<CodeHighlighter<unknown> | null> | undefined);\n    tweener(value: SignalValue<PossibleCodeScope>, duration: number, timingFunction: TimingFunction): ThreadGenerator;\n    edit(duration?: number): TagGenerator;\n    append(code: CodeTag): TOwner;\n    append(code: CodeTag, duration: number): ThreadGenerator;\n    append(duration?: number): TagGenerator;\n    prepend(code: CodeTag): TOwner;\n    prepend(code: CodeTag, duration: number): ThreadGenerator;\n    prepend(duration?: number): TagGenerator;\n    insert(point: CodePoint, code: CodeTag): TOwner;\n    insert(point: CodePoint, code: CodeTag, duration: number): ThreadGenerator;\n    insert(point: CodePoint, duration?: number): TagGenerator;\n    remove(range: CodeRange): TOwner;\n    remove(range: CodeRange, duration: number): ThreadGenerator;\n    replace(range: CodeRange, code: CodeTag): TOwner;\n    replace(range: CodeRange, code: CodeTag, duration: number): ThreadGenerator;\n    replace(range: CodeRange, duration?: number): TagGenerator;\n    private replaceTween;\n    private editTween;\n    private appendTween;\n    private prependTween;\n    parse(value: PossibleCodeScope): CodeScope;\n    toSignal(): CodeSignal<TOwner>;\n}\nexport declare function codeSignal(): PropertyDecorator;\nexport {};\n//# sourceMappingURL=CodeSignal.d.ts.map" },
  { path: "node_modules/@motion-canvas/2d/lib/code/CodeTokenizer.d.ts", content: "export type CodeTokenizer = (input: string) => string[];\n/**\n * Default tokenizer function used by ownerless code signals.\n *\n * @param input - The code to tokenize.\n */\nexport declare function defaultTokenize(input: string): string[];\n//# sourceMappingURL=CodeTokenizer.d.ts.map" },
  { path: "node_modules/@motion-canvas/2d/lib/code/DefaultHighlightStyle.d.ts", content: "import { HighlightStyle } from '@codemirror/language';\nexport declare const DefaultHighlightStyle: HighlightStyle;\n//# sourceMappingURL=DefaultHighlightStyle.d.ts.map" },
  { path: "node_modules/@motion-canvas/2d/lib/code/LezerHighlighter.d.ts", content: "import { HighlightStyle } from '@codemirror/language';\nimport { Parser, Tree } from '@lezer/common';\nimport { CodeHighlighter, HighlightResult } from './CodeHighlighter';\ninterface LezerCache {\n    tree: Tree;\n    code: string;\n    colorLookup: Map<string, string>;\n}\nexport declare class LezerHighlighter implements CodeHighlighter<LezerCache | null> {\n    private readonly parser;\n    private readonly style;\n    private static classRegex;\n    private readonly classLookup;\n    constructor(parser: Parser, style?: HighlightStyle);\n    initialize(): boolean;\n    prepare(code: string): LezerCache | null;\n    highlight(index: number, cache: LezerCache | null): HighlightResult;\n    tokenize(code: string): string[];\n    private getNodeId;\n}\nexport {};\n//# sourceMappingURL=LezerHighlighter.d.ts.map" },
  { path: "node_modules/@motion-canvas/2d/lib/code/diff.d.ts", content: "/**\n * Performs a patience diff on two arrays of strings, returning an object\n * containing the lines that were deleted, inserted, and potentially moved\n * lines. The plus parameter can result in a significant performance hit due\n * to additional Longest Common Substring searches.\n *\n * @param aLines - The original array of strings\n * @param bLines - The new array of strings\n * @param plus - Whether to return the moved lines\n *\n * Adapted from Jonathan \"jonTrent\" Trent's patience-diff algorithm.\n * Types and tests added by Hunter \"hhenrichsen\" Henrichsen.\n *\n * {@link https://github.com/jonTrent/PatienceDiff}\n */\nexport declare function patienceDiff(aLines: string[], bLines: string[]): {\n    lines: {\n        line: string;\n        aIndex: number;\n        bIndex: number;\n    }[];\n    lineCountDeleted: number;\n    lineCountInserted: number;\n};\n/**\n * Utility function for debugging patienceDiff.\n *\n * @internal\n */\nexport declare function printDiff(diff: ReturnType<typeof patienceDiff>): void;\n//# sourceMappingURL=diff.d.ts.map" },
  { path: "node_modules/@motion-canvas/2d/lib/code/extractRange.d.ts", content: "import { CodeRange } from './CodeRange';\nimport { CodeTag } from './CodeScope';\n/**\n * Transform the fragments to isolate the given range into its own fragment.\n *\n * @remarks\n * This function will try to preserve the original fragments, resolving them\n * only if they overlap with the range.\n *\n * @param range - The range to extract.\n * @param fragments - The fragments to transform.\n *\n * @returns A tuple containing the transformed fragments and the index of the\n *          isolated fragment within.\n */\nexport declare function extractRange(range: CodeRange, fragments: CodeTag[]): [CodeTag[], number];\n//# sourceMappingURL=extractRange.d.ts.map" },
  { path: "node_modules/@motion-canvas/2d/lib/code/index.d.ts", content: "export * from './CodeCursor';\nexport * from './CodeDiffer';\nexport * from './CodeFragment';\nexport * from './CodeHighlighter';\nexport * from './CodeRange';\nexport * from './CodeScope';\nexport * from './CodeSelection';\nexport * from './CodeSignal';\nexport * from './CodeTokenizer';\nexport * from './DefaultHighlightStyle';\nexport * from './LezerHighlighter';\nexport * from './diff';\nexport * from './extractRange';\n//# sourceMappingURL=index.d.ts.map" },
  { path: "node_modules/@motion-canvas/2d/lib/components/Bezier.d.ts", content: "import { BBox, SerializedVector2, Vector2 } from '@motion-canvas/core';\nimport { CurveProfile } from '../curves';\nimport { PolynomialSegment } from '../curves/PolynomialSegment';\nimport { DesiredLength } from '../partials';\nimport { Curve } from './Curve';\nexport interface BezierOverlayInfo {\n    curve: Path2D;\n    handleLines: Path2D;\n    controlPoints: Vector2[];\n    startPoint: Vector2;\n    endPoint: Vector2;\n}\nexport declare abstract class Bezier extends Curve {\n    profile(): CurveProfile;\n    protected abstract segment(): PolynomialSegment;\n    protected abstract overlayInfo(matrix: DOMMatrix): BezierOverlayInfo;\n    protected childrenBBox(): BBox;\n    protected desiredSize(): SerializedVector2<DesiredLength>;\n    protected offsetComputedLayout(box: BBox): BBox;\n    drawOverlay(context: CanvasRenderingContext2D, matrix: DOMMatrix): void;\n}\n//# sourceMappingURL=Bezier.d.ts.map" },
  { path: "node_modules/@motion-canvas/2d/lib/components/Camera.d.ts", content: "import { InterpolationFunction, PossibleVector2, Reference, SignalValue, SimpleSignal, ThreadGenerator, TimingFunction, Vector2 } from '@motion-canvas/core';\nimport { Curve } from './Curve';\nimport { Node, NodeProps } from './Node';\nimport { Rect, RectProps } from './Rect';\nexport interface CameraProps extends NodeProps {\n    /**\n     * {@inheritDoc Camera.scene}\n     */\n    scene?: Node;\n    /**\n     * {@inheritDoc Camera.zoom}\n     */\n    zoom?: SignalValue<number>;\n}\n/**\n * A node representing an orthographic camera.\n *\n * @preview\n * ```tsx editor\n * import {Camera, Circle, makeScene2D, Rect} from '@motion-canvas/2d';\n * import {all, createRef} from '@motion-canvas/core';\n *\n * export default makeScene2D(function* (view) {\n *   const camera = createRef<Camera>();\n *   const rect = createRef<Rect>();\n *   const circle = createRef<Circle>();\n *\n *   view.add(\n *     <>\n *       <Camera ref={camera}>\n *         <Rect\n *           ref={rect}\n *           fill={'lightseagreen'}\n *           size={100}\n *           position={[100, -50]}\n *         />\n *         <Circle\n *           ref={circle}\n *           fill={'hotpink'}\n *           size={120}\n *           position={[-100, 50]}\n *         />\n *       </Camera>\n *     </>,\n *   );\n *\n *   yield* all(\n *     camera().centerOn(rect(), 3),\n *     camera().rotation(180, 3),\n *     camera().zoom(1.8, 3),\n *   );\n *   yield* camera().centerOn(circle(), 2);\n *   yield* camera().reset(1);\n * });\n * ```\n */\nexport declare class Camera extends Node {\n    /**\n     * The scene node that the camera is rendering.\n     */\n    readonly scene: SimpleSignal<Node, this>;\n    constructor({ children, ...props }: CameraProps);\n    /**\n     * The zoom level of the camera.\n     *\n     * @defaultValue 1\n     */\n    readonly zoom: SimpleSignal<number, this>;\n    protected getZoom(): number;\n    protected setZoom(value: SignalValue<number>): void;\n    protected getDefaultZoom(): SignalValue<number> | undefined;\n    protected tweenZoom(value: SignalValue<number>, duration: number, timingFunction: TimingFunction, interpolationFunction: InterpolationFunction<number>): ThreadGenerator;\n    /**\n     * Resets the camera's position, rotation and zoom level to their original\n     * values.\n     *\n     * @param duration - The duration of the tween.\n     * @param timingFunction - The timing function to use for the tween.\n     */\n    reset(duration: number, timingFunction?: TimingFunction): ThreadGenerator;\n    /**\n     * Centers the camera on the specified position without changing the zoom\n     * level.\n     *\n     * @param position - The position to center the camera on.\n     * @param duration - The duration of the tween.\n     * @param timingFunction - The timing function to use for the tween.\n     * @param interpolationFunction - The interpolation function to use for the\n     * tween.\n     */\n    centerOn(position: PossibleVector2, duration: number, timingFunction?: TimingFunction, interpolationFunction?: InterpolationFunction<Vector2>): ThreadGenerator;\n    /**\n     * Centers the camera on the specified node without changing the zoom level.\n     *\n     * @param node - The node to center the camera on.\n     * @param duration - The duration of the tween.\n     * @param timingFunction - The timing function to use for the tween.\n     * @param interpolationFunction - The interpolation function to use for the\n     * tween.\n     */\n    centerOn(node: Node, duration: number, timingFunction?: TimingFunction, interpolationFunction?: InterpolationFunction<Vector2>): ThreadGenerator;\n    /**\n     * Makes the camera follow a path specified by the provided curve.\n     *\n     * @remarks\n     * This will not change the orientation of the camera. To make the camera\n     * orient itself along the curve, use {@link followCurveWithRotation} or\n     * {@link followCurveWithRotationReverse}.\n     *\n     * If you want to follow the curve in reverse, use {@link followCurveReverse}.\n     *\n     * @param curve - The curve to follow.\n     * @param duration - The duration of the tween.\n     * @param timing - The timing function to use for the tween.\n     */\n    followCurve(curve: Curve, duration: number, timing?: TimingFunction): ThreadGenerator;\n    /**\n     * Makes the camera follow a path specified by the provided curve in reverse.\n     *\n     * @remarks\n     * This will not change the orientation of the camera. To make the camera\n     * orient itself along the curve, use {@link followCurveWithRotation} or\n     * {@link followCurveWithRotationReverse}.\n     *\n     * If you want to follow the curve forward, use {@link followCurve}.\n     *\n     * @param curve - The curve to follow.\n     * @param duration - The duration of the tween.\n     * @param timing - The timing function to use for the tween.\n     */\n    followCurveReverse(curve: Curve, duration: number, timing?: TimingFunction): Generator<void | ThreadGenerator | Promise<any> | import(\"@motion-canvas/core\").Promisable<any>, void, any>;\n    /**\n     * Makes the camera follow a path specified by the provided curve while\n     * pointing the camera the direction of the tangent.\n     *\n     * @remarks\n     * To make the camera follow the curve without changing its orientation, use\n     * {@link followCurve} or {@link followCurveReverse}.\n     *\n     * If you want to follow the curve in reverse, use\n     * {@link followCurveWithRotationReverse}.\n     *\n     * @param curve - The curve to follow.\n     * @param duration - The duration of the tween.\n     * @param timing - The timing function to use for the tween.\n     */\n    followCurveWithRotation(curve: Curve, duration: number, timing?: TimingFunction): Generator<void | ThreadGenerator | Promise<any> | import(\"@motion-canvas/core\").Promisable<any>, void, any>;\n    /**\n     * Makes the camera follow a path specified by the provided curve in reverse\n     * while pointing the camera the direction of the tangent.\n     *\n     * @remarks\n     * To make the camera follow the curve without changing its orientation, use\n     * {@link followCurve} or {@link followCurveReverse}.\n     *\n     * If you want to follow the curve forward, use\n     * {@link followCurveWithRotation}.\n     *\n     * @param curve - The curve to follow.\n     * @param duration - The duration of the tween.\n     * @param timing - The timing function to use for the tween.\n     */\n    followCurveWithRotationReverse(curve: Curve, duration: number, timing?: TimingFunction): Generator<void | ThreadGenerator | Promise<any> | import(\"@motion-canvas/core\").Promisable<any>, void, any>;\n    protected transformContext(context: CanvasRenderingContext2D): void;\n    hit(position: Vector2): Node | null;\n    protected drawChildren(context: CanvasRenderingContext2D): void;\n    static Stage({ children, cameraRef, scene, ...props }: RectProps & {\n        cameraRef?: Reference<Camera>;\n        scene?: Node;\n    }): Rect;\n}\n//# sourceMappingURL=Camera.d.ts.map" },
  { path: "node_modules/@motion-canvas/2d/lib/components/Circle.d.ts", content: "import { BBox, SerializedVector2, SignalValue, SimpleSignal } from '@motion-canvas/core';\nimport { CurveProfile } from '../curves';\nimport { DesiredLength } from '../partials';\nimport { Curve, CurveProps } from './Curve';\nexport interface CircleProps extends CurveProps {\n    /**\n     * {@inheritDoc Circle.startAngle}\n     */\n    startAngle?: SignalValue<number>;\n    /**\n     * {@inheritDoc Circle.endAngle}\n     */\n    endAngle?: SignalValue<number>;\n    /**\n     * {@inheritDoc Circle.counterclockwise}\n     */\n    counterclockwise?: SignalValue<boolean>;\n    /**\n     * {@inheritDoc Circle.closed}\n     */\n    closed?: SignalValue<boolean>;\n}\n/**\n * A node for drawing circular shapes.\n *\n * @remarks\n * This node can be used to render shapes such as: circle, ellipse, arc, and\n * sector (pie chart).\n *\n * @preview\n * ```tsx editor\n * // snippet Simple circle\n * import {makeScene2D, Circle} from '@motion-canvas/2d';\n *\n * export default makeScene2D(function* (view) {\n *   view.add(\n *     <Circle\n *       size={160}\n *       fill={'lightseagreen'}\n *     />\n *    );\n * });\n *\n * // snippet Ellipse\n * import {makeScene2D, Circle} from '@motion-canvas/2d';\n *\n * export default makeScene2D(function* (view) {\n *   view.add(\n *     <Circle\n *       width={160}\n *       height={80}\n *       fill={'lightseagreen'}\n *     />\n *   );\n * });\n *\n * // snippet Sector (pie chart):\n * import {makeScene2D, Circle} from '@motion-canvas/2d';\n * import {createRef} from '@motion-canvas/core';\n *\n * export default makeScene2D(function* (view) {\n *   const ref = createRef<Circle>();\n *   view.add(\n *     <Circle\n *       ref={ref}\n *       size={160}\n *       fill={'lightseagreen'}\n *       startAngle={30}\n *       endAngle={270}\n *       closed={true}\n *     />\n *   );\n *\n *   yield* ref().startAngle(270, 2).to(30, 2);\n * });\n *\n * // snippet Arc:\n * import {makeScene2D, Circle} from '@motion-canvas/2d';\n * import {createRef} from '@motion-canvas/core';\n *\n * export default makeScene2D(function* (view) {\n *   const ref = createRef<Circle>();\n *   view.add(\n *     <Circle\n *       ref={ref}\n *       size={160}\n *       stroke={'lightseagreen'}\n *       lineWidth={8}\n *       startAngle={-90}\n *       endAngle={90}\n *     />\n *   );\n *\n *   yield* ref().startAngle(-270, 2).to(-90, 2);\n * });\n *\n * // snippet Curve properties:\n * import {makeScene2D, Circle} from '@motion-canvas/2d';\n * import {all, createRef, easeInCubic, easeOutCubic} from '@motion-canvas/core';\n *\n * export default makeScene2D(function* (view) {\n *   const ref = createRef<Circle>();\n *   view.add(\n *     <Circle\n *       ref={ref}\n *       size={160}\n *       stroke={'lightseagreen'}\n *       lineWidth={8}\n *       endAngle={270}\n *       endArrow\n *     />,\n *   );\n *\n *   yield* all(ref().start(1, 1), ref().rotation(180, 1, easeInCubic));\n *   ref().start(0).end(0);\n *   yield* all(ref().end(1, 1), ref().rotation(360, 1, easeOutCubic));\n * });\n * ```\n */\nexport declare class Circle extends Curve {\n    /**\n     * The starting angle in degrees for the circle sector.\n     *\n     * @remarks\n     * This property can be used together with {@link startAngle} to turn this\n     * circle into a sector (when using fill) or an arc (when using stroke).\n     *\n     * @defaultValue 0\n     */\n    readonly startAngle: SimpleSignal<number, this>;\n    /**\n     * The ending angle in degrees for the circle sector.\n     *\n     * @remarks\n     * This property can be used together with {@link endAngle} to turn this\n     * circle into a sector (when using fill) or an arc (when using stroke).\n     *\n     * @defaultValue 360\n     */\n    readonly endAngle: SimpleSignal<number, this>;\n    /**\n     * Whether the circle sector should be drawn counterclockwise.\n     *\n     * @remarks\n     * By default, the circle begins at {@link startAngle} and is drawn clockwise\n     * until reaching {@link endAngle}. Setting this property to true will reverse\n     * this direction.\n     */\n    readonly counterclockwise: SimpleSignal<boolean, this>;\n    /**\n     * Whether the path of this circle should be closed.\n     *\n     * @remarks\n     * When set to true, the path of this circle will start and end at the center.\n     * This can be used to fine-tune how sectors are rendered.\n     *\n     * @example\n     * A closed circle will look like a pie chart:\n     * ```tsx\n     * <Circle\n     *   size={300}\n     *   fill={'lightseagreen'}\n     *   endAngle={230}\n     *   closed={true}\n     * />\n     * ```\n     * An open one will look like an arc:\n     * ```tsx\n     * <Circle\n     *   size={300}\n     *   stroke={'lightseagreen'}\n     *   lineWidth={8}\n     *   endAngle={230}\n     *   closed={false}\n     * />\n     * ```\n     *\n     * @defaultValue false\n     */\n    readonly closed: SimpleSignal<boolean, this>;\n    constructor(props: CircleProps);\n    profile(): CurveProfile;\n    protected desiredSize(): SerializedVector2<DesiredLength>;\n    protected offsetComputedLayout(box: BBox): BBox;\n    protected childrenBBox(): BBox;\n    protected getPath(): Path2D;\n    protected getRipplePath(): Path2D;\n    protected getCacheBBox(): BBox;\n    protected createPath(expand?: number): Path2D;\n}\n//# sourceMappingURL=Circle.d.ts.map" },
  { path: "node_modules/@motion-canvas/2d/lib/components/Code.d.ts", content: "import { BBox, SerializedVector2, Signal, SignalValue, SimpleSignal, ThreadGenerator, TimingFunction, Vector2 } from '@motion-canvas/core';\nimport { CodeFragmentDrawingInfo, CodeHighlighter, CodePoint, CodeRange, CodeSelection, CodeSignal, PossibleCodeScope, PossibleCodeSelection } from '../code';\nimport { DesiredLength } from '../partials';\nimport { Shape, ShapeProps } from './Shape';\n/**\n * @experimental\n */\nexport interface DrawTokenHook {\n    (ctx: CanvasRenderingContext2D, text: string, position: Vector2, color: string, selection: number): void;\n}\n/**\n * Describes custom drawing logic used by the Code node.\n *\n * @experimental\n */\nexport interface DrawHooks {\n    /**\n     * Custom drawing logic for individual code tokens.\n     *\n     * @example\n     * ```ts\n     * token(ctx, text, position, color, selection) {\n     *   const blur = map(3, 0, selection);\n     *   const alpha = map(0.5, 1, selection);\n     *   ctx.globalAlpha *= alpha;\n     *   ctx.filter = `blur(${blur}px)`;\n     *   ctx.fillStyle = color;\n     *   ctx.fillText(text, position.x, position.y);\n     * }\n     * ```\n     */\n    token: DrawTokenHook;\n}\nexport interface CodeProps extends ShapeProps {\n    /**\n     * {@inheritDoc Code.highlighter}\n     */\n    highlighter?: SignalValue<CodeHighlighter | null>;\n    /**\n     * {@inheritDoc Code.code}\n     */\n    code?: SignalValue<PossibleCodeScope>;\n    /**\n     * {@inheritDoc Code.selection}\n     */\n    selection?: SignalValue<PossibleCodeSelection>;\n    /**\n     * {@inheritDoc Code.drawHooks}\n     */\n    drawHooks?: SignalValue<DrawHooks>;\n}\n/**\n * A node for displaying and animating code.\n *\n * @preview\n * ```tsx editor\n * import {Code, makeScene2D} from '@motion-canvas/2d';\n * import {createRef} from '@motion-canvas/core';\n *\n * export default makeScene2D(function* (view) {\n *   const code = createRef<Code>();\n *\n *   view.add(\n *     <Code\n *       ref={code}\n *       offset={-1}\n *       position={view.size().scale(-0.5).add(60)}\n *       fontFamily={'JetBrains Mono, monospace'}\n *       fontSize={36}\n *       code={`\\\n * function hello() {\n *   console.log('Hello');\n * }`}\n *     />,\n *   );\n *\n *   yield* code()\n *     .code(\n *       `\\\n * function hello() {\n *   console.warn('Hello World');\n * }`,\n *       1,\n *     )\n *     .wait(0.5)\n *     .back(1)\n *     .wait(0.5);\n * });\n * ```\n */\nexport declare class Code extends Shape {\n    /**\n     * Create a standalone code signal.\n     *\n     * @param initial - The initial code.\n     * @param highlighter - Custom highlighter to use.\n     */\n    static createSignal(initial: SignalValue<PossibleCodeScope>, highlighter?: SignalValue<CodeHighlighter>): CodeSignal<void>;\n    static defaultHighlighter: CodeHighlighter | null;\n    /**\n     * The code highlighter to use for this code node.\n     *\n     * @remarks\n     * Defaults to a shared {@link code.LezerHighlighter}.\n     */\n    readonly highlighter: SimpleSignal<CodeHighlighter | null, this>;\n    /**\n     * The code to display.\n     */\n    readonly code: CodeSignal<this>;\n    /**\n     * Custom drawing logic for the code.\n     *\n     * @remarks\n     * Check out {@link DrawHooks} for available render hooks.\n     *\n     * @experimental\n     *\n     * @example\n     * Make the unselected code blurry and transparent:\n     * ```tsx\n     * <Code\n     *   drawHooks={{\n     *     token(ctx, text, position, color, selection) {\n     *       const blur = map(3, 0, selection);\n     *       const alpha = map(0.5, 1, selection);\n     *       ctx.globalAlpha *= alpha;\n     *       ctx.filter = `blur(${blur}px)`;\n     *       ctx.fillStyle = color;\n     *       ctx.fillText(text, position.x, position.y);\n     *     },\n     *   }}\n     *   // ...\n     * />\n     * ```\n     */\n    readonly drawHooks: SimpleSignal<DrawHooks, this>;\n    protected setDrawHooks(value: DrawHooks): void;\n    /**\n     * The currently selected code range.\n     *\n     * @remarks\n     * Either a single {@link code.CodeRange} or an array of them\n     * describing which parts of the code should be visually emphasized.\n     *\n     * You can use {@link code.word} and\n     * {@link code.lines} to quickly create ranges.\n     *\n     * @example\n     * The following will select the word \"console\" in the code.\n     * Both lines and columns are 0-based. So it will select a 7-character-long\n     * (`7`) word in the second line (`1`) starting at the third character (`2`).\n     * ```tsx\n     * <Code\n     *   selection={word(1, 2, 7)}\n     *   code={`\\\n     * function hello() => {\n     *   console.log('Hello');\n     * }`}\n     *   // ...\n     * />\n     * ```\n     */\n    readonly selection: Signal<PossibleCodeSelection, CodeSelection, this>;\n    oldSelection: CodeSelection | null;\n    selectionProgress: SimpleSignal<number | null, void>;\n    protected tweenSelection(value: CodeRange[], duration: number, timingFunction: TimingFunction): ThreadGenerator;\n    /**\n     * Get the currently displayed code as a string.\n     */\n    parsed(): string;\n    highlighterCache(): {\n        before: unknown;\n        after: unknown;\n    } | null;\n    private cursorCache;\n    private get cursor();\n    constructor(props: CodeProps);\n    /**\n     * Create a child code signal.\n     *\n     * @param initial - The initial code.\n     */\n    createSignal(initial: SignalValue<PossibleCodeScope>): CodeSignal<this>;\n    /**\n     * Find all code ranges that match the given pattern.\n     *\n     * @param pattern - Either a string or a regular expression to match.\n     */\n    findAllRanges(pattern: string | RegExp): CodeRange[];\n    /**\n     * Find the first code range that matches the given pattern.\n     *\n     * @param pattern - Either a string or a regular expression to match.\n     */\n    findFirstRange(pattern: string | RegExp): CodeRange;\n    /**\n     * Find the last code range that matches the given pattern.\n     *\n     * @param pattern - Either a string or a regular expression to match.\n     */\n    findLastRange(pattern: string | RegExp): CodeRange;\n    /**\n     * Return the bounding box of the given point (character) in the code.\n     *\n     * @remarks\n     * The returned bound box is in local space of the `Code` node.\n     *\n     * @param point - The point to get the bounding box for.\n     */\n    getPointBBox(point: CodePoint): BBox;\n    /**\n     * Return bounding boxes of all characters in the selection.\n     *\n     * @remarks\n     * The returned bounding boxes are in local space of the `Code` node.\n     * Each line of code has a separate bounding box.\n     *\n     * @param selection - The selection to get the bounding boxes for.\n     */\n    getSelectionBBox(selection: PossibleCodeSelection): BBox[];\n    protected drawingInfo(): {\n        fragments: CodeFragmentDrawingInfo[];\n        verticalOffset: number;\n        fontHeight: number;\n    };\n    protected desiredSize(): SerializedVector2<DesiredLength>;\n    protected draw(context: CanvasRenderingContext2D): void;\n    protected applyText(context: CanvasRenderingContext2D): void;\n    protected collectAsyncResources(): void;\n}\n//# sourceMappingURL=Code.d.ts.map" },
  { path: "node_modules/@motion-canvas/2d/lib/components/CodeBlock.d.ts", content: "import { SerializedVector2, Signal, SignalValue, SimpleSignal, ThreadGenerator, TimingFunction, Vector2 } from '@motion-canvas/core';\nimport { Code, CodeStyle, CodeTree, Token } from 'code-fns';\nimport { DesiredLength } from '../partials';\nimport { Shape, ShapeProps } from './Shape';\ntype CodePoint = [number, number];\ntype CodeRange = [CodePoint, CodePoint];\nexport interface CodeProps extends ShapeProps {\n    language?: string;\n    children?: Code;\n    code?: SignalValue<Code>;\n    selection?: CodeRange[];\n    theme?: CodeStyle;\n}\nexport interface CodeModification {\n    from: Code;\n    to: Code;\n}\n/**\n * @deprecated Use {@link Code} instead.\n */\nexport declare class CodeBlock extends Shape {\n    private static initialized;\n    readonly language: SimpleSignal<string, this>;\n    readonly code: Signal<Code, CodeTree, this>;\n    readonly theme: Signal<CodeStyle | null, CodeStyle, this>;\n    readonly selection: SimpleSignal<CodeRange[], this>;\n    protected tweenSelection(value: CodeRange[], duration: number, timingFunction: TimingFunction): ThreadGenerator;\n    readonly unselectedOpacity: SimpleSignal<number, this>;\n    private codeProgress;\n    private selectionProgress;\n    private oldSelection;\n    private diffed;\n    private currentLineCount;\n    private newLineCount;\n    protected getLineCountOfTokenArray(tokens: Token[]): number;\n    lineCount(): number;\n    protected parsed(): Token[];\n    constructor({ children, ...rest }: CodeProps);\n    protected characterSize(): Vector2;\n    protected desiredSize(): SerializedVector2<DesiredLength>;\n    protected getTokensSize(tokens: Token[]): {\n        x: number;\n        y: number;\n    };\n    protected collectAsyncResources(): void;\n    set(strings: string[], ...rest: any[]): void;\n    /**\n     * Smoothly edit the code.\n     *\n     * @remarks\n     * This method returns a tag function that should be used together with a\n     * template literal to define what to edit. Expressions can be used to either\n     * {@link insert}, {@link remove}, or {@link edit} the code.\n     *\n     * @example\n     * ```ts\n     * yield* codeBlock().edit()`\n     *   const ${edit('a', 'b')} = [${insert('1, 2, 3')}];${remove(`\n     *   // this comment will be removed`)}\n     * `;\n     * ```\n     *\n     * @param duration - The duration of the transition.\n     * @param changeSelection - When set to `true`, the selection will be modified\n     *                          to highlight the newly inserted code. Setting it\n     *                          to `false` leaves the selection untouched.\n     *                          Providing a custom {@link CodeRange} will select\n     *                          it instead.\n     */\n    edit(duration?: number, changeSelection?: CodeRange[] | boolean): (strings: TemplateStringsArray, ...rest: (Code | CodeModification)[]) => ThreadGenerator;\n    tweenCode(code: CodeTree, time: number, timingFunction: TimingFunction): Generator<void | ThreadGenerator | Promise<any> | import(\"@motion-canvas/core\").Promisable<any>, void, any>;\n    protected draw(context: CanvasRenderingContext2D): void;\n    protected selectionStrength(x: number, y: number): number;\n    protected static selectionStrength(selection: CodeRange[], x: number, y: number): number;\n}\n/**\n * Create a code modification that inserts a piece of code.\n *\n * @remarks\n * Should be used in conjunction with {@link CodeBlock.edit}.\n *\n * @param content - The code to insert.\n */\nexport declare function insert(content: Code): CodeModification;\n/**\n * Create a code modification that removes a piece of code.\n *\n * @remarks\n * Should be used in conjunction with {@link CodeBlock.edit}.\n *\n * @param content - The code to remove.\n */\nexport declare function remove(content: Code): CodeModification;\n/**\n * Create a code modification that changes one piece of code into another.\n *\n * @remarks\n * Should be used in conjunction with {@link CodeBlock.edit}.\n *\n * @param from - The code to change from.\n * @param to - The code to change to.\n */\nexport declare function edit(from: Code, to: Code): CodeModification;\n/**\n * Create a selection range that highlights the given lines.\n *\n * @param from - The line from which the selection starts.\n * @param to - The line at which the selection ends. If omitted, the selection\n *             will cover only one line.\n */\nexport declare function lines(from: number, to?: number): CodeRange[];\n/**\n * Create a selection range that highlights the given word.\n *\n * @param line - The line at which the word appears.\n * @param from - The column at which the word starts.\n * @param length - The length of the word. If omitted, the selection will cover\n *                 the rest of the line.\n */\nexport declare function word(line: number, from: number, length?: number): CodeRange[];\n/**\n * Create a custom selection range.\n *\n * @param startLine - The line at which the selection starts.\n * @param startColumn - The column at which the selection starts.\n * @param endLine - The line at which the selection ends.\n * @param endColumn - The column at which the selection ends.\n */\nexport declare function range(startLine: number, startColumn: number, endLine: number, endColumn: number): CodeRange[];\nexport {};\n//# sourceMappingURL=CodeBlock.d.ts.map" },
  { path: "node_modules/@motion-canvas/2d/lib/components/CubicBezier.d.ts", content: "import { PossibleVector2, SignalValue, Vector2Signal } from '@motion-canvas/core';\nimport { PolynomialSegment } from '../curves/PolynomialSegment';\nimport { Bezier, BezierOverlayInfo } from './Bezier';\nimport { CurveProps } from './Curve';\nexport interface CubicBezierProps extends CurveProps {\n    p0?: SignalValue<PossibleVector2>;\n    p0X?: SignalValue<number>;\n    p0Y?: SignalValue<number>;\n    p1?: SignalValue<PossibleVector2>;\n    p1X?: SignalValue<number>;\n    p1Y?: SignalValue<number>;\n    p2?: SignalValue<PossibleVector2>;\n    p2X?: SignalValue<number>;\n    p2Y?: SignalValue<number>;\n    p3?: SignalValue<PossibleVector2>;\n    p3X?: SignalValue<number>;\n    p3Y?: SignalValue<number>;\n}\n/**\n * A node for drawing a cubic Bézier curve.\n *\n * @preview\n * ```tsx editor\n * import {makeScene2D, CubicBezier} from '@motion-canvas/2d';\n * import {createRef} from '@motion-canvas/core';\n *\n * export default makeScene2D(function* (view) {\n *   const bezier = createRef<CubicBezier>();\n *\n *   view.add(\n *     <CubicBezier\n *       ref={bezier}\n *       lineWidth={4}\n *       stroke={'lightseagreen'}\n *       p0={[-200, -100]}\n *       p1={[100, -100]}\n *       p2={[-100, 100]}\n *       p3={[200, 100]}\n *       end={0}\n *     />\n *   );\n *\n *   yield* bezier().end(1, 1);\n *   yield* bezier().start(1, 1).to(0, 1);\n * });\n * ```\n */\nexport declare class CubicBezier extends Bezier {\n    /**\n     * The start point of the Bézier curve.\n     */\n    readonly p0: Vector2Signal<this>;\n    /**\n     * The first control point of the Bézier curve.\n     */\n    readonly p1: Vector2Signal<this>;\n    /**\n     * The second control point of the Bézier curve.\n     */\n    readonly p2: Vector2Signal<this>;\n    /**\n     * The end point of the Bézier curve.\n     */\n    readonly p3: Vector2Signal<this>;\n    constructor(props: CubicBezierProps);\n    protected segment(): PolynomialSegment;\n    protected overlayInfo(matrix: DOMMatrix): BezierOverlayInfo;\n}\n//# sourceMappingURL=CubicBezier.d.ts.map" },
  { path: "node_modules/@motion-canvas/2d/lib/components/Curve.d.ts", content: "import { BBox, SerializedVector2, SignalValue, SimpleSignal, Vector2 } from '@motion-canvas/core';\nimport { CurveDrawingInfo } from '../curves/CurveDrawingInfo';\nimport { CurvePoint } from '../curves/CurvePoint';\nimport { CurveProfile } from '../curves/CurveProfile';\nimport { DesiredLength } from '../partials';\nimport { Shape, ShapeProps } from './Shape';\nexport interface CurveProps extends ShapeProps {\n    /**\n     * {@inheritDoc Curve.closed}\n     */\n    closed?: SignalValue<boolean>;\n    /**\n     * {@inheritDoc Curve.start}\n     */\n    start?: SignalValue<number>;\n    /**\n     * {@inheritDoc Curve.startOffset}\n     */\n    startOffset?: SignalValue<number>;\n    /**\n     * {@inheritDoc Curve.startArrow}\n     */\n    startArrow?: SignalValue<boolean>;\n    /**\n     * {@inheritDoc Curve.end}\n     */\n    end?: SignalValue<number>;\n    /**\n     * {@inheritDoc Curve.endOffset}\n     */\n    endOffset?: SignalValue<number>;\n    /**\n     * {@inheritDoc Curve.endArrow}\n     */\n    endArrow?: SignalValue<boolean>;\n    /**\n     * {@inheritDoc Curve.arrowSize}\n     */\n    arrowSize?: SignalValue<number>;\n}\nexport declare abstract class Curve extends Shape {\n    /**\n     * Whether the curve should be closed.\n     *\n     * @remarks\n     * Closed curves have their start and end points connected.\n     */\n    readonly closed: SimpleSignal<boolean, this>;\n    /**\n     * A percentage from the start before which the curve should be clipped.\n     *\n     * @remarks\n     * The portion of the curve that comes before the given percentage will be\n     * made invisible.\n     *\n     * This property is usefully for animating the curve appearing on the screen.\n     * The value of `0` means the very start of the curve (accounting for the\n     * {@link startOffset}) while `1` means the very end (accounting for the\n     * {@link endOffset}).\n     */\n    readonly start: SimpleSignal<number, this>;\n    /**\n     * The offset in pixels from the start of the curve.\n     *\n     * @remarks\n     * This property lets you specify where along the defined curve the actual\n     * visible portion starts. For example, setting it to `20` will make the first\n     * 20 pixels of the curve invisible.\n     *\n     * This property is useful for trimming the curve using a fixed distance.\n     * If you want to animate the curve appearing on the screen, use {@link start}\n     * instead.\n     */\n    readonly startOffset: SimpleSignal<number, this>;\n    /**\n     * Whether to display an arrow at the start of the visible curve.\n     *\n     * @remarks\n     * Use {@link arrowSize} to control the size of the arrow.\n     */\n    readonly startArrow: SimpleSignal<boolean, this>;\n    /**\n     * A percentage from the start after which the curve should be clipped.\n     *\n     * @remarks\n     * The portion of the curve that comes after the given percentage will be\n     * made invisible.\n     *\n     * This property is usefully for animating the curve appearing on the screen.\n     * The value of `0` means the very start of the curve (accounting for the\n     * {@link startOffset}) while `1` means the very end (accounting for the\n     * {@link endOffset}).\n     */\n    readonly end: SimpleSignal<number, this>;\n    /**\n     * The offset in pixels from the end of the curve.\n     *\n     * @remarks\n     * This property lets you specify where along the defined curve the actual\n     * visible portion ends. For example, setting it to `20` will make the last\n     * 20 pixels of the curve invisible.\n     *\n     * This property is useful for trimming the curve using a fixed distance.\n     * If you want to animate the curve appearing on the screen, use {@link end}\n     * instead.\n     */\n    readonly endOffset: SimpleSignal<number, this>;\n    /**\n     * Whether to display an arrow at the end of the visible curve.\n     *\n     * @remarks\n     * Use {@link arrowSize} to control the size of the arrow.\n     */\n    readonly endArrow: SimpleSignal<boolean, this>;\n    /**\n     * Controls the size of the end and start arrows.\n     *\n     * @remarks\n     * To make the arrows visible make sure to enable {@link startArrow} and/or\n     * {@link endArrow}.\n     */\n    readonly arrowSize: SimpleSignal<number, this>;\n    protected canHaveSubpath: boolean;\n    protected desiredSize(): SerializedVector2<DesiredLength>;\n    constructor(props: CurveProps);\n    protected abstract childrenBBox(): BBox;\n    abstract profile(): CurveProfile;\n    /**\n     * Convert a percentage along the curve to a distance.\n     *\n     * @remarks\n     * The returned distance is given in relation to the full curve, not\n     * accounting for {@link startOffset} and {@link endOffset}.\n     *\n     * @param value - The percentage along the curve.\n     */\n    percentageToDistance(value: number): number;\n    /**\n     * Convert a distance along the curve to a percentage.\n     *\n     * @remarks\n     * The distance should be given in relation to the full curve, not\n     * accounting for {@link startOffset} and {@link endOffset}.\n     *\n     * @param value - The distance along the curve.\n     */\n    distanceToPercentage(value: number): number;\n    /**\n     * The base arc length of this curve.\n     *\n     * @remarks\n     * This is the entire length of this curve, not accounting for\n     * {@link startOffset | the offsets}.\n     */\n    baseArcLength(): number;\n    /**\n     * The offset arc length of this curve.\n     *\n     * @remarks\n     * This is the length of the curve that accounts for\n     * {@link startOffset | the offsets}.\n     */\n    offsetArcLength(): number;\n    /**\n     * The visible arc length of this curve.\n     *\n     * @remarks\n     * This arc length accounts for both the offset and the {@link start} and\n     * {@link end} properties.\n     */\n    arcLength(): number;\n    /**\n     * The percentage of the curve that's currently visible.\n     *\n     * @remarks\n     * The returned value is the ratio between the visible length (as defined by\n     * {@link start} and {@link end}) and the offset length of the curve.\n     */\n    completion(): number;\n    protected processSubpath(_path: Path2D, _startPoint: Vector2 | null, _endPoint: Vector2 | null): void;\n    protected curveDrawingInfo(): CurveDrawingInfo;\n    protected getPointAtDistance(value: number): CurvePoint;\n    getPointAtPercentage(value: number): CurvePoint;\n    protected getComputedLayout(): BBox;\n    protected offsetComputedLayout(box: BBox): BBox;\n    protected getPath(): Path2D;\n    protected getCacheBBox(): BBox;\n    protected lineWidthCoefficient(): number;\n    /**\n     * Check if the path requires a profile.\n     *\n     * @remarks\n     * The profile is only required if certain features are used. Otherwise, the\n     * profile generation can be skipped, and the curve can be drawn directly\n     * using the 2D context.\n     */\n    protected requiresProfile(): boolean;\n    protected drawShape(context: CanvasRenderingContext2D): void;\n    private drawArrows;\n    private drawArrow;\n}\n//# sourceMappingURL=Curve.d.ts.map" },
  { path: "node_modules/@motion-canvas/2d/lib/components/Grid.d.ts", content: "import { PossibleVector2, SignalValue, SimpleSignal, Vector2Signal } from '@motion-canvas/core';\nimport { Shape, ShapeProps } from './Shape';\nexport interface GridProps extends ShapeProps {\n    /**\n     * {@inheritDoc Grid.spacing}\n     */\n    spacing?: SignalValue<PossibleVector2>;\n    /**\n     * {@inheritDoc Grid.start}\n     */\n    start?: SignalValue<number>;\n    /**\n     * {@inheritDoc Grid.end}\n     */\n    end?: SignalValue<number>;\n}\n/**\n * A node for drawing a two-dimensional grid.\n *\n * @preview\n * ```tsx editor\n * import {Grid, makeScene2D} from '@motion-canvas/2d';\n * import {all, createRef} from '@motion-canvas/core';\n *\n * export default makeScene2D(function* (view) {\n *   const grid = createRef<Grid>();\n *\n *   view.add(\n *     <Grid\n *       ref={grid}\n *       width={'100%'}\n *       height={'100%'}\n *       stroke={'#666'}\n *       start={0}\n *       end={1}\n *     />,\n *   );\n *\n *   yield* all(\n *     grid().end(0.5, 1).to(1, 1).wait(1),\n *     grid().start(0.5, 1).to(0, 1).wait(1),\n *   );\n * });\n * ```\n */\nexport declare class Grid extends Shape {\n    /**\n     * The spacing between the grid lines.\n     */\n    readonly spacing: Vector2Signal<this>;\n    /**\n     * The percentage that should be clipped from the beginning of each grid line.\n     *\n     * @remarks\n     * The portion of each grid line that comes before the given percentage will\n     * be made invisible.\n     *\n     * This property is useful for animating the grid appearing on-screen.\n     */\n    readonly start: SimpleSignal<number, this>;\n    /**\n     * The percentage that should be clipped from the end of each grid line.\n     *\n     * @remarks\n     * The portion of each grid line that comes after the given percentage will\n     * be made invisible.\n     *\n     * This property is useful for animating the grid appearing on-screen.\n     */\n    readonly end: SimpleSignal<number, this>;\n    constructor(props: GridProps);\n    protected drawShape(context: CanvasRenderingContext2D): void;\n    private mapPoints;\n}\n//# sourceMappingURL=Grid.d.ts.map" },
  { path: "node_modules/@motion-canvas/2d/lib/components/Icon.d.ts", content: "import { ColorSignal, PossibleColor, SignalValue, SimpleSignal } from '@motion-canvas/core';\nimport { Img, ImgProps } from './Img';\nexport interface IconProps extends ImgProps {\n    /**\n     * {@inheritDoc Icon.icon}\n     */\n    icon: SignalValue<string>;\n    /**\n     * {@inheritDoc Icon.color}\n     */\n    color?: SignalValue<PossibleColor>;\n}\n/**\n * An Icon Component that provides easy access to over 150k icons.\n * See https://icones.js.org/collection/all for all available Icons.\n */\nexport declare class Icon extends Img {\n    /**\n     * The identifier of the icon.\n     *\n     * @remarks\n     * You can find identifiers on [Icônes](https://icones.js.org).\n     * They can look like this:\n     * * `mdi:language-typescript`\n     * * `ph:anchor-simple-bold`\n     * * `ph:activity-bold`\n     */\n    icon: SimpleSignal<string, this>;\n    /**\n     * The color of the icon\n     *\n     * @remarks\n     * Provide the color in one of the following formats:\n     * * named color like `red`, `darkgray`, …\n     * * hexadecimal string with # like `#bada55`, `#141414`\n     *   Value can be either RGB or RGBA: `#bada55`, `#bada55aa` (latter is partially transparent)\n     *   The shorthand version (e.g. `#abc` for `#aabbcc` is also possible.)\n     *\n     * @defaultValue 'white'\n     */\n    color: ColorSignal<this>;\n    constructor(props: IconProps);\n    /**\n     * Create the URL that will be used as the Image source\n     * @returns Address to Iconify API for the requested Icon.\n     */\n    protected svgUrl(): string;\n    /**\n     * overrides `Image.src` getter\n     */\n    protected getSrc(): string;\n    /**\n     * overrides `Image.src` setter to warn the user that the value\n     * is not used\n     */\n    protected setSrc(src: string | null): void;\n}\n//# sourceMappingURL=Icon.d.ts.map" },
  { path: "node_modules/@motion-canvas/2d/lib/components/Img.d.ts", content: "import { Color, PossibleVector2, SerializedVector2, SignalValue, SimpleSignal, Vector2 } from '@motion-canvas/core';\nimport { DesiredLength } from '../partials';\nimport { Rect, RectProps } from './Rect';\nexport interface ImgProps extends RectProps {\n    /**\n     * {@inheritDoc Img.src}\n     */\n    src?: SignalValue<string | null>;\n    /**\n     * {@inheritDoc Img.alpha}\n     */\n    alpha?: SignalValue<number>;\n    /**\n     * {@inheritDoc Img.smoothing}\n     */\n    smoothing?: SignalValue<boolean>;\n}\n/**\n * A node for displaying images.\n *\n * @preview\n * ```tsx editor\n * import {Img} from '@motion-canvas/2d';\n * import {all, waitFor} from '@motion-canvas/core';\n * import {createRef} from '@motion-canvas/core';\n * import {makeScene2D} from '@motion-canvas/2d';\n *\n * export default makeScene2D(function* (view) {\n *   const ref = createRef<Img>();\n *   yield view.add(\n *     <Img\n *       ref={ref}\n *       src=\"https://images.unsplash.com/photo-1679218407381-a6f1660d60e9\"\n *       width={300}\n *       radius={20}\n *     />,\n *   );\n *\n *   // set the background using the color sampled from the image:\n *   ref().fill(ref().getColorAtPoint(0));\n *\n *   yield* all(\n *     ref().size([100, 100], 1).to([300, null], 1),\n *     ref().radius(50, 1).to(20, 1),\n *     ref().alpha(0, 1).to(1, 1),\n *   );\n *   yield* waitFor(0.5);\n * });\n * ```\n */\nexport declare class Img extends Rect {\n    private static pool;\n    /**\n     * The source of this image.\n     *\n     * @example\n     * Using a local image:\n     * ```tsx\n     * import image from './example.png';\n     * // ...\n     * view.add(<Img src={image} />)\n     * ```\n     * Loading an image from the internet:\n     * ```tsx\n     * view.add(<Img src=\"https://example.com/image.png\" />)\n     * ```\n     */\n    readonly src: SimpleSignal<string, this>;\n    /**\n     * The alpha value of this image.\n     *\n     * @remarks\n     * Unlike opacity, the alpha value affects only the image itself, leaving the\n     * fill, stroke, and children intact.\n     */\n    readonly alpha: SimpleSignal<number, this>;\n    /**\n     * Whether the image should be smoothed.\n     *\n     * @remarks\n     * When disabled, the image will be scaled using the nearest neighbor\n     * interpolation with no smoothing. The resulting image will appear pixelated.\n     *\n     * @defaultValue true\n     */\n    readonly smoothing: SimpleSignal<boolean, this>;\n    constructor(props: ImgProps);\n    protected desiredSize(): SerializedVector2<DesiredLength>;\n    protected image(): HTMLImageElement;\n    protected imageCanvas(): CanvasRenderingContext2D;\n    protected filledImageCanvas(): CanvasRenderingContext2D;\n    protected draw(context: CanvasRenderingContext2D): void;\n    protected applyFlex(): void;\n    /**\n     * Get color of the image at the given position.\n     *\n     * @param position - The position in local space at which to sample the color.\n     */\n    getColorAtPoint(position: PossibleVector2): Color;\n    /**\n     * The natural size of this image.\n     *\n     * @remarks\n     * The natural size is the size of the source image unaffected by the size\n     * and scale properties.\n     */\n    naturalSize(): Vector2;\n    /**\n     * Get color of the image at the given pixel.\n     *\n     * @param position - The pixel's position.\n     */\n    getPixelColor(position: PossibleVector2): Color;\n    protected collectAsyncResources(): void;\n}\n//# sourceMappingURL=Img.d.ts.map" },
  { path: "node_modules/@motion-canvas/2d/lib/components/Knot.d.ts", content: "import { PossibleVector2, Signal, SignalValue, Vector2Signal } from '@motion-canvas/core';\nimport { KnotInfo } from '../curves';\nimport { Node, NodeProps } from './Node';\nexport interface KnotProps extends NodeProps {\n    /**\n     * {@inheritDoc Knot.startHandle}\n     */\n    startHandle?: SignalValue<PossibleVector2>;\n    /**\n     * {@inheritDoc Knot.endHandle}\n     */\n    endHandle?: SignalValue<PossibleVector2>;\n    /**\n     * {@inheritDoc Knot.auto}\n     */\n    auto?: SignalValue<PossibleKnotAuto>;\n    startHandleAuto?: SignalValue<number>;\n    endHandleAuto?: SignalValue<number>;\n}\nexport type KnotAuto = {\n    startHandle: number;\n    endHandle: number;\n};\nexport type PossibleKnotAuto = KnotAuto | number | [number, number];\nexport type KnotAutoSignal<TOwner> = Signal<PossibleKnotAuto, KnotAuto, TOwner> & {\n    endHandle: Signal<number, number, TOwner>;\n    startHandle: Signal<number, number, TOwner>;\n};\n/**\n * A node representing a knot of a {@link Spline}.\n */\nexport declare class Knot extends Node {\n    /**\n     * The position of the knot's start handle. The position is provided relative\n     * to the knot's position.\n     *\n     * @remarks\n     * By default, the position of the start handle will be the mirrored position\n     * of the {@link endHandle}.\n     *\n     * If neither an end handle nor a start handle is provided, the positions of\n     * the handles gets calculated automatically to create smooth curve through\n     * the knot. The smoothness of the resulting curve can be controlled via the\n     * {@link Spline.smoothness} property.\n     *\n     * It is also possible to blend between a user-defined position and the\n     * auto-calculated position by using the {@link auto} property.\n     *\n     * @defaultValue Mirrored position of the endHandle.\n     */\n    readonly startHandle: Vector2Signal<this>;\n    /**\n     * The position of the knot's end handle. The position is provided relative\n     * to the knot's position.\n     *\n     * @remarks\n     * By default, the position of the end handle will be the mirrored position\n     * of the {@link startHandle}.\n     *\n     * If neither an end handle nor a start handle is provided, the positions of\n     * the handles gets calculated automatically to create smooth curve through\n     * the knot. The smoothness of the resulting curve can be controlled via the\n     * {@link Spline.smoothness} property.\n     *\n     * It is also possible to blend between a user-defined position and the\n     * auto-calculated position by using the {@link auto} property.\n     *\n     * @defaultValue Mirrored position of the startHandle.\n     */\n    readonly endHandle: Vector2Signal<this>;\n    /**\n     * How much to blend between the user-provided handles and the auto-calculated\n     * handles.\n     *\n     * @remarks\n     * This property has no effect if no explicit handles are provided for the\n     * knot.\n     *\n     * @defaultValue 0\n     */\n    readonly auto: KnotAutoSignal<this>;\n    get startHandleAuto(): Signal<number, number, this, import(\"@motion-canvas/core\").SignalContext<number, number, this>>;\n    get endHandleAuto(): Signal<number, number, this, import(\"@motion-canvas/core\").SignalContext<number, number, this>>;\n    constructor(props: KnotProps);\n    points(): KnotInfo;\n    private getDefaultEndHandle;\n    private getDefaultStartHandle;\n}\n//# sourceMappingURL=Knot.d.ts.map" },
  { path: "node_modules/@motion-canvas/2d/lib/components/Latex.d.ts", content: "import { SerializedVector2, Signal, SignalValue, SimpleSignal, TimingFunction, Vector2 } from '@motion-canvas/core';\nimport { OptionList } from 'mathjax-full/js/util/Options';\nimport { SVGDocument, SVG as SVGNode, SVGProps } from './SVG';\nexport interface LatexProps extends Omit<SVGProps, 'svg'> {\n    tex?: SignalValue<string[] | string>;\n    renderProps?: SignalValue<OptionList>;\n}\n/**\n * A node for animating equations with LaTeX.\n *\n * @preview\n * ```tsx editor\n * import {Latex, makeScene2D} from '@motion-canvas/2d';\n * import {createRef, waitFor} from '@motion-canvas/core';\n *\n * export default makeScene2D(function* (view) {\n *   const tex = createRef<Latex>();\n *   view.add(<Latex ref={tex} tex=\"{{y=}}{{a}}{{x^2}}\" fill=\"white\" />);\n *\n *   yield* waitFor(0.2);\n *   yield* tex().tex('{{y=}}{{a}}{{x^2}} + {{bx}}', 1);\n *   yield* waitFor(0.2);\n *   yield* tex().tex(\n *     '{{y=}}{{\\\\left(}}{{a}}{{x^2}} + {{bx}}{{\\\\over 1}}{{\\\\right)}}',\n *     1,\n *   );\n *   yield* waitFor(0.2);\n *   yield* tex().tex('{{y=}}{{a}}{{x^2}}', 1);\n * });\n * ```\n */\nexport declare class Latex extends SVGNode {\n    private static containerFontSize;\n    private static svgContentsPool;\n    private static texNodesPool;\n    private svgSubTexMap;\n    readonly options: SimpleSignal<OptionList, this>;\n    readonly tex: Signal<string[] | string, string[], this>;\n    constructor(props: LatexProps);\n    protected calculateWrapperScale(documentSize: Vector2, parentSize: SerializedVector2<number | null>): Vector2;\n    protected latexSVG(): string;\n    private getNodeCharacterId;\n    protected parseSVG(svg: string): SVGDocument;\n    private texToSvg;\n    private subTexToSVG;\n    private singleTexToSVG;\n    protected tweenTex(value: string[], time: number, timingFunction: TimingFunction): Generator<void | import(\"@motion-canvas/core\").ThreadGenerator | Promise<any> | import(\"@motion-canvas/core\").Promisable<any>, void, any>;\n}\n//# sourceMappingURL=Latex.d.ts.map" },
  { path: "node_modules/@motion-canvas/2d/lib/components/Layout.d.ts", content: "import { BBox, Direction, InterpolationFunction, Origin, PossibleSpacing, PossibleVector2, SerializedVector2, Signal, SignalValue, SimpleSignal, SimpleVector2Signal, SpacingSignal, ThreadGenerator, TimingFunction, Vector2, Vector2Signal } from '@motion-canvas/core';\nimport { Vector2LengthSignal } from '../decorators';\nimport { DesiredLength, FlexBasis, FlexContent, FlexDirection, FlexItems, FlexWrap, LayoutMode, Length, LengthLimit, TextWrap } from '../partials';\nimport { Node, NodeProps } from './Node';\nexport interface LayoutProps extends NodeProps {\n    layout?: LayoutMode;\n    tagName?: keyof HTMLElementTagNameMap;\n    width?: SignalValue<Length>;\n    height?: SignalValue<Length>;\n    maxWidth?: SignalValue<LengthLimit>;\n    maxHeight?: SignalValue<LengthLimit>;\n    minWidth?: SignalValue<LengthLimit>;\n    minHeight?: SignalValue<LengthLimit>;\n    ratio?: SignalValue<number>;\n    marginTop?: SignalValue<number>;\n    marginBottom?: SignalValue<number>;\n    marginLeft?: SignalValue<number>;\n    marginRight?: SignalValue<number>;\n    margin?: SignalValue<PossibleSpacing>;\n    paddingTop?: SignalValue<number>;\n    paddingBottom?: SignalValue<number>;\n    paddingLeft?: SignalValue<number>;\n    paddingRight?: SignalValue<number>;\n    padding?: SignalValue<PossibleSpacing>;\n    direction?: SignalValue<FlexDirection>;\n    basis?: SignalValue<FlexBasis>;\n    grow?: SignalValue<number>;\n    shrink?: SignalValue<number>;\n    wrap?: SignalValue<FlexWrap>;\n    justifyContent?: SignalValue<FlexContent>;\n    alignContent?: SignalValue<FlexContent>;\n    alignItems?: SignalValue<FlexItems>;\n    alignSelf?: SignalValue<FlexItems>;\n    rowGap?: SignalValue<Length>;\n    columnGap?: SignalValue<Length>;\n    gap?: SignalValue<PossibleVector2<Length>>;\n    fontFamily?: SignalValue<string>;\n    fontSize?: SignalValue<number>;\n    fontStyle?: SignalValue<string>;\n    fontWeight?: SignalValue<number>;\n    lineHeight?: SignalValue<Length>;\n    letterSpacing?: SignalValue<number>;\n    textWrap?: SignalValue<TextWrap>;\n    textDirection?: SignalValue<CanvasDirection>;\n    textAlign?: SignalValue<CanvasTextAlign>;\n    size?: SignalValue<PossibleVector2<Length>>;\n    offsetX?: SignalValue<number>;\n    offsetY?: SignalValue<number>;\n    offset?: SignalValue<PossibleVector2>;\n    /**\n     * The position of the center of this node.\n     *\n     * @remarks\n     * This shortcut property will set the node's position so that the center ends\n     * up in the given place.\n     * If present, overrides the {@link NodeProps.position} property.\n     * When {@link offset} is not set, this will be the same as the\n     * {@link NodeProps.position}.\n     */\n    middle?: SignalValue<PossibleVector2>;\n    /**\n     * The position of the top edge of this node.\n     *\n     * @remarks\n     * This shortcut property will set the node's position so that the top edge\n     * ends up in the given place.\n     * If present, overrides the {@link NodeProps.position} property.\n     */\n    top?: SignalValue<PossibleVector2>;\n    /**\n     * The position of the bottom edge of this node.\n     *\n     * @remarks\n     * This shortcut property will set the node's position so that the bottom edge\n     * ends up in the given place.\n     * If present, overrides the {@link NodeProps.position} property.\n     */\n    bottom?: SignalValue<PossibleVector2>;\n    /**\n     * The position of the left edge of this node.\n     *\n     * @remarks\n     * This shortcut property will set the node's position so that the left edge\n     * ends up in the given place.\n     * If present, overrides the {@link NodeProps.position} property.\n     */\n    left?: SignalValue<PossibleVector2>;\n    /**\n     * The position of the right edge of this node.\n     *\n     * @remarks\n     * This shortcut property will set the node's position so that the right edge\n     * ends up in the given place.\n     * If present, overrides the {@link NodeProps.position} property.\n     */\n    right?: SignalValue<PossibleVector2>;\n    /**\n     * The position of the top left corner of this node.\n     *\n     * @remarks\n     * This shortcut property will set the node's position so that the top left\n     * corner ends up in the given place.\n     * If present, overrides the {@link NodeProps.position} property.\n     */\n    topLeft?: SignalValue<PossibleVector2>;\n    /**\n     * The position of the top right corner of this node.\n     *\n     * @remarks\n     * This shortcut property will set the node's position so that the top right\n     * corner ends up in the given place.\n     * If present, overrides the {@link NodeProps.position} property.\n     */\n    topRight?: SignalValue<PossibleVector2>;\n    /**\n     * The position of the bottom left corner of this node.\n     *\n     * @remarks\n     * This shortcut property will set the node's position so that the bottom left\n     * corner ends up in the given place.\n     * If present, overrides the {@link NodeProps.position} property.\n     */\n    bottomLeft?: SignalValue<PossibleVector2>;\n    /**\n     * The position of the bottom right corner of this node.\n     *\n     * @remarks\n     * This shortcut property will set the node's position so that the bottom\n     * right corner ends up in the given place.\n     * If present, overrides the {@link NodeProps.position} property.\n     */\n    bottomRight?: SignalValue<PossibleVector2>;\n    clip?: SignalValue<boolean>;\n}\nexport declare class Layout extends Node {\n    readonly layout: SimpleSignal<LayoutMode, this>;\n    readonly maxWidth: SimpleSignal<LengthLimit, this>;\n    readonly maxHeight: SimpleSignal<LengthLimit, this>;\n    readonly minWidth: SimpleSignal<LengthLimit, this>;\n    readonly minHeight: SimpleSignal<LengthLimit, this>;\n    readonly ratio: SimpleSignal<number | null, this>;\n    readonly margin: SpacingSignal<this>;\n    readonly padding: SpacingSignal<this>;\n    readonly direction: SimpleSignal<FlexDirection, this>;\n    readonly basis: SimpleSignal<FlexBasis, this>;\n    readonly grow: SimpleSignal<number, this>;\n    readonly shrink: SimpleSignal<number, this>;\n    readonly wrap: SimpleSignal<FlexWrap, this>;\n    readonly justifyContent: SimpleSignal<FlexContent, this>;\n    readonly alignContent: SimpleSignal<FlexContent, this>;\n    readonly alignItems: SimpleSignal<FlexItems, this>;\n    readonly alignSelf: SimpleSignal<FlexItems, this>;\n    readonly gap: Vector2LengthSignal<this>;\n    get columnGap(): Signal<Length, number, this>;\n    get rowGap(): Signal<Length, number, this>;\n    readonly fontFamily: SimpleSignal<string, this>;\n    readonly fontSize: SimpleSignal<number, this>;\n    readonly fontStyle: SimpleSignal<string, this>;\n    readonly fontWeight: SimpleSignal<number, this>;\n    readonly lineHeight: SimpleSignal<Length, this>;\n    readonly letterSpacing: SimpleSignal<number, this>;\n    readonly textWrap: SimpleSignal<TextWrap, this>;\n    readonly textDirection: SimpleSignal<CanvasDirection, this>;\n    readonly textAlign: SimpleSignal<CanvasTextAlign, this>;\n    protected getX(): number;\n    protected setX(value: SignalValue<number>): void;\n    protected getY(): number;\n    protected setY(value: SignalValue<number>): void;\n    /**\n     * Represents the size of this node.\n     *\n     * @remarks\n     * A size is a two-dimensional vector, where `x` represents the `width`, and `y`\n     * represents the `height`.\n     *\n     * The value of both x and y is of type {@link partials.Length} which is\n     * either:\n     * - `number` - the desired length in pixels\n     * - `${number}%` - a string with the desired length in percents, for example\n     *                  `'50%'`\n     * - `null` - an automatic length\n     *\n     * When retrieving the size, all units are converted to pixels, using the\n     * current state of the layout. For example, retrieving the width set to\n     * `'50%'`, while the parent has a width of `200px` will result in the number\n     * `100` being returned.\n     *\n     * When the node is not part of the layout, setting its size using percents\n     * refers to the size of the entire scene.\n     *\n     * @example\n     * Initializing the size:\n     * ```tsx\n     * // with a possible vector:\n     * <Node size={['50%', 200]} />\n     * // with individual components:\n     * <Node width={'50%'} height={200} />\n     * ```\n     *\n     * Accessing the size:\n     * ```tsx\n     * // retrieving the vector:\n     * const size = node.size();\n     * // retrieving an individual component:\n     * const width = node.size.x();\n     * ```\n     *\n     * Setting the size:\n     * ```tsx\n     * // with a possible vector:\n     * node.size(['50%', 200]);\n     * node.size(() => ['50%', 200]);\n     * // with individual components:\n     * node.size.x('50%');\n     * node.size.x(() => '50%');\n     * ```\n     */\n    readonly size: Vector2LengthSignal<this>;\n    get width(): Signal<Length, number, this>;\n    get height(): Signal<Length, number, this>;\n    protected getWidth(): number;\n    protected setWidth(value: SignalValue<Length>): void;\n    protected tweenWidth(value: SignalValue<Length>, time: number, timingFunction: TimingFunction, interpolationFunction: InterpolationFunction<Length>): ThreadGenerator;\n    protected getHeight(): number;\n    protected setHeight(value: SignalValue<Length>): void;\n    protected tweenHeight(value: SignalValue<Length>, time: number, timingFunction: TimingFunction, interpolationFunction: InterpolationFunction<Length>): ThreadGenerator;\n    /**\n     * Get the desired size of this node.\n     *\n     * @remarks\n     * This method can be used to control the size using external factors.\n     * By default, the returned size is the same as the one declared by the user.\n     */\n    protected desiredSize(): SerializedVector2<DesiredLength>;\n    protected tweenSize(value: SignalValue<SerializedVector2<Length>>, time: number, timingFunction: TimingFunction, interpolationFunction: InterpolationFunction<Vector2>): ThreadGenerator;\n    /**\n     * Represents the offset of this node's origin.\n     *\n     * @remarks\n     * By default, the origin of a node is located at its center. The origin\n     * serves as the pivot point when rotating and scaling a node, but it doesn't\n     * affect the placement of its children.\n     *\n     * The value is relative to the size of this node. A value of `1` means as far\n     * to the right/bottom as possible. Here are a few examples of offsets:\n     * - `[-1, -1]` - top left corner\n     * - `[1, -1]` - top right corner\n     * - `[0, 1]` - bottom edge\n     * - `[-1, 1]` - bottom left corner\n     */\n    readonly offset: Vector2Signal<this>;\n    /**\n     * The position of the center of this node.\n     *\n     * @remarks\n     * When set, this shortcut property will modify the node's position so that\n     * the center ends up in the given place.\n     *\n     * If the {@link offset} has not been changed, this will be the same as the\n     * {@link position}.\n     *\n     * When retrieved, it will return the position of the center in the parent\n     * space.\n     */\n    readonly middle: SimpleVector2Signal<this>;\n    /**\n     * The position of the top edge of this node.\n     *\n     * @remarks\n     * When set, this shortcut property will modify the node's position so that\n     * the top edge ends up in the given place.\n     *\n     * When retrieved, it will return the position of the top edge in the parent\n     * space.\n     */\n    readonly top: SimpleVector2Signal<this>;\n    /**\n     * The position of the bottom edge of this node.\n     *\n     * @remarks\n     * When set, this shortcut property will modify the node's position so that\n     * the bottom edge ends up in the given place.\n     *\n     * When retrieved, it will return the position of the bottom edge in the\n     * parent space.\n     */\n    readonly bottom: SimpleVector2Signal<this>;\n    /**\n     * The position of the left edge of this node.\n     *\n     * @remarks\n     * When set, this shortcut property will modify the node's position so that\n     * the left edge ends up in the given place.\n     *\n     * When retrieved, it will return the position of the left edge in the parent\n     * space.\n     */\n    readonly left: SimpleVector2Signal<this>;\n    /**\n     * The position of the right edge of this node.\n     *\n     * @remarks\n     * When set, this shortcut property will modify the node's position so that\n     * the right edge ends up in the given place.\n     *\n     * When retrieved, it will return the position of the right edge in the parent\n     * space.\n     */\n    readonly right: SimpleVector2Signal<this>;\n    /**\n     * The position of the top left corner of this node.\n     *\n     * @remarks\n     * When set, this shortcut property will modify the node's position so that\n     * the top left corner ends up in the given place.\n     *\n     * When retrieved, it will return the position of the top left corner in the\n     * parent space.\n     */\n    readonly topLeft: SimpleVector2Signal<this>;\n    /**\n     * The position of the top right corner of this node.\n     *\n     * @remarks\n     * When set, this shortcut property will modify the node's position so that\n     * the top right corner ends up in the given place.\n     *\n     * When retrieved, it will return the position of the top right corner in the\n     * parent space.\n     */\n    readonly topRight: SimpleVector2Signal<this>;\n    /**\n     * The position of the bottom left corner of this node.\n     *\n     * @remarks\n     * When set, this shortcut property will modify the node's position so that\n     * the bottom left corner ends up in the given place.\n     *\n     * When retrieved, it will return the position of the bottom left corner in\n     * the parent space.\n     */\n    readonly bottomLeft: SimpleVector2Signal<this>;\n    /**\n     * The position of the bottom right corner of this node.\n     *\n     * @remarks\n     * When set, this shortcut property will modify the node's position so that\n     * the bottom right corner ends up in the given place.\n     *\n     * When retrieved, it will return the position of the bottom right corner in\n     * the parent space.\n     */\n    readonly bottomRight: SimpleVector2Signal<this>;\n    /**\n     * Get the cardinal point corresponding to the given origin.\n     *\n     * @param origin - The origin or direction of the point.\n     */\n    cardinalPoint(origin: Origin | Direction): SimpleVector2Signal<this>;\n    readonly clip: SimpleSignal<boolean, this>;\n    element: HTMLElement;\n    styles: CSSStyleDeclaration;\n    protected readonly sizeLockCounter: SimpleSignal<number, this>;\n    constructor(props: LayoutProps);\n    lockSize(): void;\n    releaseSize(): void;\n    protected parentTransform(): Layout | null;\n    anchorPosition(): Vector2;\n    /**\n     * Get the resolved layout mode of this node.\n     *\n     * @remarks\n     * When the mode is `null`, its value will be inherited from the parent.\n     *\n     * Use {@link layout} to get the raw mode set for this node (without\n     * inheritance).\n     */\n    layoutEnabled(): boolean;\n    isLayoutRoot(): boolean;\n    localToParent(): DOMMatrix;\n    /**\n     * A simplified version of {@link localToParent} matrix used for transforming\n     * direction vectors.\n     *\n     * @internal\n     */\n    protected scalingRotationMatrix(): DOMMatrix;\n    protected getComputedLayout(): BBox;\n    computedPosition(): Vector2;\n    protected computedSize(): Vector2;\n    /**\n     * Find the closest layout root and apply any new layout changes.\n     */\n    protected requestLayoutUpdate(): void;\n    protected appendedToView(): boolean;\n    /**\n     * Apply any new layout changes to this node and its children.\n     */\n    protected updateLayout(): void;\n    protected layoutChildren(): Layout[];\n    /**\n     * Apply any new font changes to this node and all of its ancestors.\n     */\n    protected requestFontUpdate(): void;\n    protected getCacheBBox(): BBox;\n    protected draw(context: CanvasRenderingContext2D): void;\n    drawOverlay(context: CanvasRenderingContext2D, matrix: DOMMatrix): void;\n    getOriginDelta(origin: Origin): Vector2;\n    /**\n     * Update the offset of this node and adjust the position to keep it in the\n     * same place.\n     *\n     * @param offset - The new offset.\n     */\n    moveOffset(offset: Vector2): void;\n    protected parsePixels(value: number | null): string;\n    protected parseLength(value: number | string | null): string;\n    protected applyFlex(): void;\n    protected applyFont(): void;\n    dispose(): void;\n    hit(position: Vector2): Node | null;\n}\n//# sourceMappingURL=Layout.d.ts.map" },
  { path: "node_modules/@motion-canvas/2d/lib/components/Line.d.ts", content: "import { BBox, PossibleVector2, SignalValue, SimpleSignal, ThreadGenerator, TimingFunction, Vector2 } from '@motion-canvas/core';\nimport { CurveProfile } from '../curves';\nimport { Curve, CurveProps } from './Curve';\nexport interface LineProps extends CurveProps {\n    /**\n     * {@inheritDoc Line.radius}\n     */\n    radius?: SignalValue<number>;\n    /**\n     * {@inheritDoc Line.points}\n     */\n    points?: SignalValue<SignalValue<PossibleVector2>[]>;\n}\n/**\n * A node for drawing lines and polygons.\n *\n * @remarks\n * This node can be used to render any polygonal shape defined by a set of\n * points.\n *\n * @preview\n * ```tsx editor\n * // snippet Simple line\n * import {makeScene2D, Line} from '@motion-canvas/2d';\n *\n * export default makeScene2D(function* (view) {\n *   view.add(\n *     <Line\n *       points={[\n *         [150, 50],\n *         [0, -50],\n *         [-150, 50],\n *       ]}\n *       stroke={'lightseagreen'}\n *       lineWidth={8}\n *       radius={40}\n *       startArrow\n *     />,\n *   );\n * });\n *\n * // snippet Polygon\n * import {makeScene2D, Line} from '@motion-canvas/2d';\n *\n * export default makeScene2D(function* (view) {\n *   view.add(\n *     <Line\n *       points={[\n *         [-200, 70],\n *         [150, 70],\n *         [100, -70],\n *         [-100, -70],\n *       ]}\n *       fill={'lightseagreen'}\n *       closed\n *     />,\n *   );\n * });\n *\n * // snippet Using signals\n * import {makeScene2D, Line} from '@motion-canvas/2d';\n * import {createSignal} from '@motion-canvas/core';\n *\n * export default makeScene2D(function* (view) {\n *   const tip = createSignal(-150);\n *   view.add(\n *     <Line\n *       points={[\n *         [-150, 70],\n *         [150, 70],\n *         // this point is dynamically calculated based on the signal:\n *         () => [tip(), -70],\n *       ]}\n *       stroke={'lightseagreen'}\n *       lineWidth={8}\n *       closed\n *     />,\n *   );\n *\n *   yield* tip(150, 1).back(1);\n * });\n *\n * // snippet Tweening points\n * import {makeScene2D, Line} from '@motion-canvas/2d';\n * import {createRef} from '@motion-canvas/core';\n *\n * export default makeScene2D(function* (view) {\n *   const line = createRef<Line>();\n *   view.add(\n *     <Line\n *       ref={line}\n *       points={[\n *         [-150, 70],\n *         [150, 70],\n *         [0, -70],\n *       ]}\n *       stroke={'lightseagreen'}\n *       lineWidth={8}\n *       radius={20}\n *       closed\n *     />,\n *   );\n *\n *   yield* line()\n *     .points(\n *       [\n *         [-150, 0],\n *         [0, 100],\n *         [150, 0],\n *         [150, -70],\n *         [-150, -70],\n *       ],\n *       2,\n *     )\n *     .back(2);\n * });\n * ```\n */\nexport declare class Line extends Curve {\n    /**\n     * Rotate the points to minimize the overall distance traveled when tweening.\n     *\n     * @param points - The points to rotate.\n     * @param reference - The reference points to which the distance is measured.\n     * @param closed - Whether the points form a closed polygon.\n     */\n    private static rotatePoints;\n    /**\n     * Distribute additional points along the polyline.\n     *\n     * @param points - The points of a polyline along which new points should be\n     *                 distributed.\n     * @param count - The number of points to add.\n     */\n    private static distributePoints;\n    /**\n     * The radius of the line's corners.\n     */\n    readonly radius: SimpleSignal<number, this>;\n    /**\n     * The points of the line.\n     *\n     * @remarks\n     * When set to `null`, the Line will use the positions of its children as\n     * points.\n     */\n    readonly points: SimpleSignal<SignalValue<PossibleVector2>[] | null, this>;\n    protected tweenPoints(value: SignalValue<SignalValue<PossibleVector2>[] | null>, time: number, timingFunction: TimingFunction): ThreadGenerator;\n    private tweenedPoints;\n    constructor(props: LineProps);\n    protected childrenBBox(): BBox;\n    parsedPoints(): Vector2[];\n    profile(): CurveProfile;\n    protected lineWidthCoefficient(): number;\n    drawOverlay(context: CanvasRenderingContext2D, matrix: DOMMatrix): void;\n    private parsePoints;\n}\n//# sourceMappingURL=Line.d.ts.map" },
  { path: "node_modules/@motion-canvas/2d/lib/components/Node.d.ts", content: "import { BBox, ColorSignal, PossibleColor, PossibleSpacing, PossibleVector2, Promisable, ReferenceReceiver, Signal, SignalValue, SimpleSignal, SimpleVector2Signal, SpacingSignal, ThreadGenerator, TimingFunction, Vector2, Vector2Signal } from '@motion-canvas/core';\nimport { NODE_NAME } from '../decorators';\nimport { FiltersSignal } from '../decorators/filtersSignal';\nimport { Filter } from '../partials';\nimport { PossibleShaderConfig, ShaderConfig } from '../partials/ShaderConfig';\nimport type { View2D } from './View2D';\nimport type { ComponentChildren } from './types';\nexport type NodeState = NodeProps & Record<string, any>;\nexport interface NodeProps {\n    ref?: ReferenceReceiver<any>;\n    children?: SignalValue<ComponentChildren>;\n    /**\n     * @deprecated Use {@link children} instead.\n     */\n    spawner?: SignalValue<ComponentChildren>;\n    key?: string;\n    x?: SignalValue<number>;\n    y?: SignalValue<number>;\n    position?: SignalValue<PossibleVector2>;\n    rotation?: SignalValue<number>;\n    scaleX?: SignalValue<number>;\n    scaleY?: SignalValue<number>;\n    scale?: SignalValue<PossibleVector2>;\n    skewX?: SignalValue<number>;\n    skewY?: SignalValue<number>;\n    skew?: SignalValue<PossibleVector2>;\n    zIndex?: SignalValue<number>;\n    opacity?: SignalValue<number>;\n    filters?: SignalValue<Filter[]>;\n    shadowColor?: SignalValue<PossibleColor>;\n    shadowBlur?: SignalValue<number>;\n    shadowOffsetX?: SignalValue<number>;\n    shadowOffsetY?: SignalValue<number>;\n    shadowOffset?: SignalValue<PossibleVector2>;\n    cache?: SignalValue<boolean>;\n    /**\n     * {@inheritDoc Node.cachePadding}\n     */\n    cachePaddingTop?: SignalValue<number>;\n    /**\n     * {@inheritDoc Node.cachePadding}\n     */\n    cachePaddingBottom?: SignalValue<number>;\n    /**\n     * {@inheritDoc Node.cachePadding}\n     */\n    cachePaddingLeft?: SignalValue<number>;\n    /**\n     * {@inheritDoc Node.cachePadding}\n     */\n    cachePaddingRight?: SignalValue<number>;\n    /**\n     * {@inheritDoc Node.cachePadding}\n     */\n    cachePadding?: SignalValue<PossibleSpacing>;\n    composite?: SignalValue<boolean>;\n    compositeOperation?: SignalValue<GlobalCompositeOperation>;\n    /**\n     * @experimental\n     */\n    shaders?: PossibleShaderConfig;\n}\nexport declare class Node implements Promisable<Node> {\n    /**\n     * @internal\n     */\n    readonly [NODE_NAME]: string;\n    isClass: boolean;\n    /**\n     * Represents the position of this node in local space of its parent.\n     *\n     * @example\n     * Initializing the position:\n     * ```tsx\n     * // with a possible vector:\n     * <Node position={[1, 2]} />\n     * // with individual components:\n     * <Node x={1} y={2} />\n     * ```\n     *\n     * Accessing the position:\n     * ```tsx\n     * // retrieving the vector:\n     * const position = node.position();\n     * // retrieving an individual component:\n     * const x = node.position.x();\n     * ```\n     *\n     * Setting the position:\n     * ```tsx\n     * // with a possible vector:\n     * node.position([1, 2]);\n     * node.position(() => [1, 2]);\n     * // with individual components:\n     * node.position.x(1);\n     * node.position.x(() => 1);\n     * ```\n     */\n    readonly position: Vector2Signal<this>;\n    get x(): SimpleSignal<number, this>;\n    get y(): SimpleSignal<number, this>;\n    /**\n     * A helper signal for operating on the position in world space.\n     *\n     * @remarks\n     * Retrieving the position using this signal returns the position in world\n     * space. Similarly, setting the position using this signal transforms the\n     * new value to local space.\n     *\n     * If the new value is a function, the position of this node will be\n     * continuously updated to always match the position returned by the function.\n     * This can be useful to \"pin\" the node in a specific place or to make it\n     * follow another node's position.\n     *\n     * Unlike {@link position}, this signal is not compound - it doesn't contain\n     * separate signals for the `x` and `y` components.\n     */\n    readonly absolutePosition: SimpleVector2Signal<this>;\n    protected getAbsolutePosition(): Vector2;\n    protected setAbsolutePosition(value: SignalValue<PossibleVector2>): void;\n    /**\n     * Represents the rotation (in degrees) of this node relative to its parent.\n     */\n    readonly rotation: SimpleSignal<number, this>;\n    /**\n     * A helper signal for operating on the rotation in world space.\n     *\n     * @remarks\n     * Retrieving the rotation using this signal returns the rotation in world\n     * space. Similarly, setting the rotation using this signal transforms the\n     * new value to local space.\n     *\n     * If the new value is a function, the rotation of this node will be\n     * continuously updated to always match the rotation returned by the function.\n     */\n    readonly absoluteRotation: SimpleSignal<number, this>;\n    protected getAbsoluteRotation(): number;\n    protected setAbsoluteRotation(value: SignalValue<number>): void;\n    /**\n     * Represents the scale of this node in local space of its parent.\n     *\n     * @example\n     * Initializing the scale:\n     * ```tsx\n     * // with a possible vector:\n     * <Node scale={[1, 2]} />\n     * // with individual components:\n     * <Node scaleX={1} scaleY={2} />\n     * ```\n     *\n     * Accessing the scale:\n     * ```tsx\n     * // retrieving the vector:\n     * const scale = node.scale();\n     * // retrieving an individual component:\n     * const scaleX = node.scale.x();\n     * ```\n     *\n     * Setting the scale:\n     * ```tsx\n     * // with a possible vector:\n     * node.scale([1, 2]);\n     * node.scale(() => [1, 2]);\n     * // with individual components:\n     * node.scale.x(1);\n     * node.scale.x(() => 1);\n     * ```\n     */\n    readonly scale: Vector2Signal<this>;\n    /**\n     * Represents the skew of this node in local space of its parent.\n     *\n     * @example\n     * Initializing the skew:\n     * ```tsx\n     * // with a possible vector:\n     * <Node skew={[40, 20]} />\n     * // with individual components:\n     * <Node skewX={40} skewY={20} />\n     * ```\n     *\n     * Accessing the skew:\n     * ```tsx\n     * // retrieving the vector:\n     * const skew = node.skew();\n     * // retrieving an individual component:\n     * const skewX = node.skew.x();\n     * ```\n     *\n     * Setting the skew:\n     * ```tsx\n     * // with a possible vector:\n     * node.skew([40, 20]);\n     * node.skew(() => [40, 20]);\n     * // with individual components:\n     * node.skew.x(40);\n     * node.skew.x(() => 40);\n     * ```\n     */\n    readonly skew: Vector2Signal<this>;\n    /**\n     * A helper signal for operating on the scale in world space.\n     *\n     * @remarks\n     * Retrieving the scale using this signal returns the scale in world space.\n     * Similarly, setting the scale using this signal transforms the new value to\n     * local space.\n     *\n     * If the new value is a function, the scale of this node will be continuously\n     * updated to always match the position returned by the function.\n     *\n     * Unlike {@link scale}, this signal is not compound - it doesn't contain\n     * separate signals for the `x` and `y` components.\n     */\n    readonly absoluteScale: SimpleVector2Signal<this>;\n    protected getAbsoluteScale(): Vector2;\n    protected setAbsoluteScale(value: SignalValue<PossibleVector2>): void;\n    private getRelativeScale;\n    readonly zIndex: SimpleSignal<number, this>;\n    readonly cache: SimpleSignal<boolean, this>;\n    /**\n     * Controls the padding of the cached canvas used by this node.\n     *\n     * @remarks\n     * By default, the size of the cache is determined based on the bounding box\n     * of the node and its children. That includes effects such as stroke or\n     * shadow. This property can be used to expand the cache area further.\n     * Usually used to account for custom effects created by {@link shaders}.\n     */\n    readonly cachePadding: SpacingSignal<this>;\n    readonly composite: SimpleSignal<boolean, this>;\n    readonly compositeOperation: SimpleSignal<GlobalCompositeOperation, this>;\n    private readonly compositeOverride;\n    protected tweenCompositeOperation(value: SignalValue<GlobalCompositeOperation>, time: number, timingFunction: TimingFunction): Generator<void | ThreadGenerator | Promise<any> | Promisable<any>, void, any>;\n    /**\n     * Represents the opacity of this node in the range 0-1.\n     *\n     * @remarks\n     * The value is clamped to the range 0-1.\n     */\n    readonly opacity: SimpleSignal<number, this>;\n    absoluteOpacity(): number;\n    readonly filters: FiltersSignal<this>;\n    readonly shadowColor: ColorSignal<this>;\n    readonly shadowBlur: SimpleSignal<number, this>;\n    readonly shadowOffset: Vector2Signal<this>;\n    /**\n     * @experimental\n     */\n    readonly shaders: Signal<PossibleShaderConfig, ShaderConfig[], this>;\n    protected hasFilters(): boolean;\n    protected hasShadow(): boolean;\n    protected filterString(): string;\n    /**\n     * @deprecated Use {@link children} instead.\n     */\n    protected readonly spawner: SimpleSignal<ComponentChildren, this>;\n    protected getSpawner(): ComponentChildren;\n    protected setSpawner(value: SignalValue<ComponentChildren>): void;\n    readonly children: Signal<ComponentChildren, Node[], this>;\n    protected setChildren(value: SignalValue<ComponentChildren>): void;\n    protected getChildren(): Node[];\n    protected spawnedChildren(): Node[];\n    protected sortedChildren(): Node[];\n    protected view2D: View2D;\n    private stateStack;\n    protected realChildren: Node[];\n    protected hasSpawnedChildren: boolean;\n    private unregister;\n    readonly parent: SimpleSignal<Node | null, void>;\n    readonly properties: Record<string, import(\"../decorators\").PropertyMetadata<any>>;\n    readonly key: string;\n    readonly creationStack?: string;\n    constructor({ children, spawner, key, ...rest }: NodeProps);\n    /**\n     * Get the local-to-world matrix for this node.\n     *\n     * @remarks\n     * This matrix transforms vectors from local space of this node to world\n     * space.\n     *\n     * @example\n     * Calculate the absolute position of a point located 200 pixels to the right\n     * of the node:\n     * ```ts\n     * const local = new Vector2(0, 200);\n     * const world = local.transformAsPoint(node.localToWorld());\n     * ```\n     */\n    localToWorld(): DOMMatrix;\n    /**\n     * Get the world-to-local matrix for this node.\n     *\n     * @remarks\n     * This matrix transforms vectors from world space to local space of this\n     * node.\n     *\n     * @example\n     * Calculate the position relative to this node for a point located in the\n     * top-left corner of the screen:\n     * ```ts\n     * const world = new Vector2(0, 0);\n     * const local = world.transformAsPoint(node.worldToLocal());\n     * ```\n     */\n    worldToLocal(): DOMMatrix;\n    /**\n     * Get the world-to-parent matrix for this node.\n     *\n     * @remarks\n     * This matrix transforms vectors from world space to local space of this\n     * node's parent.\n     */\n    worldToParent(): DOMMatrix;\n    /**\n     * Get the parent-to-world matrix for this node.\n     *\n     * @remarks\n     * This matrix transforms vectors from local space of this node's parent to\n     * world space.\n     */\n    parentToWorld(): DOMMatrix;\n    /**\n     * Get the local-to-parent matrix for this node.\n     *\n     * @remarks\n     * This matrix transforms vectors from local space of this node to local space\n     * of this node's parent.\n     */\n    localToParent(): DOMMatrix;\n    /**\n     * A matrix mapping composite space to world space.\n     *\n     * @remarks\n     * Certain effects such as blur and shadows ignore the current transformation.\n     * This matrix can be used to transform their parameters so that the effect\n     * appears relative to the closest composite root.\n     */\n    compositeToWorld(): DOMMatrix;\n    protected compositeRoot(): Node | null;\n    compositeToLocal(): DOMMatrix;\n    view(): View2D;\n    /**\n     * Add the given node(s) as the children of this node.\n     *\n     * @remarks\n     * The nodes will be appended at the end of the children list.\n     *\n     * @example\n     * ```tsx\n     * const node = <Layout />;\n     * node.add(<Rect />);\n     * node.add(<Circle />);\n     * ```\n     * Result:\n     * ```mermaid\n     * graph TD;\n     *   layout([Layout])\n     *   circle([Circle])\n     *   rect([Rect])\n     *     layout-->rect;\n     *     layout-->circle;\n     * ```\n     *\n     * @param node - A node or an array of nodes to append.\n     */\n    add(node: ComponentChildren): this;\n    /**\n     * Insert the given node(s) at the specified index in the children list.\n     *\n     * @example\n     * ```tsx\n     * const node = (\n     *   <Layout>\n     *     <Rect />\n     *     <Circle />\n     *   </Layout>\n     * );\n     *\n     * node.insert(<Txt />, 1);\n     * ```\n     *\n     * Result:\n     * ```mermaid\n     * graph TD;\n     *   layout([Layout])\n     *   circle([Circle])\n     *   text([Text])\n     *   rect([Rect])\n     *     layout-->rect;\n     *     layout-->text;\n     *     layout-->circle;\n     * ```\n     *\n     * @param node - A node or an array of nodes to insert.\n     * @param index - An index at which to insert the node(s).\n     */\n    insert(node: ComponentChildren, index?: number): this;\n    /**\n     * Remove this node from the tree.\n     */\n    remove(): this;\n    /**\n     * Rearrange this node in relation to its siblings.\n     *\n     * @remarks\n     * Children are rendered starting from the beginning of the children list.\n     * We can change the rendering order by rearranging said list.\n     *\n     * A positive `by` arguments move the node up (it will be rendered on top of\n     * the elements it has passed). Negative values move it down.\n     *\n     * @param by - Number of places by which the node should be moved.\n     */\n    move(by?: number): this;\n    /**\n     * Move the node up in relation to its siblings.\n     *\n     * @remarks\n     * The node will exchange places with the sibling right above it (if any) and\n     * from then on will be rendered on top of it.\n     */\n    moveUp(): this;\n    /**\n     * Move the node down in relation to its siblings.\n     *\n     * @remarks\n     * The node will exchange places with the sibling right below it (if any) and\n     * from then on will be rendered under it.\n     */\n    moveDown(): this;\n    /**\n     * Move the node to the top in relation to its siblings.\n     *\n     * @remarks\n     * The node will be placed at the end of the children list and from then on\n     * will be rendered on top of all of its siblings.\n     */\n    moveToTop(): this;\n    /**\n     * Move the node to the bottom in relation to its siblings.\n     *\n     * @remarks\n     * The node will be placed at the beginning of the children list and from then\n     * on will be rendered below all of its siblings.\n     */\n    moveToBottom(): this;\n    /**\n     * Move the node to the provided position relative to its siblings.\n     *\n     * @remarks\n     * If the node is getting moved to a lower position, it will be placed below\n     * the sibling that's currently at the provided index (if any).\n     * If the node is getting moved to a higher position, it will be placed above\n     * the sibling that's currently at the provided index (if any).\n     *\n     * @param index - The index to move the node to.\n     */\n    moveTo(index: number): this;\n    /**\n     * Move the node below the provided node in the parent's layout.\n     *\n     * @remarks\n     * The node will be moved below the provided node and from then on will be\n     * rendered below it. By default, if the node is already positioned lower than\n     * the sibling node, it will not get moved.\n     *\n     * @param node - The sibling node below which to move.\n     * @param directlyBelow - Whether the node should be positioned directly below\n     *                        the sibling. When true, will move the node even if\n     *                        it is already positioned below the sibling.\n     */\n    moveBelow(node: Node, directlyBelow?: boolean): this;\n    /**\n     * Move the node above the provided node in the parent's layout.\n     *\n     * @remarks\n     * The node will be moved above the provided node and from then on will be\n     * rendered on top of it. By default, if the node is already positioned\n     * higher than the sibling node, it will not get moved.\n     *\n     * @param node - The sibling node below which to move.\n     * @param directlyAbove - Whether the node should be positioned directly above the\n     *                        sibling. When true, will move the node even if it is\n     *                        already positioned above the sibling.\n     */\n    moveAbove(node: Node, directlyAbove?: boolean): this;\n    /**\n     * Change the parent of this node while keeping the absolute transform.\n     *\n     * @remarks\n     * After performing this operation, the node will stay in the same place\n     * visually, but its parent will be changed.\n     *\n     * @param newParent - The new parent of this node.\n     */\n    reparent(newParent: Node): this;\n    /**\n     * Remove all children of this node.\n     */\n    removeChildren(): this;\n    /**\n     * Get the current children of this node.\n     *\n     * @remarks\n     * Unlike {@link children}, this method does not have any side effects.\n     * It does not register the `children` signal as a dependency, and it does not\n     * spawn any children. It can be used to safely retrieve the current state of\n     * the scene graph for debugging purposes.\n     */\n    peekChildren(): readonly Node[];\n    /**\n     * Find all descendants of this node that match the given predicate.\n     *\n     * @param predicate - A function that returns true if the node matches.\n     */\n    findAll<T extends Node>(predicate: (node: any) => node is T): T[];\n    /**\n     * Find all descendants of this node that match the given predicate.\n     *\n     * @param predicate - A function that returns true if the node matches.\n     */\n    findAll<T extends Node = Node>(predicate: (node: any) => boolean): T[];\n    /**\n     * Find the first descendant of this node that matches the given predicate.\n     *\n     * @param predicate - A function that returns true if the node matches.\n     */\n    findFirst<T extends Node>(predicate: (node: Node) => node is T): T | null;\n    /**\n     * Find the first descendant of this node that matches the given predicate.\n     *\n     * @param predicate - A function that returns true if the node matches.\n     */\n    findFirst<T extends Node = Node>(predicate: (node: Node) => boolean): T | null;\n    /**\n     * Find the last descendant of this node that matches the given predicate.\n     *\n     * @param predicate - A function that returns true if the node matches.\n     */\n    findLast<T extends Node>(predicate: (node: Node) => node is T): T | null;\n    /**\n     * Find the last descendant of this node that matches the given predicate.\n     *\n     * @param predicate - A function that returns true if the node matches.\n     */\n    findLast<T extends Node = Node>(predicate: (node: Node) => boolean): T | null;\n    /**\n     * Find the closest ancestor of this node that matches the given predicate.\n     *\n     * @param predicate - A function that returns true if the node matches.\n     */\n    findAncestor<T extends Node>(predicate: (node: Node) => node is T): T | null;\n    /**\n     * Find the closest ancestor of this node that matches the given predicate.\n     *\n     * @param predicate - A function that returns true if the node matches.\n     */\n    findAncestor<T extends Node = Node>(predicate: (node: Node) => boolean): T | null;\n    /**\n     * Get the nth children cast to the specified type.\n     *\n     * @param index - The index of the child to retrieve.\n     */\n    childAs<T extends Node = Node>(index: number): T | null;\n    /**\n     * Get the children array cast to the specified type.\n     */\n    childrenAs<T extends Node = Node>(): T[];\n    /**\n     * Get the parent cast to the specified type.\n     */\n    parentAs<T extends Node = Node>(): T | null;\n    /**\n     * Prepare this node to be disposed of.\n     *\n     * @remarks\n     * This method is called automatically when a scene is refreshed. It will\n     * be called even if the node is not currently attached to the tree.\n     *\n     * The goal of this method is to clean any external references to allow the\n     * node to be garbage collected.\n     */\n    dispose(): void;\n    /**\n     * Create a copy of this node.\n     *\n     * @param customProps - Properties to override.\n     */\n    clone(customProps?: NodeState): this;\n    /**\n     * Create a copy of this node.\n     *\n     * @remarks\n     * Unlike {@link clone}, a snapshot clone calculates any reactive properties\n     * at the moment of cloning and passes the raw values to the copy.\n     *\n     * @param customProps - Properties to override.\n     */\n    snapshotClone(customProps?: NodeState): this;\n    /**\n     * Create a reactive copy of this node.\n     *\n     * @remarks\n     * A reactive copy has all its properties dynamically updated to match the\n     * source node.\n     *\n     * @param customProps - Properties to override.\n     */\n    reactiveClone(customProps?: NodeState): this;\n    /**\n     * Create an instance of this node's class.\n     *\n     * @param props - Properties to pass to the constructor.\n     */\n    instantiate(props?: NodeProps): this;\n    /**\n     * Set the children without parsing them.\n     *\n     * @remarks\n     * This method assumes that the caller took care of parsing the children and\n     * updating the hierarchy.\n     *\n     * @param value - The children to set.\n     */\n    protected setParsedChildren(value: Node[]): void;\n    protected spawnChildren(reactive: boolean, children: ComponentChildren): void;\n    /**\n     * Parse any `ComponentChildren` into an array of nodes.\n     *\n     * @param children - The children to parse.\n     */\n    protected parseChildren(children: ComponentChildren): Node[];\n    /**\n     * Remove the given child.\n     */\n    protected removeChild(child: Node): void;\n    /**\n     * Whether this node should be cached or not.\n     */\n    protected requiresCache(): boolean;\n    protected cacheCanvas(): CanvasRenderingContext2D;\n    /**\n     * Get a cache canvas with the contents of this node rendered onto it.\n     */\n    protected cachedCanvas(): CanvasRenderingContext2D;\n    /**\n     * Get a bounding box for the contents rendered by this node.\n     *\n     * @remarks\n     * The returned bounding box should be in local space.\n     */\n    protected getCacheBBox(): BBox;\n    /**\n     * Get a bounding box for the contents rendered by this node as well\n     * as its children.\n     */\n    cacheBBox(): BBox;\n    /**\n     * Get a bounding box for the contents rendered by this node (including\n     * effects applied after caching).\n     *\n     * @remarks\n     * The returned bounding box should be in local space.\n     */\n    protected fullCacheBBox(): BBox;\n    /**\n     * Get a bounding box in world space for the contents rendered by this node as\n     * well as its children.\n     *\n     * @remarks\n     * This is the same the bounding box returned by {@link cacheBBox} only\n     * transformed to world space.\n     */\n    protected worldSpaceCacheBBox(): BBox;\n    protected parentWorldSpaceCacheBBox(): BBox;\n    /**\n     * Prepare the given context for drawing a cached node onto it.\n     *\n     * @remarks\n     * This method is called before the contents of the cache canvas are drawn\n     * on the screen. It can be used to apply effects to the entire node together\n     * with its children, instead of applying them individually.\n     * Effects such as transparency, shadows, and filters use this technique.\n     *\n     * Whether the node is cached is decided by the {@link requiresCache} method.\n     *\n     * @param context - The context using which the cache will be drawn.\n     */\n    protected setupDrawFromCache(context: CanvasRenderingContext2D): void;\n    protected renderFromSource(context: CanvasRenderingContext2D, source: CanvasImageSource, x: number, y: number): void;\n    private shaderCanvas;\n    /**\n     * Render this node onto the given canvas.\n     *\n     * @param context - The context to draw with.\n     */\n    render(context: CanvasRenderingContext2D): void;\n    /**\n     * Draw this node onto the canvas.\n     *\n     * @remarks\n     * This method is used when drawing directly onto the screen as well as onto\n     * the cache canvas.\n     * It assumes that the context have already been transformed to local space.\n     *\n     * @param context - The context to draw with.\n     */\n    protected draw(context: CanvasRenderingContext2D): void;\n    protected drawChildren(context: CanvasRenderingContext2D): void;\n    /**\n     * Draw an overlay for this node.\n     *\n     * @remarks\n     * The overlay for the currently inspected node is displayed on top of the\n     * canvas.\n     *\n     * The provided context is in screen space. The local-to-screen matrix can be\n     * used to transform all shapes that need to be displayed.\n     * This approach allows to keep the line widths and gizmo sizes consistent,\n     * no matter how zoomed-in the view is.\n     *\n     * @param context - The context to draw with.\n     * @param matrix - A local-to-screen matrix.\n     */\n    drawOverlay(context: CanvasRenderingContext2D, matrix: DOMMatrix): void;\n    protected transformContext(context: CanvasRenderingContext2D): void;\n    /**\n     * Try to find a node intersecting the given position.\n     *\n     * @param position - The searched position.\n     */\n    hit(position: Vector2): Node | null;\n    /**\n     * Collect all asynchronous resources used by this node.\n     */\n    protected collectAsyncResources(): void;\n    /**\n     * Wait for any asynchronous resources that this node or its children have.\n     *\n     * @remarks\n     * Certain resources like images are always loaded asynchronously.\n     * Awaiting this method makes sure that all such resources are done loading\n     * before continuing the animation.\n     */\n    toPromise(): Promise<this>;\n    /**\n     * Return a snapshot of the node's current signal values.\n     *\n     * @remarks\n     * This method will calculate the values of any reactive properties of the\n     * node at the time the method is called.\n     */\n    getState(): NodeState;\n    /**\n     * Apply the given state to the node, setting all matching signal values to\n     * the provided values.\n     *\n     * @param state - The state to apply to the node.\n     */\n    applyState(state: NodeState): void;\n    /**\n     * Smoothly transition between the current state of the node and the given\n     * state.\n     *\n     * @param state - The state to transition to.\n     * @param duration - The duration of the transition.\n     * @param timing - The timing function to use for the transition.\n     */\n    applyState(state: NodeState, duration: number, timing?: TimingFunction): ThreadGenerator;\n    /**\n     * Push a snapshot of the node's current state onto the node's state stack.\n     *\n     * @remarks\n     * This method can be used together with the {@link restore} method to save a\n     * node's current state and later restore it. It is possible to store more\n     * than one state by calling `save` method multiple times.\n     */\n    save(): void;\n    /**\n     * Restore the node to its last saved state.\n     *\n     * @remarks\n     * This method can be used together with the {@link save} method to restore a\n     * node to a previously saved state. Restoring a node to a previous state\n     * removes that state from the state stack.\n     *\n     * @example\n     * ```tsx\n     * const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n     *\n     * view.add(node);\n     *\n     * // Save the node's current state\n     * node.save();\n     *\n     * // Modify some of the node's properties\n     * yield* node.scale(2, 1);\n     * yield* node.fill('hotpink', 1);\n     *\n     * // Restore the node to its saved state\n     * node.restore();\n     * ```\n     */\n    restore(): void;\n    /**\n     * Tween the node to its last saved state.\n     *\n     * @remarks\n     * This method can be used together with the {@link save} method to restore a\n     * node to a previously saved state. Restoring a node to a previous state\n     * removes that state from the state stack.\n     *\n     * @example\n     * ```tsx\n     * const node = <Circle width={100} height={100} fill={\"lightseagreen\"} />\n     *\n     * view.add(node);\n     *\n     * // Save the node's current state\n     * node.save();\n     *\n     * // Modify some of the node's properties\n     * yield* node.scale(2, 1);\n     * yield* node.fill('hotpink', 1);\n     *\n     * // Tween the node to its saved state over 1 second\n     * yield* node.restore(1);\n     * ```\n     *\n     * @param duration - The duration of the transition.\n     * @param timing - The timing function to use for the transition.\n     */\n    restore(duration: number, timing?: TimingFunction): ThreadGenerator;\n    [Symbol.iterator](): Generator<{\n        meta: import(\"../decorators\").PropertyMetadata<any>;\n        signal: SimpleSignal<any>;\n        key: string;\n    }, void, unknown>;\n    private signalByKey;\n    private reversedChildren;\n}\n//# sourceMappingURL=Node.d.ts.map" },
  { path: "node_modules/@motion-canvas/2d/lib/components/Path.d.ts", content: "import { BBox, SignalValue, SimpleSignal, TimingFunction, Vector2 } from '@motion-canvas/core';\nimport { CurveProfile } from '../curves';\nimport { Curve, CurveProps } from './Curve';\nexport interface PathProps extends CurveProps {\n    data: SignalValue<string>;\n}\nexport declare class Path extends Curve {\n    private currentProfile;\n    readonly data: SimpleSignal<string, this>;\n    constructor(props: PathProps);\n    profile(): CurveProfile;\n    protected childrenBBox(): BBox;\n    protected lineWidthCoefficient(): number;\n    protected processSubpath(path: Path2D, startPoint: Vector2 | null, endPoint: Vector2 | null): void;\n    protected tweenData(newPath: SignalValue<string>, time: number, timingFunction: TimingFunction): Generator<void | import(\"@motion-canvas/core\").ThreadGenerator | Promise<any> | import(\"@motion-canvas/core\").Promisable<any>, void, any>;\n    drawOverlay(context: CanvasRenderingContext2D, matrix: DOMMatrix): void;\n}\n//# sourceMappingURL=Path.d.ts.map" },
  { path: "node_modules/@motion-canvas/2d/lib/components/Polygon.d.ts", content: "import { BBox, SerializedVector2, SignalValue, SimpleSignal, Vector2 } from '@motion-canvas/core';\nimport { CurveProfile } from '../curves';\nimport { DesiredLength } from '../partials';\nimport { Curve, CurveProps } from './Curve';\nexport interface PolygonProps extends CurveProps {\n    /**\n     * {@inheritDoc Polygon.sides}\n     */\n    sides?: SignalValue<number>;\n    /**\n     * {@inheritDoc Polygon.radius}\n     */\n    radius?: SignalValue<number>;\n}\n/**\n * A node for drawing regular polygons.\n *\n * @remarks\n * This node can be used to render shapes such as: triangle, pentagon,\n * hexagon and more.\n *\n * Note that the polygon is inscribed in a circle defined by the height\n * and width. If height and width are unequal, the polygon is inscribed\n * in the resulting ellipse.\n *\n * Since the polygon is inscribed in the circle, the actual displayed\n * height and width may differ somewhat from the bounding rectangle. This\n * will be particularly noticeable if the number of sides is low, e.g. for a\n * triangle.\n *\n * @preview\n * ```tsx editor\n * // snippet Polygon\n * import {makeScene2D, Polygon} from '@motion-canvas/2d';\n * import {createRef} from '@motion-canvas/core';\n *\n * export default makeScene2D(function* (view) {\n *   const ref = createRef<Polygon>();\n *   view.add(\n *     <Polygon\n *       ref={ref}\n *       sides={6}\n *       size={160}\n *       fill={'lightseagreen'}\n *     />\n *   );\n *\n *   yield* ref().sides(3, 2).to(6, 2);\n * });\n *\n * // snippet Pentagon outline\n * import {makeScene2D, Polygon} from '@motion-canvas/2d';\n *\n * export default makeScene2D(function* (view) {\n *   view.add(\n *     <Polygon\n *       sides={5}\n *       size={160}\n *       radius={30}\n *       stroke={'lightblue'}\n *       lineWidth={8}\n *     />\n *   );\n * });\n *\n * // snippet Accessing vertex data\n * import {Circle, Polygon, makeScene2D} from '@motion-canvas/2d';\n * import {createRef, range} from '@motion-canvas/core';\n *\n * export default makeScene2D(function* (view) {\n *   const polygon = createRef<Polygon>();\n *   view.add(\n *     <Polygon ref={polygon} sides={3} lineWidth={4} stroke={'white'} size={160}>\n *       {range(6).map(index => (\n *         <Circle\n *           fill={'white'}\n *           size={20}\n *           position={() => polygon().vertex(index)}\n *           opacity={() => polygon().vertexCompletion(index)}\n *         />\n *       ))}\n *     </Polygon>,\n *   );\n *\n *   yield* polygon().sides(6, 2).wait(0.5).back(2);\n * });\n * ```\n */\nexport declare class Polygon extends Curve {\n    /**\n     * The number of sides of the polygon.\n     *\n     * @remarks\n     * For example, a value of 6 creates a hexagon.\n     *\n     * @example\n     * ```tsx\n     * <Polygon\n     *   size={320}\n     *   sides={7}\n     *   stroke={'#fff'}\n     *   lineWidth={8}\n     *   fill={'lightseagreen'}\n     * />\n     * ```\n     */\n    readonly sides: SimpleSignal<number, this>;\n    /**\n     * The radius of the polygon's corners.\n     *\n     * @example\n     * ```tsx\n     * <Polygon\n     *   radius={30}\n     *   size={320}\n     *   sides={3}\n     *   stroke={'#fff'}\n     *   lineWidth={8}\n     * />\n     * ```\n     */\n    readonly radius: SimpleSignal<number, this>;\n    constructor(props: PolygonProps);\n    /**\n     * Get the position of the nth vertex in the local space of this polygon.\n     *\n     * @param index - The index of the vertex.\n     */\n    vertex(index: number): Vector2;\n    /**\n     * Get the completion of the nth vertex.\n     *\n     * @remarks\n     * The completion is a value between `0` and `1` that describes how the given\n     * vertex partakes in the polygon.\n     *\n     * For integer values of {@link sides}, the completion is simply `1` for\n     * each index making up the polygon and `0` for any other index. If `sides`\n     * includes a fraction, the last index of the polygon will have a completion\n     * equal to said fraction.\n     *\n     * Check out the {@link Polygon | Accessing vertex data} example for a\n     * demonstration.\n     *\n     * @param index - The index of the vertex.\n     */\n    vertexCompletion(index: number): number;\n    profile(): CurveProfile;\n    protected desiredSize(): SerializedVector2<DesiredLength>;\n    protected offsetComputedLayout(box: BBox): BBox;\n    protected childrenBBox(): BBox;\n    protected requiresProfile(): boolean;\n    protected getPath(): Path2D;\n    protected getRipplePath(): Path2D;\n    protected createPath(expand?: number): Path2D;\n}\n//# sourceMappingURL=Polygon.d.ts.map" },
  { path: "node_modules/@motion-canvas/2d/lib/components/QuadBezier.d.ts", content: "import { PossibleVector2, SignalValue, Vector2Signal } from '@motion-canvas/core';\nimport { PolynomialSegment } from '../curves/PolynomialSegment';\nimport { Bezier, BezierOverlayInfo } from './Bezier';\nimport { CurveProps } from './Curve';\nexport interface QuadBezierProps extends CurveProps {\n    p0?: SignalValue<PossibleVector2>;\n    p0X?: SignalValue<number>;\n    p0Y?: SignalValue<number>;\n    p1?: SignalValue<PossibleVector2>;\n    p1X?: SignalValue<number>;\n    p1Y?: SignalValue<number>;\n    p2?: SignalValue<PossibleVector2>;\n    p2X?: SignalValue<number>;\n    p2Y?: SignalValue<number>;\n}\n/**\n * A node for drawing a quadratic Bézier curve.\n *\n * @preview\n * ```tsx editor\n * import {makeScene2D, QuadBezier} from '@motion-canvas/2d';\n * import {createRef} from '@motion-canvas/core';\n *\n * export default makeScene2D(function* (view) {\n *   const bezier = createRef<QuadBezier>();\n *\n *   view.add(\n *     <QuadBezier\n *       ref={bezier}\n *       lineWidth={4}\n *       stroke={'lightseagreen'}\n *       p0={[-200, 0]}\n *       p1={[0, -200]}\n *       p2={[200, 0]}\n *       end={0}\n *     />\n *   );\n *\n *   yield* bezier().end(1, 1);\n *   yield* bezier().start(1, 1).to(0, 1);\n * });\n * ```\n */\nexport declare class QuadBezier extends Bezier {\n    /**\n     * The start point of the Bézier curve.\n     */\n    readonly p0: Vector2Signal<this>;\n    /**\n     * The control point of the Bézier curve.\n     */\n    readonly p1: Vector2Signal<this>;\n    /**\n     * The end point of the Bézier curve.\n     */\n    readonly p2: Vector2Signal<this>;\n    constructor(props: QuadBezierProps);\n    protected segment(): PolynomialSegment;\n    protected overlayInfo(matrix: DOMMatrix): BezierOverlayInfo;\n}\n//# sourceMappingURL=QuadBezier.d.ts.map" },
  { path: "node_modules/@motion-canvas/2d/lib/components/Ray.d.ts", content: "import { BBox, PossibleVector2, SignalValue, Vector2Signal } from '@motion-canvas/core';\nimport { CurveProfile } from '../curves';\nimport { Curve, CurveProps } from './Curve';\nexport interface RayProps extends CurveProps {\n    /**\n     * {@inheritDoc Ray.from}\n     */\n    from?: SignalValue<PossibleVector2>;\n    fromX?: SignalValue<number>;\n    fromY?: SignalValue<number>;\n    /**\n     * {@inheritDoc Ray.to}\n     */\n    to?: SignalValue<PossibleVector2>;\n    toX?: SignalValue<number>;\n    toY?: SignalValue<number>;\n}\n/**\n * A node for drawing an individual line segment.\n *\n * @preview\n * ```tsx editor\n * import {makeScene2D} from '@motion-canvas/2d';\n * import {Ray} from '@motion-canvas/2d';\n * import {createRef} from '@motion-canvas/core';\n *\n * export default makeScene2D(function* (view) {\n *   const ray = createRef<Ray>();\n *\n *   view.add(\n *     <Ray\n *       ref={ray}\n *       lineWidth={8}\n *       endArrow\n *       stroke={'lightseagreen'}\n *       fromX={-200}\n *       toX={200}\n *     />,\n *   );\n *\n *   yield* ray().start(1, 1);\n *   yield* ray().start(0).end(0).start(1, 1);\n * });\n * ```\n */\nexport declare class Ray extends Curve {\n    /**\n     * The starting point of the ray.\n     */\n    readonly from: Vector2Signal<this>;\n    /**\n     * The ending point of the ray.\n     */\n    readonly to: Vector2Signal<this>;\n    constructor(props: RayProps);\n    protected childrenBBox(): BBox;\n    profile(): CurveProfile;\n    drawOverlay(context: CanvasRenderingContext2D, matrix: DOMMatrix): void;\n}\n//# sourceMappingURL=Ray.d.ts.map" },
  { path: "node_modules/@motion-canvas/2d/lib/components/Rect.d.ts", content: "import { BBox, PossibleSpacing, SerializedVector2, SignalValue, SimpleSignal, SpacingSignal } from '@motion-canvas/core';\nimport { DesiredLength } from '../partials';\nimport { Curve, CurveProps } from './Curve';\nexport interface RectProps extends CurveProps {\n    /**\n     * {@inheritDoc Rect.radius}\n     */\n    radius?: SignalValue<PossibleSpacing>;\n    /**\n     * {@inheritDoc Rect.smoothCorners}\n     */\n    smoothCorners?: SignalValue<boolean>;\n    /**\n     * {@inheritDoc Rect.cornerSharpness}\n     */\n    cornerSharpness?: SignalValue<number>;\n}\nexport declare class Rect extends Curve {\n    /**\n     * Rounds the corners of this rectangle.\n     *\n     * @remarks\n     * The value represents the radius of the quarter circle that is used to round\n     * the corners. If the value is a number, the same radius is used for all\n     * corners. Passing an array of two to four numbers will set individual radii\n     * for each corner. Individual radii correspond to different corners depending\n     * on the number of values passed:\n     *\n     * ```ts\n     * // top-left-and-bottom-right | top-right-and-bottom-left\n     * [10, 30]\n     * // top-left | top-right-and-bottom-left | bottom-right\n     * [10, 20, 30]\n     * // top-left | top-right | bottom-right | bottom-left\n     * [10, 20, 30, 40]\n     * ```\n     *\n     * @example\n     * One uniform radius:\n     * ```tsx\n     * <Rect\n     *   size={320}\n     *   radius={40}\n     *   fill={'white'}\n     * />\n     * ```\n     * @example\n     * Individual radii for each corner:\n     * ```tsx\n     * <Rect\n     *   size={320}\n     *   radius={[10, 20, 30, 40]}\n     *   fill={'white'}\n     * />\n     * ```\n     */\n    readonly radius: SpacingSignal<this>;\n    /**\n     * Enables corner smoothing.\n     *\n     * @remarks\n     * This property only affects the way rounded corners are drawn. To control\n     * the corner radius use the {@link radius} property.\n     *\n     * When enabled, rounded corners are drawn continuously using Bézier curves\n     * rather than quarter circles. The sharpness of the curve can be controlled\n     * with {@link cornerSharpness}.\n     *\n     * You can read more about corner smoothing in\n     * [this article by Nick Lawrence](https://uxplanet.org/ui-ux-design-corner-smoothing-720509d1ae48).\n     *\n     * @example\n     * ```tsx\n     * <Rect\n     *   width={300}\n     *   height={300}\n     *   smoothCorners={true}\n     * />\n     * ```\n     */\n    readonly smoothCorners: SimpleSignal<boolean, this>;\n    /**\n     * Controls the sharpness of {@link smoothCorners}.\n     *\n     * @remarks\n     * This property only affects the way rounded corners are drawn. To control\n     * the corner radius use the {@link radius} property.\n     *\n     * Requires {@link smoothCorners} to be enabled to have any effect.\n     * By default, corner sharpness is set to `0.6` which represents a smooth,\n     * circle-like rounding. At `0` the edges are squared off.\n     *\n     * @example\n     * ```tsx\n     * <Rect\n     *   size={300}\n     *   smoothCorners={true}\n     *   cornerSharpness={0.7}\n     * />\n     * ```\n     */\n    readonly cornerSharpness: SimpleSignal<number, this>;\n    constructor(props: RectProps);\n    profile(): import(\"..\").CurveProfile;\n    protected desiredSize(): SerializedVector2<DesiredLength>;\n    protected offsetComputedLayout(box: BBox): BBox;\n    protected childrenBBox(): BBox;\n    protected getPath(): Path2D;\n    protected getCacheBBox(): BBox;\n    protected getRipplePath(): Path2D;\n}\n//# sourceMappingURL=Rect.d.ts.map" },
  { path: "node_modules/@motion-canvas/2d/lib/components/SVG.d.ts", content: "import { SerializedVector2, SignalValue, SimpleSignal, ThreadGenerator, TimingFunction, Vector2 } from '@motion-canvas/core';\nimport { DesiredLength } from '../partials';\nimport { Node, NodeProps } from './Node';\nimport { Shape, ShapeProps } from './Shape';\n/**\n * Represent SVG shape.\n * This only used single time because `node` may have reference to parent SVG renderer.\n */\nexport interface SVGShape {\n    id: string;\n    shape: Node;\n}\n/**\n * Data of SVGShape.\n * This can used many times  because it do not reference parent SVG.\n * This must build into SVGShape\n */\nexport interface SVGShapeData {\n    id: string;\n    type: new (props: NodeProps) => Node;\n    props: ShapeProps;\n    children?: SVGShapeData[];\n}\n/**\n * Represent SVG document that contains SVG shapes.\n * This only used single time because `nodes` have reference to parent SVG renderer.\n */\nexport interface SVGDocument {\n    size: Vector2;\n    nodes: SVGShape[];\n}\n/**\n * Data of SVGDocument.\n * This can used many times because it do not reference parent SVG.\n * This must build into SVGDocument\n */\nexport interface SVGDocumentData {\n    size: Vector2;\n    nodes: SVGShapeData[];\n}\nexport interface SVGProps extends ShapeProps {\n    svg: SignalValue<string>;\n}\n/**\nA Node for drawing and animating SVG images.\n\n@remarks\nIf you're not interested in animating SVG, you can use {@link Img} instead.\n */\nexport declare class SVG extends Shape {\n    protected static containerElement: HTMLDivElement;\n    private static svgNodesPool;\n    /**\n     * SVG string to be rendered\n     */\n    readonly svg: SimpleSignal<string, this>;\n    /**\n     * Child to wrap all SVG node\n     */\n    wrapper: Node;\n    private lastTweenTargetSrc;\n    private lastTweenTargetDocument;\n    constructor(props: SVGProps);\n    /**\n     * Get all SVG nodes with the given id.\n     * @param id - An id to query.\n     */\n    getChildrenById(id: string): Node[];\n    protected desiredSize(): SerializedVector2<DesiredLength>;\n    protected getCurrentSize(): {\n        x: number | null;\n        y: number | null;\n    };\n    protected calculateWrapperScale(documentSize: Vector2, parentSize: SerializedVector2<number | null>): Vector2;\n    /**\n     * Convert `SVGDocumentData` to `SVGDocument`.\n     * @param data - `SVGDocumentData` to convert.\n     */\n    protected buildDocument(data: SVGDocumentData): SVGDocument;\n    /**\n     * Convert `SVGShapeData` to `SVGShape`.\n     * @param data - `SVGShapeData` to convert.\n     */\n    protected buildShape({ id, type, props, children }: SVGShapeData): SVGShape;\n    /**\n     * Convert an SVG string to `SVGDocument`.\n     * @param svg - An SVG string to be parsed.\n     */\n    protected parseSVG(svg: string): SVGDocument;\n    /**\n     * Create a tweening list to tween between two SVG nodes.\n     * @param from - The initial node,\n     * @param to - The final node.\n     * @param duration - The duration of the tween.\n     * @param timing - The timing function.\n     */\n    protected generateTransformer(from: Node, to: Node, duration: number, timing: TimingFunction): Generator<ThreadGenerator>;\n    protected tweenSvg(value: SignalValue<string>, time: number, timingFunction: TimingFunction): Generator<void | ThreadGenerator | Promise<any> | import(\"@motion-canvas/core\").Promisable<any>, void, any>;\n    private wrapperScale;\n    /**\n     * Get the current `SVGDocument`.\n     */\n    private document;\n    /**\n     * Get current document nodes.\n     */\n    private documentNodes;\n    /**\n     * Convert SVG colors in Shape properties to Motion Canvas colors.\n     * @param param - Shape properties.\n     * @returns Converted Shape properties.\n     */\n    private processElementStyle;\n    /**\n     * Parse an SVG string as `SVGDocumentData`.\n     * @param svg - And SVG string to be parsed.\n     * @returns `SVGDocumentData` that can be used to build SVGDocument.\n     */\n    protected static parseSVGData(svg: string): SVGDocumentData;\n    /**\n     * Get position, rotation and scale from Matrix transformation as Shape properties\n     * @param transform - Matrix transformation\n     * @returns MotionCanvas Shape properties\n     */\n    protected static getMatrixTransformation(transform: DOMMatrix): ShapeProps;\n    /**\n     * Convert an SVG color into a Motion Canvas color.\n     * @param color - SVG color.\n     * @returns Motion Canvas color.\n     */\n    private static processSVGColor;\n    /**\n     * Get the final transformation matrix for the given SVG element.\n     * @param element - SVG element.\n     * @param parentTransform - The transformation matrix of the parent.\n     */\n    private static getElementTransformation;\n    private static parseLineCap;\n    private static parseLineJoin;\n    private static parseLineDash;\n    private static parseDashOffset;\n    private static parseOpacity;\n    /**\n     * Convert the SVG element's style to a Motion Canvas Shape properties.\n     * @param element - An SVG element whose style should be converted.\n     * @param inheritedStyle - The parent style that should be inherited.\n     */\n    private static getElementStyle;\n    /**\n     * Extract `SVGShapeData` list from the SVG element's children.\n     * This will not extract the current element's shape.\n     * @param element - An element whose children will be extracted.\n     * @param svgRoot - The SVG root (\"svg\" tag) of the element.\n     * @param parentTransform - The transformation matrix applied to the parent.\n     * @param inheritedStyle - The style of the current SVG `element` that the children should inherit.\n     */\n    private static extractGroupNodes;\n    /**\n     * Parse a number from an SVG element attribute.\n     * @param element - SVG element whose attribute will be parsed.\n     * @param name - The name of the attribute to parse.\n     * @returns a parsed number or `0` if the attribute is not defined.\n     */\n    private static parseNumberAttribute;\n    /**\n     * Extract `SVGShapeData` list from the SVG element.\n     * This will also recursively extract shapes from its children.\n     * @param child - An SVG element to extract.\n     * @param svgRoot - The SVG root (\"svg\" tag) of the element.\n     * @param parentTransform - The transformation matrix applied to the parent.\n     * @param inheritedStyle - The style of the parent SVG element that the element should inherit.\n     */\n    private static extractElementNodes;\n}\n//# sourceMappingURL=SVG.d.ts.map" },
  { path: "node_modules/@motion-canvas/2d/lib/components/Shape.d.ts", content: "import { BBox, SignalValue, SimpleSignal } from '@motion-canvas/core';\nimport { CanvasStyleSignal } from '../decorators/canvasStyleSignal';\nimport { PossibleCanvasStyle } from '../partials';\nimport { Layout, LayoutProps } from './Layout';\nexport interface ShapeProps extends LayoutProps {\n    fill?: SignalValue<PossibleCanvasStyle>;\n    stroke?: SignalValue<PossibleCanvasStyle>;\n    strokeFirst?: SignalValue<boolean>;\n    lineWidth?: SignalValue<number>;\n    lineJoin?: SignalValue<CanvasLineJoin>;\n    lineCap?: SignalValue<CanvasLineCap>;\n    lineDash?: SignalValue<number[]>;\n    lineDashOffset?: SignalValue<number>;\n    antialiased?: SignalValue<boolean>;\n}\nexport declare abstract class Shape extends Layout {\n    readonly fill: CanvasStyleSignal<this>;\n    readonly stroke: CanvasStyleSignal<this>;\n    readonly strokeFirst: SimpleSignal<boolean, this>;\n    readonly lineWidth: SimpleSignal<number, this>;\n    readonly lineJoin: SimpleSignal<CanvasLineJoin, this>;\n    readonly lineCap: SimpleSignal<CanvasLineCap, this>;\n    readonly lineDash: SimpleSignal<number[], this>;\n    readonly lineDashOffset: SimpleSignal<number, this>;\n    readonly antialiased: SimpleSignal<boolean, this>;\n    protected readonly rippleStrength: SimpleSignal<number, this>;\n    protected rippleSize(): number;\n    constructor(props: ShapeProps);\n    protected applyText(context: CanvasRenderingContext2D): void;\n    protected applyStyle(context: CanvasRenderingContext2D): void;\n    protected draw(context: CanvasRenderingContext2D): void;\n    protected drawShape(context: CanvasRenderingContext2D): void;\n    protected getCacheBBox(): BBox;\n    protected getPath(): Path2D;\n    protected getRipplePath(): Path2D;\n    protected drawRipple(context: CanvasRenderingContext2D): void;\n    ripple(duration?: number): Generator<void | import(\"@motion-canvas/core\").ThreadGenerator | Promise<any> | import(\"@motion-canvas/core\").Promisable<any>, void, any>;\n}\n//# sourceMappingURL=Shape.d.ts.map" },
  { path: "node_modules/@motion-canvas/2d/lib/components/Spline.d.ts", content: "import { BBox, PossibleVector2, SerializedVector2, SignalValue, SimpleSignal } from '@motion-canvas/core';\nimport { CurveProfile, KnotInfo } from '../curves';\nimport { DesiredLength } from '../partials';\nimport { Curve, CurveProps } from './Curve';\nexport interface SplineProps extends CurveProps {\n    /**\n     * {@inheritDoc Spline.smoothness}\n     */\n    smoothness?: SignalValue<number>;\n    /**\n     * {@inheritDoc Spline.points}\n     */\n    points?: SignalValue<SignalValue<PossibleVector2[]>>;\n}\n/**\n * A node for drawing a smooth line through a number of points.\n *\n * @remarks\n * This node uses Bézier curves for drawing each segment of the spline.\n *\n * @example\n * Defining knots using the `points` property. This will automatically\n * calculate the handle positions for each knot do draw a smooth curve. You\n * can control the smoothness of the resulting curve via the\n * {@link Spline.smoothness} property:\n *\n * ```tsx\n * <Spline\n *   lineWidth={4}\n *   stroke={'white'}\n *   smoothness={0.4}\n *   points={[\n *     [-400, 0],\n *     [-200, -300],\n *     [0, 0],\n *     [200, -300],\n *     [400, 0],\n *   ]}\n * />\n * ```\n *\n * Defining knots with {@link Knot} nodes:\n *\n * ```tsx\n * <Spline lineWidth={4} stroke={'white'}>\n *   <Knot position={[-400, 0]} />\n *   <Knot position={[-200, -300]} />\n *   <Knot\n *     position={[0, 0]}\n *     startHandle={[-100, 200]}\n *     endHandle={[100, 200]}\n *   />\n *   <Knot position={[200, -300]} />\n *   <Knot position={[400, 0]} />\n * </Spline>\n * ```\n */\nexport declare class Spline extends Curve {\n    /**\n     * The smoothness of the spline when using auto-calculated handles.\n     *\n     * @remarks\n     * This property is only applied to knots that don't use explicit handles.\n     *\n     * @defaultValue 0.4\n     */\n    readonly smoothness: SimpleSignal<number>;\n    /**\n     * The knots of the spline as an array of knots with auto-calculated handles.\n     *\n     * @remarks\n     * You can control the smoothness of the resulting curve\n     * via the {@link smoothness} property.\n     */\n    readonly points: SimpleSignal<SignalValue<PossibleVector2>[] | null, this>;\n    constructor(props: SplineProps);\n    profile(): CurveProfile;\n    knots(): KnotInfo[];\n    protected childrenBBox(): BBox;\n    protected lineWidthCoefficient(): number;\n    protected desiredSize(): SerializedVector2<DesiredLength>;\n    protected offsetComputedLayout(box: BBox): BBox;\n    private getTightBBox;\n    drawOverlay(context: CanvasRenderingContext2D, matrix: DOMMatrix): void;\n    private isKnot;\n}\n//# sourceMappingURL=Spline.d.ts.map" },
  { path: "node_modules/@motion-canvas/2d/lib/components/Txt.d.ts", content: "import { InterpolationFunction, SignalValue, SimpleSignal, ThreadGenerator, TimingFunction } from '@motion-canvas/core';\nimport { Node } from './Node';\nimport { Shape, ShapeProps } from './Shape';\nimport { TxtLeaf } from './TxtLeaf';\nimport { ComponentChildren } from './types';\ntype TxtChildren = string | Node | (string | Node)[];\ntype AnyTxt = Txt | TxtLeaf;\nexport interface TxtProps extends ShapeProps {\n    children?: TxtChildren;\n    text?: SignalValue<string>;\n}\nexport declare class Txt extends Shape {\n    /**\n     * Create a bold text node.\n     *\n     * @remarks\n     * This is a shortcut for\n     * ```tsx\n     * <Txt fontWeight={700} />\n     * ```\n     *\n     * @param props - Additional text properties.\n     */\n    static b(props: TxtProps): Txt;\n    /**\n     * Create an italic text node.\n     *\n     * @remarks\n     * This is a shortcut for\n     * ```tsx\n     * <Txt fontStyle={'italic'} />\n     * ```\n     *\n     * @param props - Additional text properties.\n     */\n    static i(props: TxtProps): Txt;\n    readonly text: SimpleSignal<string, this>;\n    protected getText(): string;\n    protected setText(value: SignalValue<string>): void;\n    protected setChildren(value: SignalValue<ComponentChildren>): void;\n    protected tweenText(value: SignalValue<string>, time: number, timingFunction: TimingFunction, interpolationFunction: InterpolationFunction<string>): ThreadGenerator;\n    protected getLayout(): boolean;\n    constructor({ children, text, ...props }: TxtProps);\n    protected innerText(): string;\n    protected parentTxt(): Txt | null;\n    protected parseChildren(children: ComponentChildren): AnyTxt[];\n    protected applyFlex(): void;\n    protected draw(context: CanvasRenderingContext2D): void;\n}\nexport {};\n//# sourceMappingURL=Txt.d.ts.map" },
  { path: "node_modules/@motion-canvas/2d/lib/components/TxtLeaf.d.ts", content: "import { BBox, SignalValue, SimpleSignal } from '@motion-canvas/core';\nimport { Shape, ShapeProps } from './Shape';\nimport { Txt } from './Txt';\nexport interface TxtLeafProps extends ShapeProps {\n    children?: string;\n    text?: SignalValue<string>;\n}\nexport declare class TxtLeaf extends Shape {\n    protected static formatter: HTMLDivElement;\n    protected static readonly segmenter: any;\n    readonly text: SimpleSignal<string, this>;\n    constructor({ children, ...rest }: TxtLeafProps);\n    protected parentTxt(): Txt | null;\n    protected draw(context: CanvasRenderingContext2D): void;\n    protected drawText(context: CanvasRenderingContext2D, text: string, box: BBox): void;\n    protected getCacheBBox(): BBox;\n    protected applyFlex(): void;\n    protected updateLayout(): void;\n}\n//# sourceMappingURL=TxtLeaf.d.ts.map" },
  { path: "node_modules/@motion-canvas/2d/lib/components/Video.d.ts", content: "import { SerializedVector2, SignalValue, SimpleSignal } from '@motion-canvas/core';\nimport { DesiredLength } from '../partials';\nimport { Rect, RectProps } from './Rect';\nexport interface VideoProps extends RectProps {\n    /**\n     * {@inheritDoc Video.src}\n     */\n    src?: SignalValue<string>;\n    /**\n     * {@inheritDoc Video.alpha}\n     */\n    alpha?: SignalValue<number>;\n    /**\n     * {@inheritDoc Video.smoothing}\n     */\n    smoothing?: SignalValue<boolean>;\n    /**\n     * {@inheritDoc Video.loop}\n     */\n    loop?: SignalValue<boolean>;\n    /**\n     * {@inheritDoc Video.playbackRate}\n     */\n    playbackRate?: number;\n    /**\n     * The starting time for this video in seconds.\n     */\n    time?: SignalValue<number>;\n    play?: boolean;\n}\nexport declare class Video extends Rect {\n    private static readonly pool;\n    /**\n     * The source of this video.\n     *\n     * @example\n     * Using a local video:\n     * ```tsx\n     * import video from './example.mp4';\n     * // ...\n     * view.add(<Video src={video} />)\n     * ```\n     * Loading an image from the internet:\n     * ```tsx\n     * view.add(<Video src=\"https://example.com/video.mp4\" />)\n     * ```\n     */\n    readonly src: SimpleSignal<string, this>;\n    /**\n     * The alpha value of this video.\n     *\n     * @remarks\n     * Unlike opacity, the alpha value affects only the video itself, leaving the\n     * fill, stroke, and children intact.\n     */\n    readonly alpha: SimpleSignal<number, this>;\n    /**\n     * Whether the video should be smoothed.\n     *\n     * @remarks\n     * When disabled, the video will be scaled using the nearest neighbor\n     * interpolation with no smoothing. The resulting video will appear pixelated.\n     *\n     * @defaultValue true\n     */\n    readonly smoothing: SimpleSignal<boolean, this>;\n    /**\n     * Whether this video should loop upon reaching the end.\n     */\n    readonly loop: SimpleSignal<boolean, this>;\n    /**\n     * The rate at which the video plays, as multiples of the normal speed.\n     *\n     * @defaultValue 1\n     */\n    readonly playbackRate: SimpleSignal<number, this>;\n    protected readonly time: SimpleSignal<number, this>;\n    protected readonly playing: SimpleSignal<boolean, this>;\n    private lastTime;\n    constructor({ play, ...props }: VideoProps);\n    isPlaying(): boolean;\n    getCurrentTime(): number;\n    getDuration(): number;\n    protected desiredSize(): SerializedVector2<DesiredLength>;\n    completion(): number;\n    protected video(): HTMLVideoElement;\n    protected seekedVideo(): HTMLVideoElement;\n    protected fastSeekedVideo(): HTMLVideoElement;\n    protected draw(context: CanvasRenderingContext2D): void;\n    protected applyFlex(): void;\n    protected setCurrentTime(value: number): void;\n    protected setPlaybackRate(playbackRate: number): void;\n    play(): void;\n    pause(): void;\n    seek(time: number): void;\n    clampTime(time: number): number;\n    protected collectAsyncResources(): void;\n}\n//# sourceMappingURL=Video.d.ts.map" },
  { path: "node_modules/@motion-canvas/2d/lib/components/View2D.d.ts", content: "import { PlaybackState, SimpleSignal } from '@motion-canvas/core';\nimport type { Node } from './Node';\nimport { Rect, RectProps } from './Rect';\nexport interface View2DProps extends RectProps {\n    assetHash: string;\n}\nexport declare class View2D extends Rect {\n    static shadowRoot: ShadowRoot;\n    readonly playbackState: SimpleSignal<PlaybackState, this>;\n    readonly globalTime: SimpleSignal<number, this>;\n    readonly assetHash: SimpleSignal<string, this>;\n    constructor(props: View2DProps);\n    dispose(): void;\n    render(context: CanvasRenderingContext2D): void;\n    /**\n     * Find a node by its key.\n     *\n     * @param key - The key of the node.\n     */\n    findKey<T extends Node = Node>(key: string): T | null;\n    protected requestLayoutUpdate(): void;\n    protected requestFontUpdate(): void;\n    view(): View2D;\n}\n//# sourceMappingURL=View2D.d.ts.map" },
  { path: "node_modules/@motion-canvas/2d/lib/components/index.d.ts", content: "export * from './Bezier';\nexport * from './Camera';\nexport * from './Circle';\nexport * from './Code';\nexport * from './CubicBezier';\nexport * from './Curve';\nexport * from './Grid';\nexport * from './Icon';\nexport * from './Img';\nexport * from './Knot';\nexport * from './Latex';\nexport * from './Layout';\nexport * from './Line';\nexport * from './Node';\nexport * from './Path';\nexport * from './Polygon';\nexport * from './QuadBezier';\nexport * from './Ray';\nexport * from './Rect';\nexport * from './SVG';\nexport * from './Shape';\nexport * from './Spline';\nexport * from './Txt';\nexport * from './Video';\nexport * from './View2D';\nexport * from './types';\n//# sourceMappingURL=index.d.ts.map" },
  { path: "node_modules/@motion-canvas/2d/lib/components/types.d.ts", content: "import type { ReferenceReceiver } from '@motion-canvas/core';\nimport type { Node } from './Node';\nexport type ComponentChild = Node | object | string | number | bigint | boolean | null | undefined;\nexport type ComponentChildren = ComponentChild | ComponentChild[];\nexport type NodeChildren = Node | Node[];\nexport type PropsOf<T> = T extends NodeConstructor<infer P> ? P : T extends FunctionComponent<infer P> ? P : never;\nexport interface JSXProps {\n    children?: ComponentChildren;\n    ref?: ReferenceReceiver<Node>;\n}\nexport interface FunctionComponent<T = any> {\n    (props: T): Node | null;\n}\nexport interface NodeConstructor<TProps = any, TNode = Node> {\n    new (props: TProps): TNode;\n}\n//# sourceMappingURL=types.d.ts.map" },
  { path: "node_modules/@motion-canvas/2d/lib/curves/ArcSegment.d.ts", content: "import { Vector2 } from '@motion-canvas/core';\nimport { CurvePoint } from './CurvePoint';\nimport { Segment } from './Segment';\nexport declare class ArcSegment extends Segment {\n    readonly startPoint: Vector2;\n    readonly radius: Vector2;\n    readonly xAxisRotationDegree: number;\n    readonly largeArcFlag: number;\n    readonly sweepFlag: number;\n    readonly endPoint: Vector2;\n    private static el;\n    readonly center: Vector2;\n    readonly startAngle: number;\n    readonly deltaAngle: number;\n    readonly xAxisRotation: number;\n    private xAxisRotationMatrix;\n    readonly points: Vector2[];\n    private length;\n    constructor(startPoint: Vector2, radius: Vector2, xAxisRotationDegree: number, largeArcFlag: number, sweepFlag: number, endPoint: Vector2);\n    getAnglePosition(angle: number): Vector2;\n    getAngleDerivative(angle: number): Vector2;\n    draw(context: CanvasRenderingContext2D | Path2D, start: number, end: number, move: boolean): [CurvePoint, CurvePoint];\n    getPoint(distance: number): CurvePoint;\n    get arcLength(): number;\n}\n//# sourceMappingURL=ArcSegment.d.ts.map" },
  { path: "node_modules/@motion-canvas/2d/lib/curves/CircleSegment.d.ts", content: "import { Vector2 } from '@motion-canvas/core';\nimport { CurvePoint } from './CurvePoint';\nimport { Segment } from './Segment';\nexport declare class CircleSegment extends Segment {\n    private center;\n    private radius;\n    private from;\n    private to;\n    private counter;\n    private readonly length;\n    private readonly angle;\n    readonly points: Vector2[];\n    constructor(center: Vector2, radius: number, from: Vector2, to: Vector2, counter: boolean);\n    get arcLength(): number;\n    draw(context: CanvasRenderingContext2D | Path2D, from: number, to: number): [CurvePoint, CurvePoint];\n    getPoint(distance: number): CurvePoint;\n}\n//# sourceMappingURL=CircleSegment.d.ts.map" },
  { path: "node_modules/@motion-canvas/2d/lib/curves/CubicBezierSegment.d.ts", content: "import { Vector2 } from '@motion-canvas/core';\nimport { PolynomialSegment } from './PolynomialSegment';\n/**\n * A spline segment representing a cubic Bézier curve.\n */\nexport declare class CubicBezierSegment extends PolynomialSegment {\n    readonly p0: Vector2;\n    readonly p1: Vector2;\n    readonly p2: Vector2;\n    readonly p3: Vector2;\n    private static el;\n    get points(): Vector2[];\n    constructor(p0: Vector2, p1: Vector2, p2: Vector2, p3: Vector2);\n    split(t: number): [PolynomialSegment, PolynomialSegment];\n    protected doDraw(context: CanvasRenderingContext2D | Path2D): void;\n    protected static getLength(p0: Vector2, p1: Vector2, p2: Vector2, p3: Vector2): number;\n}\n//# sourceMappingURL=CubicBezierSegment.d.ts.map" },
  { path: "node_modules/@motion-canvas/2d/lib/curves/CurveDrawingInfo.d.ts", content: "import { Vector2 } from '@motion-canvas/core';\nexport interface CurveDrawingInfo {\n    path: Path2D;\n    arrowSize: number;\n    endPoint: Vector2;\n    endTangent: Vector2;\n    startPoint: Vector2;\n    startTangent: Vector2;\n    startOffset: number;\n}\n//# sourceMappingURL=CurveDrawingInfo.d.ts.map" },
  { path: "node_modules/@motion-canvas/2d/lib/curves/CurvePoint.d.ts", content: "import type { Vector2 } from '@motion-canvas/core';\nexport interface CurvePoint {\n    position: Vector2;\n    /**\n     * @deprecated\n     * The tangent is currently inconsistent for different types of curves and may\n     * sometimes return the normal of the point, instead. This will be fixed in\n     * the next major version but is kept as is for now for backwards\n     * compatibility reasons. To always get the real tangent of the point, you can\n     * use `normal.flipped.perpendicular`, instead.\n     */\n    tangent: Vector2;\n    normal: Vector2;\n}\n//# sourceMappingURL=CurvePoint.d.ts.map" },
  { path: "node_modules/@motion-canvas/2d/lib/curves/CurveProfile.d.ts", content: "import { Segment } from './Segment';\nexport interface CurveProfile {\n    arcLength: number;\n    segments: Segment[];\n    minSin: number;\n}\n//# sourceMappingURL=CurveProfile.d.ts.map" },
  { path: "node_modules/@motion-canvas/2d/lib/curves/KnotInfo.d.ts", content: "import { Vector2 } from '@motion-canvas/core';\nexport type KnotAutoHandles = {\n    start: number;\n    end: number;\n};\nexport interface KnotInfo {\n    position: Vector2;\n    startHandle: Vector2;\n    endHandle: Vector2;\n    auto: KnotAutoHandles;\n}\n//# sourceMappingURL=KnotInfo.d.ts.map" },
  { path: "node_modules/@motion-canvas/2d/lib/curves/LineSegment.d.ts", content: "import { Vector2 } from '@motion-canvas/core';\nimport { CurvePoint } from './CurvePoint';\nimport { Segment } from './Segment';\nexport declare class LineSegment extends Segment {\n    readonly from: Vector2;\n    readonly to: Vector2;\n    private readonly length;\n    private readonly vector;\n    private readonly normal;\n    readonly points: Vector2[];\n    constructor(from: Vector2, to: Vector2);\n    get arcLength(): number;\n    draw(context: CanvasRenderingContext2D | Path2D, start?: number, end?: number, move?: boolean): [CurvePoint, CurvePoint];\n    getPoint(distance: number): CurvePoint;\n}\n//# sourceMappingURL=LineSegment.d.ts.map" },
  { path: "node_modules/@motion-canvas/2d/lib/curves/Polynomial.d.ts", content: "/**\n * A polynomial in the form ax^3 + bx^2 + cx + d up to a cubic polynomial.\n *\n * Source code liberally taken from:\n * https://github.com/FreyaHolmer/Mathfs/blob/master/Runtime/Curves/Polynomial.cs\n */\nexport declare class Polynomial {\n    readonly c0: number;\n    readonly c1: number;\n    readonly c2: number;\n    readonly c3: number;\n    /**\n     * Constructs a constant polynomial\n     *\n     * @param c0 - The constant coefficient\n     */\n    static constant(c0: number): Polynomial;\n    /**\n     * Constructs a linear polynomial\n     *\n     * @param c0 - The constant coefficient\n     * @param c1 - The linear coefficient\n     */\n    static linear(c0: number, c1: number): Polynomial;\n    /**\n     * Constructs a quadratic polynomial\n     *\n     * @param c0 - The constant coefficient\n     * @param c1 - The linear coefficient\n     * @param c2 - The quadratic coefficient\n     */\n    static quadratic(c0: number, c1: number, c2: number): Polynomial;\n    /**\n     * Constructs a cubic polynomial\n     *\n     * @param c0 - The constant coefficient\n     * @param c1 - The linear coefficient\n     * @param c2 - The quadratic coefficient\n     * @param c3 - The cubic coefficient\n     */\n    static cubic(c0: number, c1: number, c2: number, c3: number): Polynomial;\n    /**\n     * The degree of the polynomial\n     */\n    get degree(): number;\n    /**\n     * @param c0 - The constant coefficient\n     */\n    constructor(c0: number);\n    /**\n     * @param c0 - The constant coefficient\n     * @param c1 - The linear coefficient\n     */\n    constructor(c0: number, c1: number);\n    /**\n     * @param c0 - The constant coefficient\n     * @param c1 - The linear coefficient\n     * @param c2 - The quadratic coefficient\n     */\n    constructor(c0: number, c1: number, c2: number);\n    /**\n     * @param c0 - The constant coefficient\n     * @param c1 - The linear coefficient\n     * @param c2 - The quadratic coefficient\n     * @param c3 - The cubic coefficient\n     */\n    constructor(c0: number, c1: number, c2: number, c3: number);\n    /**\n     * Return the nth derivative of the polynomial.\n     *\n     * @param n - The number of times to differentiate the polynomial.\n     */\n    differentiate(n?: number): Polynomial;\n    /**\n     * Evaluate the polynomial at the given value t.\n     *\n     * @param t - The value to sample at\n     */\n    eval(t: number): number;\n    /**\n     * Evaluate the nth derivative of the polynomial at the given value t.\n     *\n     * @param t - The value to sample at\n     * @param derivative - The derivative of the polynomial to sample from\n     */\n    eval(t: number, derivative: number): number;\n    /**\n     * Split the polynomial into two polynomials of the same overall shape.\n     *\n     * @param u - The point at which to split the polynomial.\n     */\n    split(u: number): [Polynomial, Polynomial];\n    /**\n     * Calculate the roots (values where this polynomial = 0).\n     *\n     * @remarks\n     * Depending on the degree of the polynomial, returns between 0 and 3 results.\n     */\n    roots(): number[];\n    /**\n     * Calculate the local extrema of the polynomial.\n     */\n    localExtrema(): number[];\n    /**\n     * Calculate the local extrema of the polynomial in the unit interval.\n     */\n    localExtrema01(): number[];\n    /**\n     * Return the output value range within the unit interval.\n     */\n    outputRange01(): number[];\n    private solveCubicRoots;\n    private solveDepressedCubicRoots;\n    private solveQuadraticRoots;\n    private solveLinearRoot;\n    private almostZero;\n}\n//# sourceMappingURL=Polynomial.d.ts.map" },
  { path: "node_modules/@motion-canvas/2d/lib/curves/Polynomial2D.d.ts", content: "import { BBox, Vector2 } from '@motion-canvas/core';\nimport { Polynomial } from './Polynomial';\nexport declare class Polynomial2D {\n    readonly c0: Vector2 | Polynomial;\n    readonly c1: Vector2 | Polynomial;\n    readonly c2?: Vector2 | undefined;\n    readonly c3?: Vector2 | undefined;\n    readonly x: Polynomial;\n    readonly y: Polynomial;\n    constructor(c0: Vector2, c1: Vector2, c2: Vector2, c3: Vector2);\n    constructor(c0: Vector2, c1: Vector2, c2: Vector2);\n    constructor(x: Polynomial, y: Polynomial);\n    eval(t: number, derivative?: number): Vector2;\n    split(u: number): [Polynomial2D, Polynomial2D];\n    differentiate(n?: number): Polynomial2D;\n    evalDerivative(t: number): Vector2;\n    /**\n     * Calculate the tight axis-aligned bounds of the curve in the unit interval.\n     */\n    getBounds(): BBox;\n}\n//# sourceMappingURL=Polynomial2D.d.ts.map" },
  { path: "node_modules/@motion-canvas/2d/lib/curves/PolynomialSegment.d.ts", content: "import { BBox, Vector2 } from '@motion-canvas/core';\nimport { CurvePoint } from './CurvePoint';\nimport { Polynomial2D } from './Polynomial2D';\nimport { Segment } from './Segment';\nimport { UniformPolynomialCurveSampler } from './UniformPolynomialCurveSampler';\nexport declare abstract class PolynomialSegment extends Segment {\n    protected readonly curve: Polynomial2D;\n    protected readonly length: number;\n    protected readonly pointSampler: UniformPolynomialCurveSampler;\n    get arcLength(): number;\n    abstract get points(): Vector2[];\n    protected constructor(curve: Polynomial2D, length: number);\n    getBBox(): BBox;\n    /**\n     * Evaluate the polynomial at the given t value.\n     *\n     * @param t - The t value at which to evaluate the curve.\n     */\n    eval(t: number): CurvePoint;\n    /**\n     * Split the curve into two separate polynomials at the given t value. The two\n     * resulting curves form the same overall shape as the original curve.\n     *\n     * @param t - The t value at which to split the curve.\n     */\n    abstract split(t: number): [PolynomialSegment, PolynomialSegment];\n    getPoint(distance: number): CurvePoint;\n    transformPoints(matrix: DOMMatrix): Vector2[];\n    /**\n     * Return the tangent of the point that sits at the provided t value on the\n     * curve.\n     *\n     * @param t - The t value at which to evaluate the curve.\n     */\n    tangent(t: number): Vector2;\n    draw(context: CanvasRenderingContext2D | Path2D, start?: number, end?: number, move?: boolean): [CurvePoint, CurvePoint];\n    protected abstract doDraw(context: CanvasRenderingContext2D | Path2D): void;\n}\n//# sourceMappingURL=PolynomialSegment.d.ts.map" },
  { path: "node_modules/@motion-canvas/2d/lib/curves/QuadBezierSegment.d.ts", content: "import { Vector2 } from '@motion-canvas/core';\nimport { PolynomialSegment } from './PolynomialSegment';\n/**\n * A spline segment representing a quadratic Bézier curve.\n */\nexport declare class QuadBezierSegment extends PolynomialSegment {\n    readonly p0: Vector2;\n    readonly p1: Vector2;\n    readonly p2: Vector2;\n    private static el;\n    get points(): Vector2[];\n    constructor(p0: Vector2, p1: Vector2, p2: Vector2);\n    split(t: number): [PolynomialSegment, PolynomialSegment];\n    protected static getLength(p0: Vector2, p1: Vector2, p2: Vector2): number;\n    protected doDraw(context: CanvasRenderingContext2D | Path2D): void;\n}\n//# sourceMappingURL=QuadBezierSegment.d.ts.map" },
  { path: "node_modules/@motion-canvas/2d/lib/curves/Segment.d.ts", content: "import { Vector2 } from '@motion-canvas/core';\nimport { CurvePoint } from './CurvePoint';\nexport declare abstract class Segment {\n    abstract readonly points: Vector2[];\n    abstract draw(context: CanvasRenderingContext2D | Path2D, start: number, end: number, move: boolean): [CurvePoint, CurvePoint];\n    abstract getPoint(distance: number): CurvePoint;\n    abstract get arcLength(): number;\n}\n//# sourceMappingURL=Segment.d.ts.map" },
  { path: "node_modules/@motion-canvas/2d/lib/curves/UniformPolynomialCurveSampler.d.ts", content: "import { CurvePoint } from './CurvePoint';\nimport { PolynomialSegment } from './PolynomialSegment';\n/**\n * Class to uniformly sample points on a given polynomial curve.\n *\n * @remarks\n * In order to uniformly sample points from non-linear curves, this sampler\n * re-parameterizes the curve by arclength.\n */\nexport declare class UniformPolynomialCurveSampler {\n    private readonly curve;\n    private sampledDistances;\n    /**\n     * @param curve - The curve to sample\n     * @param samples - How many points to sample from the provided curve. The\n     *                  more points get sampled, the higher the resolution–and\n     *                  therefore precision–of the sampler.\n     */\n    constructor(curve: PolynomialSegment, samples?: number);\n    /**\n     * Discard all previously sampled points and resample the provided number of\n     * points from the curve.\n     *\n     * @param samples - The number of points to sample.\n     */\n    resample(samples: number): void;\n    /**\n     * Return the point at the provided distance along the sampled curve's\n     * arclength.\n     *\n     * @param distance - The distance along the curve's arclength for which to\n     *                   retrieve the point.\n     */\n    pointAtDistance(distance: number): CurvePoint;\n    /**\n     * Return the t value for the point at the provided distance along the sampled\n     * curve's arc length.\n     *\n     * @param distance - The distance along the arclength\n     */\n    distanceToT(distance: number): number;\n}\n//# sourceMappingURL=UniformPolynomialCurveSampler.d.ts.map" },
  { path: "node_modules/@motion-canvas/2d/lib/curves/createCurveProfileLerp.d.ts", content: "import { Vector2 } from '@motion-canvas/core';\nimport { CurveProfile } from './CurveProfile';\n/**\n * Calculate polygon perimeter\n * @param points - polygon points\n * @returns - perimeter of polygon\n */\nexport declare function polygonLength(points: Vector2[]): number;\n/**\n * Calculate total moving point distance when morphing between polygon points\n * @param points - first polygon points\n * @param reference - second polygon points\n * @param offset - offset for first polygon points\n * @returns\n */\nexport declare function calculateLerpDistance(points: Vector2[], reference: Vector2[], offset: number): number;\n/**\n * Interpolate between two polygon points.\n * @param from - source polygon points\n * @param to - target polygon points\n * @param value - interpolation progress\n * @returns - new polygon points\n */\nexport declare function polygonPointsLerp(from: Vector2[], to: Vector2[], value: number): Vector2[];\n/**\n * Create interpolator to tween between two curve\n * @param a - source curve\n * @param b - target curve\n * @returns - curve interpolator\n */\nexport declare function createCurveProfileLerp(a: CurveProfile, b: CurveProfile): (progress: number) => CurveProfile;\n//# sourceMappingURL=createCurveProfileLerp.d.ts.map" },
  { path: "node_modules/@motion-canvas/2d/lib/curves/getBezierSplineProfile.d.ts", content: "import { CurveProfile } from './CurveProfile';\nimport { KnotInfo } from './KnotInfo';\n/**\n * Calculate the curve profile of a spline based on a set of knots.\n *\n * @param knots - The knots defining the spline\n * @param closed - Whether the spline should be closed or not\n * @param smoothness - The desired smoothness of the spline when using auto\n *                     calculated handles.\n */\nexport declare function getBezierSplineProfile(knots: KnotInfo[], closed: boolean, smoothness: number): CurveProfile;\n//# sourceMappingURL=getBezierSplineProfile.d.ts.map" },
  { path: "node_modules/@motion-canvas/2d/lib/curves/getCircleProfile.d.ts", content: "import { Vector2 } from '@motion-canvas/core';\nimport { CurveProfile } from './CurveProfile';\nexport declare function getCircleProfile(size: Vector2, startAngle: number, endAngle: number, closed: boolean, counterclockwise?: boolean): CurveProfile;\n//# sourceMappingURL=getCircleProfile.d.ts.map" },
  { path: "node_modules/@motion-canvas/2d/lib/curves/getPathProfile.d.ts", content: "import { CurveProfile } from './CurveProfile';\nexport declare function getPathProfile(data: string): CurveProfile;\n//# sourceMappingURL=getPathProfile.d.ts.map" },
  { path: "node_modules/@motion-canvas/2d/lib/curves/getPointAtDistance.d.ts", content: "import { CurvePoint } from './CurvePoint';\nimport { CurveProfile } from './CurveProfile';\nexport declare function getPointAtDistance(profile: CurveProfile, distance: number): CurvePoint;\n//# sourceMappingURL=getPointAtDistance.d.ts.map" },
  { path: "node_modules/@motion-canvas/2d/lib/curves/getPolylineProfile.d.ts", content: "import { Vector2 } from '@motion-canvas/core';\nimport { CurveProfile } from './CurveProfile';\nexport declare function getPolylineProfile(points: readonly Vector2[], radius: number, closed: boolean): CurveProfile;\n//# sourceMappingURL=getPolylineProfile.d.ts.map" },
  { path: "node_modules/@motion-canvas/2d/lib/curves/getRectProfile.d.ts", content: "import { BBox, Spacing } from '@motion-canvas/core';\nimport { CurveProfile } from './CurveProfile';\nexport declare function getRectProfile(rect: BBox, radius: Spacing, smoothCorners: boolean, cornerSharpness: number): CurveProfile;\n//# sourceMappingURL=getRectProfile.d.ts.map" },
  { path: "node_modules/@motion-canvas/2d/lib/curves/index.d.ts", content: "export * from './CircleSegment';\nexport * from './CubicBezierSegment';\nexport * from './CurveDrawingInfo';\nexport * from './CurvePoint';\nexport * from './CurveProfile';\nexport * from './KnotInfo';\nexport * from './LineSegment';\nexport * from './Polynomial';\nexport * from './Polynomial2D';\nexport * from './QuadBezierSegment';\nexport * from './Segment';\nexport * from './getBezierSplineProfile';\nexport * from './getCircleProfile';\nexport * from './getPointAtDistance';\nexport * from './getPolylineProfile';\nexport * from './getRectProfile';\n//# sourceMappingURL=index.d.ts.map" },
  { path: "node_modules/@motion-canvas/2d/lib/decorators/canvasStyleSignal.d.ts", content: "import { Signal } from '@motion-canvas/core';\nimport type { CanvasStyle, PossibleCanvasStyle } from '../partials';\nexport type CanvasStyleSignal<T> = Signal<PossibleCanvasStyle, CanvasStyle, T>;\nexport declare function canvasStyleSignal(): PropertyDecorator;\n//# sourceMappingURL=canvasStyleSignal.d.ts.map" },
  { path: "node_modules/@motion-canvas/2d/lib/decorators/colorSignal.d.ts", content: "export declare function colorSignal(): PropertyDecorator;\n//# sourceMappingURL=colorSignal.d.ts.map" },
  { path: "node_modules/@motion-canvas/2d/lib/decorators/compound.d.ts", content: "import { CompoundSignalContext } from '@motion-canvas/core';\n/**\n * Create a compound property decorator.\n *\n * @remarks\n * This decorator turns a given property into a signal consisting of one or more\n * nested signals.\n *\n * @example\n * ```ts\n * class Example {\n *   \\@compound({x: 'scaleX', y: 'scaleY'})\n *   public declare readonly scale: Signal<Vector2, this>;\n *\n *   public setScale() {\n *     this.scale({x: 7, y: 3});\n *     // same as:\n *     this.scale.x(7).scale.y(3);\n *   }\n * }\n * ```\n *\n * @param entries - A record mapping the property in the compound object to the\n *                  corresponding property on the owner node.\n */\nexport declare function compound<TSetterValue, TValue extends TSetterValue, TKeys extends keyof TValue = keyof TValue, TOwner = void>(entries: Record<string, string>, klass?: typeof CompoundSignalContext<TSetterValue, TValue, TKeys, TOwner>): PropertyDecorator;\n//# sourceMappingURL=compound.d.ts.map" },
  { path: "node_modules/@motion-canvas/2d/lib/decorators/computed.d.ts", content: "/**\n * Create a computed method decorator.\n *\n * @remarks\n * This decorator turns the given method into a computed value.\n * See {@link createComputed} for more information.\n */\nexport declare function computed(): MethodDecorator;\n//# sourceMappingURL=computed.d.ts.map" },
  { path: "node_modules/@motion-canvas/2d/lib/decorators/defaultStyle.d.ts", content: "export declare function defaultStyle<T>(styleName: string, parse?: (value: string) => T): PropertyDecorator;\n//# sourceMappingURL=defaultStyle.d.ts.map" },
  { path: "node_modules/@motion-canvas/2d/lib/decorators/filtersSignal.d.ts", content: "import { Signal, SignalContext, SignalValue, SimpleSignal, ThreadGenerator, TimingFunction } from '@motion-canvas/core';\nimport { Filter, FilterName } from '../partials';\nexport type FiltersSignal<TOwner> = Signal<Filter[], Filter[], TOwner, FiltersSignalContext<TOwner>> & {\n    [K in FilterName]: SimpleSignal<number, TOwner>;\n};\nexport declare class FiltersSignalContext<TOwner> extends SignalContext<Filter[], Filter[], TOwner> {\n    constructor(initial: Filter[], owner: TOwner);\n    tweener(value: SignalValue<Filter[]>, duration: number, timingFunction: TimingFunction): ThreadGenerator;\n}\nexport declare function filtersSignal(): PropertyDecorator;\n//# sourceMappingURL=filtersSignal.d.ts.map" },
  { path: "node_modules/@motion-canvas/2d/lib/decorators/index.d.ts", content: "export * from './canvasStyleSignal';\nexport * from './colorSignal';\nexport * from './compound';\nexport * from './computed';\nexport * from './defaultStyle';\nexport * from './filtersSignal';\nexport * from './initializers';\nexport * from './nodeName';\nexport * from './signal';\nexport * from './vector2Signal';\n//# sourceMappingURL=index.d.ts.map" },
  { path: "node_modules/@motion-canvas/2d/lib/decorators/initializers.d.ts", content: "export type Initializer<T> = (instance: T, context?: any) => void;\nexport declare function addInitializer<T>(target: any, initializer: Initializer<T>): void;\nexport declare function initialize(target: any, context?: any): void;\n//# sourceMappingURL=initializers.d.ts.map" },
  { path: "node_modules/@motion-canvas/2d/lib/decorators/nodeName.d.ts", content: "/**\n * @internal\n */\nexport declare const NODE_NAME: unique symbol;\n/**\n * @internal\n */\nexport declare function nodeName(name: string): (target: any) => void;\n//# sourceMappingURL=nodeName.d.ts.map" },
  { path: "node_modules/@motion-canvas/2d/lib/decorators/signal.d.ts", content: "import { InterpolationFunction, TimingFunction } from '@motion-canvas/core';\nexport interface PropertyMetadata<T> {\n    default?: T;\n    interpolationFunction?: InterpolationFunction<T>;\n    parser?: (value: any) => T;\n    getter?: () => T;\n    setter?: (value: any) => void;\n    tweener?: (value: T, duration: number, timingFunction: TimingFunction, interpolationFunction: InterpolationFunction<T>) => void;\n    cloneable?: boolean;\n    inspectable?: boolean;\n    compoundParent?: string;\n    compound?: boolean;\n    compoundEntries: [string, string][];\n}\nexport declare function getPropertyMeta<T>(object: any, key: string | symbol): PropertyMetadata<T> | null;\nexport declare function getPropertyMetaOrCreate<T>(object: any, key: string | symbol): PropertyMetadata<T>;\nexport declare function getPropertiesOf(value: any): Record<string, PropertyMetadata<any>>;\nexport declare function initializeSignals(instance: any, props: Record<string, any>): void;\n/**\n * Create a signal decorator.\n *\n * @remarks\n * This decorator turns the given property into a signal.\n *\n * The class using this decorator can implement the following methods:\n * - `get[PropertyName]` - A property getter.\n * - `get[PropertyName]` - A property setter.\n * - `tween[PropertyName]` - A tween provider.\n *\n * @example\n * ```ts\n * class Example {\n *   \\@property()\n *   public declare length: Signal<number, this>;\n * }\n * ```\n */\nexport declare function signal<T>(): PropertyDecorator;\n/**\n * Create an initial signal value decorator.\n *\n * @remarks\n * This decorator specifies the initial value of a property.\n *\n * Must be specified before the {@link signal} decorator.\n *\n * @example\n * ```ts\n * class Example {\n *   \\@initial(1)\n *   \\@property()\n *   public declare length: Signal<number, this>;\n * }\n * ```\n *\n * @param value - The initial value of the property.\n */\nexport declare function initial<T>(value: T): PropertyDecorator;\n/**\n * Create a signal interpolation function decorator.\n *\n * @remarks\n * This decorator specifies the interpolation function of a property.\n * The interpolation function is used when tweening between different values.\n *\n * Must be specified before the {@link signal} decorator.\n *\n * @example\n * ```ts\n * class Example {\n *   \\@interpolation(textLerp)\n *   \\@property()\n *   public declare text: Signal<string, this>;\n * }\n * ```\n *\n * @param value - The interpolation function for the property.\n */\nexport declare function interpolation<T>(value: InterpolationFunction<T>): PropertyDecorator;\n/**\n * Create a signal parser decorator.\n *\n * @remarks\n * This decorator specifies the parser of a property.\n * Instead of returning the raw value, its passed as the first parameter to the\n * parser and the resulting value is returned.\n *\n * If the wrapper class has a method called `lerp` it will be set as the\n * default interpolation function for the property.\n *\n * Must be specified before the {@link signal} decorator.\n *\n * @example\n * ```ts\n * class Example {\n *   \\@wrapper(Vector2)\n *   \\@property()\n *   public declare offset: Signal<Vector2, this>;\n * }\n * ```\n *\n * @param value - The wrapper class for the property.\n */\nexport declare function parser<T>(value: (value: any) => T): PropertyDecorator;\n/**\n * Create a signal wrapper decorator.\n *\n * @remarks\n * This is a shortcut decorator for setting both the {@link parser} and\n * {@link interpolation}.\n *\n * The interpolation function will be set only if the wrapper class has a method\n * called `lerp`, which will be used as said function.\n *\n * Must be specified before the {@link signal} decorator.\n *\n * @example\n * ```ts\n * class Example {\n *   \\@wrapper(Vector2)\n *   \\@property()\n *   public declare offset: Signal<Vector2, this>;\n *\n *   // same as:\n *   \\@parser(value => new Vector2(value))\n *   \\@interpolation(Vector2.lerp)\n *   \\@property()\n *   public declare offset: Signal<Vector2, this>;\n * }\n * ```\n *\n * @param value - The wrapper class for the property.\n */\nexport declare function wrapper<T>(value: (new (value: any) => T) & {\n    lerp?: InterpolationFunction<T>;\n}): PropertyDecorator;\n/**\n * Create a cloneable property decorator.\n *\n * @remarks\n * This decorator specifies whether the property should be copied over when\n * cloning the node.\n *\n * By default, any property is cloneable.\n *\n * Must be specified before the {@link signal} decorator.\n *\n * @example\n * ```ts\n * class Example {\n *   \\@clone(false)\n *   \\@property()\n *   public declare length: Signal<number, this>;\n * }\n * ```\n *\n * @param value - Whether the property should be cloneable.\n */\nexport declare function cloneable<T>(value?: boolean): PropertyDecorator;\n/**\n * Create an inspectable property decorator.\n *\n * @remarks\n * This decorator specifies whether the property should be visible in the\n * inspector.\n *\n * By default, any property is inspectable.\n *\n * Must be specified before the {@link signal} decorator.\n *\n * @example\n * ```ts\n * class Example {\n *   \\@inspectable(false)\n *   \\@property()\n *   public declare hiddenLength: Signal<number, this>;\n * }\n * ```\n *\n * @param value - Whether the property should be inspectable.\n */\nexport declare function inspectable<T>(value?: boolean): PropertyDecorator;\n//# sourceMappingURL=signal.d.ts.map" },
  { path: "node_modules/@motion-canvas/2d/lib/decorators/spacingSignal.d.ts", content: "export declare function spacingSignal(prefix?: string): PropertyDecorator;\n//# sourceMappingURL=spacingSignal.d.ts.map" },
  { path: "node_modules/@motion-canvas/2d/lib/decorators/vector2Signal.d.ts", content: "import { PossibleVector2, Signal, Vector2 } from '@motion-canvas/core';\nimport type { Length } from '../partials';\nexport type Vector2LengthSignal<TOwner> = Signal<PossibleVector2<Length>, Vector2, TOwner> & {\n    x: Signal<Length, number, TOwner>;\n    y: Signal<Length, number, TOwner>;\n};\nexport declare function vector2Signal(prefix?: string | Record<string, string>): PropertyDecorator;\n//# sourceMappingURL=vector2Signal.d.ts.map" },
  { path: "node_modules/@motion-canvas/2d/lib/index.d.ts", content: "export * from './code';\nexport * from './components';\nexport * from './curves';\nexport * from './decorators';\nexport * from './jsx-runtime';\nexport * from './partials';\nexport * from './scenes';\nexport * from './utils';\n//# sourceMappingURL=index.d.ts.map" },
  { path: "node_modules/@motion-canvas/2d/lib/jsx-dev-runtime.d.ts", content: "import { Fragment, jsx } from './jsx-runtime';\nexport { Fragment, jsx as jsxDEV };\n//# sourceMappingURL=jsx-dev-runtime.d.ts.map" },
  { path: "node_modules/@motion-canvas/2d/lib/jsx-runtime.d.ts", content: "import type { ComponentChildren, FunctionComponent, JSXProps, Node, NodeConstructor } from './components';\nexport declare namespace JSX {\n    type Element = Node;\n    type ElementClass = Node;\n    interface ElementChildrenAttribute {\n        children: any;\n    }\n}\nexport declare const Fragment: unique symbol;\nexport declare function jsx(type: NodeConstructor | FunctionComponent | typeof Fragment, config: JSXProps, key?: any): ComponentChildren;\nexport { jsx as jsxs };\n//# sourceMappingURL=jsx-runtime.d.ts.map" },
  { path: "node_modules/@motion-canvas/2d/lib/partials/Filter.d.ts", content: "import { SignalValue, SimpleSignal } from '@motion-canvas/core';\n/**\n * All possible CSS filter names.\n *\n * @internal\n */\nexport type FilterName = 'invert' | 'sepia' | 'grayscale' | 'brightness' | 'contrast' | 'saturate' | 'hue' | 'blur';\n/**\n * Definitions of all possible CSS filters.\n *\n * @internal\n */\nexport declare const FILTERS: Record<string, Partial<FilterProps>>;\n/**\n * A unified abstraction for all CSS filters.\n */\nexport interface FilterProps {\n    name: string;\n    value: SignalValue<number>;\n    unit: string;\n    scale: number;\n    transform: boolean;\n    default: number;\n}\nexport declare class Filter {\n    get name(): string;\n    get default(): number;\n    readonly value: SimpleSignal<number, Filter>;\n    private readonly props;\n    constructor(props: Partial<FilterProps>);\n    isActive(): boolean;\n    serialize(matrix: DOMMatrix): string;\n}\n/**\n * Create an {@link https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/invert | invert} filter.\n *\n * @param value - The value of the filter.\n */\nexport declare function invert(value?: SignalValue<number>): Filter;\n/**\n * Create a {@link https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/sepia | sepia} filter.\n *\n * @param value - The value of the filter.\n */\nexport declare function sepia(value?: SignalValue<number>): Filter;\n/**\n * Create a {@link https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/grayscale | grayscale} filter.\n *\n * @param value - The value of the filter.\n */\nexport declare function grayscale(value?: SignalValue<number>): Filter;\n/**\n * Create a {@link https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/brightness | brightness} filter.\n *\n * @param value - The value of the filter.\n */\nexport declare function brightness(value?: SignalValue<number>): Filter;\n/**\n * Create a {@link https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/contrast | contrast} filter.\n *\n * @param value - The value of the filter.\n */\nexport declare function contrast(value?: SignalValue<number>): Filter;\n/**\n * Create a {@link https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/saturate | saturate} filter.\n *\n * @param value - The value of the filter.\n */\nexport declare function saturate(value?: SignalValue<number>): Filter;\n/**\n * Create a {@link https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/hue-rotate | hue} filter.\n *\n * @param value - The value of the filter in degrees.\n */\nexport declare function hue(value?: SignalValue<number>): Filter;\n/**\n * Create a {@link https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/blur | blur} filter.\n *\n * @param value - The value of the filter in pixels.\n */\nexport declare function blur(value?: SignalValue<number>): Filter;\n//# sourceMappingURL=Filter.d.ts.map" },
  { path: "node_modules/@motion-canvas/2d/lib/partials/Gradient.d.ts", content: "import { PossibleColor, PossibleVector2, SignalValue, SimpleSignal, Vector2Signal } from '@motion-canvas/core';\nexport type GradientType = 'linear' | 'conic' | 'radial';\nexport interface GradientStop {\n    offset: SignalValue<number>;\n    color: SignalValue<PossibleColor>;\n}\nexport interface GradientProps {\n    type?: SignalValue<GradientType>;\n    fromX?: SignalValue<number>;\n    fromY?: SignalValue<number>;\n    from?: SignalValue<PossibleVector2>;\n    toX?: SignalValue<number>;\n    toY?: SignalValue<number>;\n    to?: SignalValue<PossibleVector2>;\n    angle?: SignalValue<number>;\n    fromRadius?: SignalValue<number>;\n    toRadius?: SignalValue<number>;\n    stops?: GradientStop[];\n}\nexport declare class Gradient {\n    readonly type: SimpleSignal<GradientType, this>;\n    readonly from: Vector2Signal<this>;\n    readonly to: Vector2Signal<this>;\n    readonly angle: SimpleSignal<number, this>;\n    readonly fromRadius: SimpleSignal<number, this>;\n    readonly toRadius: SimpleSignal<number, this>;\n    readonly stops: SimpleSignal<GradientStop[], this>;\n    constructor(props: GradientProps);\n    canvasGradient(context: CanvasRenderingContext2D): CanvasGradient;\n}\n//# sourceMappingURL=Gradient.d.ts.map" },
  { path: "node_modules/@motion-canvas/2d/lib/partials/Pattern.d.ts", content: "import { SimpleSignal } from '@motion-canvas/core';\nexport type CanvasRepetition = null | 'repeat' | 'repeat-x' | 'repeat-y' | 'no-repeat';\nexport interface PatternProps {\n    image: CanvasImageSource;\n    repetition?: CanvasRepetition;\n}\nexport declare class Pattern {\n    readonly image: SimpleSignal<CanvasImageSource, this>;\n    readonly repetition: SimpleSignal<CanvasRepetition, this>;\n    constructor(props: PatternProps);\n    canvasPattern(context: CanvasRenderingContext2D): CanvasPattern | null;\n}\n//# sourceMappingURL=Pattern.d.ts.map" },
  { path: "node_modules/@motion-canvas/2d/lib/partials/ShaderConfig.d.ts", content: "import { SignalValue, WebGLConvertible } from '@motion-canvas/core';\nimport { Node } from '../components';\n/**\n * Describes a shader program used to apply effects to nodes.\n *\n * @experimental\n */\nexport interface ShaderConfig {\n    /**\n     * The source code of the fragment shader.\n     *\n     * @example\n     * ```glsl\n     * #version 300 es\n     * precision highp float;\n     *\n     * #include \"@motion-canvas/core/shaders/common.glsl\"\n     *\n     * void main() {\n     *     out_color = texture(core_source_tx, source_uv);\n     * }\n     * ```\n     */\n    fragment: string;\n    /**\n     * Custom uniforms to be passed to the shader.\n     *\n     * @remarks\n     * The keys of this object will be used as the uniform names.\n     * The values can be either a number or an array of numbers.\n     * The following table shows how the values will be mapped to GLSL types.\n     *\n     * | TypeScript                         | GLSL    |\n     * | ---------------------------------- | ------- |\n     * | `number`                           | `float` |\n     * | `[number, number]`                 | `vec2`  |\n     * | `[number, number, number]`         | `vec3`  |\n     * | `[number, number, number, number]` | `vec4`  |\n     *\n     * @example\n     * ```ts\n     * const shader = {\n     *   // ...\n     *   uniforms: {\n     *     my_value: () => 1,\n     *     my_vector: [1, 2, 3],\n     *   },\n     * };\n     * ```\n     *\n     * ```glsl\n     * uniform float my_value;\n     * uniform vec3 my_vector;\n     * ```\n     */\n    uniforms?: Record<string, SignalValue<number | number[] | WebGLConvertible>>;\n    /**\n     * A custom hook run before the shader is used.\n     *\n     * @remarks\n     * Gives you low-level access to the WebGL context and the shader program.\n     *\n     * @param gl - WebGL context.\n     * @param program - The shader program.\n     */\n    setup?: (gl: WebGL2RenderingContext, program: WebGLProgram) => void;\n    /**\n     * A custom hook run after the shader is used.\n     *\n     * @remarks\n     * Gives you low-level access to the WebGL context and the shader program.\n     * Can be used to clean up resources created in the {@link setup} hook.\n     *\n     * @param gl - WebGL context.\n     * @param program - The shader program.\n     */\n    teardown?: (gl: WebGL2RenderingContext, program: WebGLProgram) => void;\n}\nexport type PossibleShaderConfig = (ShaderConfig | string)[] | ShaderConfig | string | null;\nexport declare function parseShader(this: Node, value: PossibleShaderConfig): ShaderConfig[];\n//# sourceMappingURL=ShaderConfig.d.ts.map" },
  { path: "node_modules/@motion-canvas/2d/lib/partials/index.d.ts", content: "export * from './Filter';\nexport * from './Gradient';\nexport * from './Pattern';\nexport * from './types';\n//# sourceMappingURL=index.d.ts.map" },
  { path: "node_modules/@motion-canvas/2d/lib/partials/types.d.ts", content: "import { Color, PossibleColor } from '@motion-canvas/core';\nimport type { Gradient } from './Gradient';\nimport type { Pattern } from './Pattern';\nexport type FlexDirection = 'row' | 'row-reverse' | 'column' | 'column-reverse';\nexport type FlexWrap = 'nowrap' | 'wrap' | 'wrap-reverse';\nexport type FlexBasis = Length | 'content' | 'max-content' | 'min-content' | 'fit-content' | null;\nexport type FlexContent = 'center' | 'start' | 'end' | 'space-between' | 'space-around' | 'space-evenly' | 'stretch';\nexport type FlexItems = 'center' | 'start' | 'end' | 'stretch' | 'baseline';\nexport type TextWrap = boolean | 'pre';\nexport type LayoutMode = boolean | null;\n/**\n * Represents a length used by most layout properties.\n *\n * @remarks\n * The value can be either:\n * - `number` - the desired length in pixels\n * - `${number}%` - a string with the desired length in percents, for example\n *                  `'50%'`\n */\nexport type Length = number | `${number}%`;\n/**\n * Represents a desired length used internally by layout Nodes.\n *\n * @remarks\n * When the desired length is set to `null` it represents a default value for\n * whatever property it describes.\n */\nexport type DesiredLength = Length | null;\n/**\n * Represents a length limit used by layout properties such as `max-width`.\n */\nexport type LengthLimit = Length | null | 'max-content' | 'min-content';\nexport type PossibleCanvasStyle = null | PossibleColor | Gradient | Pattern;\nexport type CanvasStyle = null | Color | Gradient | Pattern;\n//# sourceMappingURL=types.d.ts.map" },
  { path: "node_modules/@motion-canvas/2d/lib/scenes/Scene2D.d.ts", content: "import { FullSceneDescription, GeneratorScene, Inspectable, InspectedAttributes, InspectedElement, Scene, ThreadGeneratorFactory, Vector2 } from '@motion-canvas/core';\nimport { Node, View2D } from '../components';\nexport declare class Scene2D extends GeneratorScene<View2D> implements Inspectable {\n    private view;\n    private registeredNodes;\n    private readonly nodeCounters;\n    private assetHash;\n    constructor(description: FullSceneDescription<ThreadGeneratorFactory<View2D>>);\n    getView(): View2D;\n    next(): Promise<void>;\n    draw(context: CanvasRenderingContext2D): void;\n    reset(previousScene?: Scene): Promise<void>;\n    inspectPosition(x: number, y: number): InspectedElement | null;\n    validateInspection(element: InspectedElement | null): InspectedElement | null;\n    inspectAttributes(element: InspectedElement): InspectedAttributes | null;\n    drawOverlay(element: InspectedElement, matrix: DOMMatrix, context: CanvasRenderingContext2D): void;\n    transformMousePosition(x: number, y: number): Vector2 | null;\n    registerNode(node: Node, key?: string): [string, () => void];\n    getNode(key: any): Node | null;\n    getDetachedNodes(): Generator<Node, void, unknown>;\n    protected recreateView(): void;\n}\n//# sourceMappingURL=Scene2D.d.ts.map" },
  { path: "node_modules/@motion-canvas/2d/lib/scenes/index.d.ts", content: "export * from './Scene2D';\nexport * from './makeScene2D';\nexport * from './useScene2D';\n//# sourceMappingURL=index.d.ts.map" },
  { path: "node_modules/@motion-canvas/2d/lib/scenes/makeScene2D.d.ts", content: "import { DescriptionOf, ThreadGeneratorFactory } from '@motion-canvas/core';\nimport type { View2D } from '../components';\nimport { Scene2D } from './Scene2D';\nexport declare function makeScene2D(runner: ThreadGeneratorFactory<View2D>): DescriptionOf<Scene2D>;\n//# sourceMappingURL=makeScene2D.d.ts.map" },
  { path: "node_modules/@motion-canvas/2d/lib/scenes/useScene2D.d.ts", content: "import type { Scene2D } from './Scene2D';\nexport declare function useScene2D(): Scene2D;\n//# sourceMappingURL=useScene2D.d.ts.map" },
  { path: "node_modules/@motion-canvas/2d/lib/utils/CanvasUtils.d.ts", content: "import { BBox, Spacing, Vector2 } from '@motion-canvas/core';\nimport { CanvasStyle, Gradient, Pattern, PossibleCanvasStyle } from '../partials';\nexport declare function canvasStyleParser(style: PossibleCanvasStyle): Gradient | Pattern | import(\"chroma-js\").Color | null;\nexport declare function resolveCanvasStyle(style: CanvasStyle, context: CanvasRenderingContext2D): string | CanvasGradient | CanvasPattern;\nexport declare function drawRoundRect(context: CanvasRenderingContext2D | Path2D, rect: BBox, radius: Spacing, smoothCorners: boolean, cornerSharpness: number): void;\nexport declare function adjustRectRadius(radius: number, horizontal: number, vertical: number, rect: BBox): number;\nexport declare function drawRect(context: CanvasRenderingContext2D | Path2D, rect: BBox): void;\nexport declare function fillRect(context: CanvasRenderingContext2D, rect: BBox): void;\nexport declare function strokeRect(context: CanvasRenderingContext2D, rect: BBox): void;\nexport declare function drawPolygon(path: CanvasRenderingContext2D | Path2D, rect: BBox, sides: number): void;\nexport declare function drawImage(context: CanvasRenderingContext2D, image: CanvasImageSource, destination: BBox): void;\nexport declare function drawImage(context: CanvasRenderingContext2D, image: CanvasImageSource, source: BBox, destination: BBox): void;\nexport declare function moveTo(context: CanvasRenderingContext2D | Path2D, position: Vector2): void;\nexport declare function lineTo(context: CanvasRenderingContext2D | Path2D, position: Vector2): void;\nexport declare function arcTo(context: CanvasRenderingContext2D | Path2D, through: Vector2, position: Vector2, radius: number): void;\nexport declare function drawLine(context: CanvasRenderingContext2D | Path2D, points: Vector2[]): void;\nexport declare function drawPivot(context: CanvasRenderingContext2D | Path2D, offset: Vector2, radius?: number): void;\nexport declare function arc(context: CanvasRenderingContext2D | Path2D, center: Vector2, radius: number, startAngle?: number, endAngle?: number, counterclockwise?: boolean): void;\nexport declare function bezierCurveTo(context: CanvasRenderingContext2D | Path2D, controlPoint1: Vector2, controlPoint2: Vector2, to: Vector2): void;\nexport declare function quadraticCurveTo(context: CanvasRenderingContext2D | Path2D, controlPoint: Vector2, to: Vector2): void;\n//# sourceMappingURL=CanvasUtils.d.ts.map" },
  { path: "node_modules/@motion-canvas/2d/lib/utils/diff.d.ts", content: "interface TransformDiff<T> {\n    inserted: TransformDiffItem<T>[];\n    deleted: TransformDiffItem<T>[];\n    transformed: TransformDiffItemTransformed<T>[];\n}\ninterface TransformDiffItem<T> {\n    before?: T;\n    beforeIdIndex: number;\n    current: T;\n    currentIndex: number;\n}\ninterface TransformDiffItemTransformed<T> {\n    insert: boolean;\n    remove: boolean;\n    from: TransformDiffItem<T>;\n    to: TransformDiffItem<T>;\n}\ninterface ApplyTransformInserted<T> {\n    item: TransformDiffItem<T>;\n    order: number;\n}\ninterface ApplyTransformResult<T> {\n    inserted: ApplyTransformInserted<T>[];\n}\ninterface Idable {\n    id: string;\n}\nexport declare function getTransformDiff<T extends Idable>(from: T[], to: T[]): TransformDiff<T>;\nexport declare function applyTransformDiff<T extends Idable>(current: T[], diff: TransformDiff<T>, cloner: (original: T) => T): ApplyTransformResult<T>;\nexport {};\n//# sourceMappingURL=diff.d.ts.map" },
  { path: "node_modules/@motion-canvas/2d/lib/utils/index.d.ts", content: "export * from './CanvasUtils';\nexport * from './is';\nexport * from './withDefaults';\n//# sourceMappingURL=index.d.ts.map" },
  { path: "node_modules/@motion-canvas/2d/lib/utils/is.d.ts", content: "/**\n * Create a predicate that checks if the given object is an instance of the\n * given class.\n *\n * @param klass - The class to check against.\n */\nexport declare function is<T>(klass: new (...args: any[]) => T): (object: any) => object is T;\n//# sourceMappingURL=is.d.ts.map" },
  { path: "node_modules/@motion-canvas/2d/lib/utils/makeSignalExtensions.d.ts", content: "import { SignalExtensions } from '@motion-canvas/core';\nimport { PropertyMetadata } from '../decorators';\nexport declare function makeSignalExtensions<TSetterValue, TValue extends TSetterValue>(meta?: Partial<PropertyMetadata<TValue>>, owner?: any, name?: string): Partial<SignalExtensions<TSetterValue, TValue>>;\n//# sourceMappingURL=makeSignalExtensions.d.ts.map" },
  { path: "node_modules/@motion-canvas/2d/lib/utils/withDefaults.d.ts", content: "import { FunctionComponent, NodeConstructor, PropsOf } from '../components';\n/**\n * Create a higher order component with default props.\n *\n * @example\n * ```tsx\n * const MyTxt = withDefaults(Txt, {\n *   fill: '#f3303f',\n * });\n *\n * // ...\n *\n * view.add(<MyTxt>Hello, World!</MyTxt>);\n * ```\n *\n * @param component - The base class or function component to wrap.\n * @param defaults - The default props to apply.\n */\nexport declare function withDefaults<T extends FunctionComponent | NodeConstructor>(component: T, defaults: PropsOf<T>): (props: PropsOf<T>) => import(\"../components\").Node;\n//# sourceMappingURL=withDefaults.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/package.json", content: "{\"name\":\"@motion-canvas/core\",\"types\":\"./lib/index.d.ts\"}" },
  { path: "node_modules/@motion-canvas/core/lib/app/Exporter.d.ts", content: "import type { MetaField } from '../meta';\nimport type { Project } from './Project';\nimport type { RendererResult, RendererSettings } from './Renderer';\n/**\n * The static interface for exporters.\n */\nexport interface ExporterClass {\n    /**\n     * The unique identifier of this exporter.\n     *\n     * @remarks\n     * This identifier will be used to store the settings of this exporter.\n     * It's recommended to prepend it with the name of the package to avoid\n     * collisions.\n     */\n    readonly id: string;\n    /**\n     * The name of this exporter.\n     *\n     * @remarks\n     * This name will be displayed in the editor.\n     */\n    readonly displayName: string;\n    /**\n     * Create an instance of this exporter.\n     *\n     * @remarks\n     * A new exporter is created whenever the user starts a new rendering process.\n     *\n     * @param project - The current project.\n     * @param settings - The rendering settings.\n     */\n    create(project: Project, settings: RendererSettings): Promise<Exporter>;\n    /**\n     * Create a meta field representing the options of this exporter.\n     */\n    meta(project: Project): MetaField<any>;\n}\n/**\n * The main interface for implementing custom exporters.\n */\nexport interface Exporter {\n    /**\n     * Prepare the rendering configuration.\n     *\n     * @remarks\n     * Called at the beginning of the rendering process, before anything else has\n     * been set up. The returned value can be used to override the rendering\n     * settings provided by the user.\n     */\n    configuration?(): Promise<RendererSettings | void>;\n    /**\n     * Begin the rendering process.\n     *\n     * @remarks\n     * Called after the rendering has been set up, right before the first frame\n     * is rendered. Once `start()` is called, it is guaranteed that the `stop()`\n     * method will be called as well. Can be used to initialize any resources that\n     * require a clean-up.\n     */\n    start?(): Promise<void>;\n    /**\n     * Export a frame.\n     *\n     * @remarks\n     * Called each time after a frame is rendered.\n     *\n     * @param canvas - A canvas containing the rendered frame.\n     * @param frame - The frame number.\n     * @param sceneFrame - The frame number within the scene.\n     * @param sceneName - The name of the scene with which the frame is associated.\n     * @param signal - An abort signal triggered if the user aborts the rendering.\n     */\n    handleFrame(canvas: HTMLCanvasElement, frame: number, sceneFrame: number, sceneName: string, signal: AbortSignal): Promise<void>;\n    /**\n     * Finish the rendering process.\n     *\n     * @remarks\n     * Guaranteed to be called after the rendering has finished - no matter the\n     * result. Can be used to finalize the exporting and perform any necessary\n     * clean-up.\n     *\n     * @param result - The result of the rendering.\n     */\n    stop?(result: RendererResult): Promise<void>;\n}\n//# sourceMappingURL=Exporter.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/app/ImageExporter.d.ts", content: "import { BoolMetaField, EnumMetaField, NumberMetaField, ObjectMetaField } from '../meta';\nimport { CanvasOutputMimeType } from '../types';\nimport type { Exporter } from './Exporter';\nimport type { Logger } from './Logger';\nimport type { Project } from './Project';\nimport type { RendererSettings } from './Renderer';\n/**\n * Image sequence exporter.\n *\n * @internal\n */\nexport declare class ImageExporter implements Exporter {\n    private readonly logger;\n    private readonly settings;\n    static readonly id = \"@motion-canvas/core/image-sequence\";\n    static readonly displayName = \"Image sequence\";\n    static meta(): ObjectMetaField<{\n        fileType: EnumMetaField<CanvasOutputMimeType>;\n        quality: NumberMetaField;\n        groupByScene: BoolMetaField;\n    }>;\n    static create(project: Project, settings: RendererSettings): Promise<ImageExporter>;\n    private static readonly response;\n    private readonly frameLookup;\n    private readonly projectName;\n    private readonly quality;\n    private readonly fileType;\n    private readonly groupByScene;\n    constructor(logger: Logger, settings: RendererSettings);\n    start(): Promise<void>;\n    handleFrame(canvas: HTMLCanvasElement, frame: number, sceneFrame: number, sceneName: string, signal: AbortSignal): Promise<void>;\n    stop(): Promise<void>;\n    private handleResponse;\n}\n//# sourceMappingURL=ImageExporter.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/app/Logger.d.ts", content: "export declare enum LogLevel {\n    Error = \"error\",\n    Warn = \"warn\",\n    Info = \"info\",\n    Http = \"http\",\n    Verbose = \"verbose\",\n    Debug = \"debug\",\n    Silly = \"silly\"\n}\n/**\n * Represents an individual log entry.\n *\n * @remarks\n * When displayed in the editor, the log entry will have the following format:\n * ```\n *                              inspect node ┐\n *   ┌ expand more          duration ┐       │\n *   ▼                               ▼       ▼\n * ┌────────────────────────────────────────────┐\n * │ ▶ message                       300 ms (+) │\n * ├────────────────────────────────────────────┤\n * │ remarks                                    │\n * │ object                                     │\n * │ stacktrace                                 │\n * └────────────────────────────────────────────┘\n * ```\n */\nexport interface LogPayload {\n    /**\n     * The log level.\n     */\n    level?: LogLevel;\n    /**\n     * The main message of the log.\n     *\n     * @remarks\n     * Always visible.\n     */\n    message: string;\n    /**\n     * Additional information about the log.\n     *\n     * @remarks\n     * Visible only when the log is expanded.\n     */\n    remarks?: string;\n    /**\n     * An object that will be serialized as JSON and displayed under the message.\n     *\n     * @remarks\n     * Visible only when the log is expanded.\n     */\n    object?: any;\n    /**\n     * The stack trace of the log.\n     *\n     * @remarks\n     * Visible only when the log is expanded.\n     * The current stack trace can be obtained using `new Error().stack`.\n     * Both Chromium and Firefox stack traces are supported.\n     */\n    stack?: string;\n    /**\n     * An optional duration in milliseconds.\n     *\n     * @remarks\n     * Can be used to display any duration related to the log.\n     * The value is always visible next to the message.\n     */\n    durationMs?: number;\n    /**\n     * An optional key used to inspect a related object.\n     *\n     * @remarks\n     * This will be used together with the {@link scenes.Inspectable} interface to\n     * display additional information about the inspected object.\n     * When specified, the log will have an \"inspect\" button that will open the\n     * \"Properties\" tab and select the inspected object.\n     */\n    inspect?: string;\n    /**\n     * Any additional information that the log may contain.\n     */\n    [K: string]: any;\n}\nexport declare class Logger {\n    /**\n     * Triggered when a new message is logged.\n     */\n    get onLogged(): import(\"../events\").Subscribable<LogPayload, import(\"../events\").EventHandler<LogPayload>>;\n    private readonly logged;\n    readonly history: LogPayload[];\n    private profilers;\n    log(payload: LogPayload): void;\n    error(payload: string | LogPayload): void;\n    warn(payload: string | LogPayload): void;\n    info(payload: string | LogPayload): void;\n    http(payload: string | LogPayload): void;\n    verbose(payload: string | LogPayload): void;\n    debug(payload: string | LogPayload): void;\n    silly(payload: string | LogPayload): void;\n    protected logLevel(level: LogLevel, payload: string | LogPayload): void;\n    profile(id: string, payload?: LogPayload): void;\n}\n//# sourceMappingURL=Logger.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/app/PlaybackManager.d.ts", content: "import type { Scene, SceneDescriptionReload, Slide } from '../scenes';\nexport declare enum PlaybackState {\n    Playing = 0,\n    Rendering = 1,\n    Paused = 2,\n    Presenting = 3\n}\n/**\n * A general class for managing a sequence of scenes.\n *\n * @remarks\n * This class provides primitive operations that can be executed on a scene\n * sequence, such as {@link progress} or {@link seek}.\n *\n * @internal\n */\nexport declare class PlaybackManager {\n    /**\n     * Triggered when the active scene changes.\n     *\n     * @eventProperty\n     */\n    get onSceneChanged(): import(\"../events\").SubscribableValueEvent<Scene<unknown>>;\n    /**\n     * Triggered when the scenes get recalculated.\n     *\n     * @remarks\n     * This event indicates that the timing of at least one scene has changed.\n     *\n     * @eventProperty\n     */\n    get onScenesRecalculated(): import(\"../events\").SubscribableValueEvent<Scene<unknown>[]>;\n    frame: number;\n    speed: number;\n    fps: number;\n    duration: number;\n    finished: boolean;\n    slides: Slide[];\n    previousScene: Scene | null;\n    state: PlaybackState;\n    get currentScene(): Scene;\n    set currentScene(scene: Scene);\n    private currentSceneReference;\n    private scenes;\n    setup(scenes: Scene[]): void;\n    progress(): Promise<boolean>;\n    seek(frame: number): Promise<boolean>;\n    goBack(): Promise<void>;\n    goForward(): Promise<void>;\n    goTo(slideId: string): Promise<void>;\n    private seekSlide;\n    reset(): Promise<void>;\n    reload(description?: SceneDescriptionReload<never>): void;\n    recalculate(): Promise<void>;\n    private next;\n    private findBestScene;\n    private getNextScene;\n}\n//# sourceMappingURL=PlaybackManager.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/app/PlaybackStatus.d.ts", content: "import { PlaybackManager, PlaybackState } from './PlaybackManager';\n/**\n * A read-only representation of the playback.\n */\nexport declare class PlaybackStatus {\n    private readonly playback;\n    constructor(playback: PlaybackManager);\n    /**\n     * Convert seconds to frames using the current framerate.\n     *\n     * @param seconds - The seconds to convert.\n     */\n    secondsToFrames(seconds: number): number;\n    /**\n     * Convert frames to seconds using the current framerate.\n     *\n     * @param frames - The frames to convert.\n     */\n    framesToSeconds(frames: number): number;\n    get time(): number;\n    get frame(): number;\n    get speed(): number;\n    get fps(): number;\n    get state(): PlaybackState;\n    /**\n     * The time passed since the last frame in seconds.\n     */\n    get deltaTime(): number;\n}\n//# sourceMappingURL=PlaybackStatus.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/app/Player.d.ts", content: "import { AudioManager } from '../media';\nimport { Vector2 } from '../types';\nimport { Logger } from './Logger';\nimport { PlaybackManager } from './PlaybackManager';\nimport { PlaybackStatus } from './PlaybackStatus';\nimport { Project } from './Project';\nexport interface PlayerState extends Record<string, unknown> {\n    paused: boolean;\n    loop: boolean;\n    muted: boolean;\n    volume: number;\n    speed: number;\n}\nexport interface PlayerSettings {\n    range: [number, number];\n    fps: number;\n    size: Vector2;\n    audioOffset: number;\n    resolutionScale: number;\n}\n/**\n * The player logic used by the editor and embeddable player.\n *\n * @remarks\n * This class builds on top of the `PlaybackManager` to provide a simple\n * interface similar to other media players. It plays through the animation\n * using a real-time update loop and optionally synchronises it with audio.\n */\nexport declare class Player {\n    private project;\n    private settings;\n    private initialState;\n    private initialFrame;\n    /**\n     * Triggered during each iteration of the update loop when the frame is ready\n     * to be rendered.\n     *\n     * @remarks\n     * Player does not perform any rendering on its own. For the animation to be\n     * visible, another class must subscribe to this event and perform the\n     * rendering itself. {@link Stage} can be used to display the animation.\n     *\n     * @eventProperty\n     */\n    get onRender(): import(\"../events\").Subscribable<void, import(\"../events\").AsyncEventHandler<void>>;\n    private readonly render;\n    get onStateChanged(): import(\"../events\").SubscribableValueEvent<PlayerState>;\n    private readonly playerState;\n    get onFrameChanged(): import(\"../events\").SubscribableValueEvent<number>;\n    private readonly frame;\n    get onDurationChanged(): import(\"../events\").SubscribableValueEvent<number>;\n    private readonly duration;\n    /**\n     * Triggered right after recalculation finishes.\n     *\n     * @remarks\n     * Can be used to provide visual feedback.\n     *\n     * @eventProperty\n     */\n    get onRecalculated(): import(\"../events\").Subscribable<void, import(\"../events\").EventHandler<void>>;\n    private readonly recalculated;\n    readonly playback: PlaybackManager;\n    readonly status: PlaybackStatus;\n    readonly audio: AudioManager;\n    readonly logger: Logger;\n    private readonly sharedWebGLContext;\n    private readonly lock;\n    private startTime;\n    private endTime;\n    private requestId;\n    private renderTime;\n    private requestedSeek;\n    private requestedRender;\n    private requestedRecalculation;\n    private size;\n    private resolutionScale;\n    private active;\n    private get startFrame();\n    private get endFrame();\n    private get finished();\n    constructor(project: Project, settings?: Partial<PlayerSettings>, initialState?: Partial<PlayerState>, initialFrame?: number);\n    configure(settings: PlayerSettings): Promise<void>;\n    /**\n     * Whether the given frame is inside the animation range.\n     *\n     * @param frame - The frame to check.\n     */\n    isInRange(frame: number): boolean;\n    /**\n     * Whether the given frame is inside the user-defined range.\n     *\n     * @param frame - The frame to check.\n     */\n    isInUserRange(frame: number): boolean;\n    requestSeek(value: number): void;\n    requestPreviousFrame(): void;\n    requestNextFrame(): void;\n    requestReset(): void;\n    requestRender(): void;\n    toggleLoop(value?: boolean): void;\n    togglePlayback(value?: boolean): void;\n    toggleAudio(value?: boolean): void;\n    setAudioVolume(value: number): void;\n    addAudioVolume(value: number): void;\n    setSpeed(value: number): void;\n    setVariables(variables: Record<string, unknown>): void;\n    /**\n     * Activate the player.\n     *\n     * @remarks\n     * A player needs to be active in order for the update loop to run. Each\n     * player is active by default.\n     */\n    activate(): void;\n    /**\n     * Deactivate the player.\n     *\n     * @remarks\n     * Deactivating the player prevents its update loop from running. This should\n     * be done before disposing the player, to prevent it from running in the\n     * background.\n     *\n     * Just pausing the player does not stop the loop.\n     */\n    deactivate(): void;\n    private requestRecalculation;\n    private prepare;\n    private run;\n    private request;\n    clampRange(frame: number): number;\n    private syncAudio;\n}\n//# sourceMappingURL=Player.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/app/Presenter.d.ts", content: "import type { Slide } from '../scenes';\nimport { PlaybackManager } from './PlaybackManager';\nimport type { Project } from './Project';\nimport { Stage, StageSettings } from './Stage';\nexport interface PresenterSettings extends StageSettings {\n    name: string;\n    fps: number;\n    slide: string | null;\n}\nexport interface PresenterInfo extends Record<string, unknown> {\n    currentSlideId: string | null;\n    nextSlideId: string | null;\n    hasNext: boolean;\n    hasPrevious: boolean;\n    isWaiting: boolean;\n    count: number;\n    index: number | null;\n}\nexport declare enum PresenterState {\n    Initial = 0,\n    Working = 1,\n    Aborting = 2\n}\nexport declare class Presenter {\n    private project;\n    get onStateChanged(): import(\"../events\").SubscribableValueEvent<PresenterState>;\n    private readonly state;\n    get onInfoChanged(): import(\"../events\").SubscribableValueEvent<PresenterInfo>;\n    private readonly info;\n    get onSlidesChanged(): import(\"../events\").SubscribableValueEvent<Slide[]>;\n    private readonly slides;\n    readonly stage: Stage;\n    private readonly lock;\n    readonly playback: PlaybackManager;\n    private readonly status;\n    private readonly logger;\n    private readonly sharedWebGLContext;\n    private abortController;\n    private renderTime;\n    private requestId;\n    private requestedResume;\n    private requestedSlide;\n    constructor(project: Project);\n    /**\n     * Present the animation.\n     *\n     * @param settings - The presentation settings.\n     */\n    present(settings: PresenterSettings): Promise<void>;\n    /**\n     * Abort the ongoing presentation process.\n     */\n    abort(): void;\n    /**\n     * Resume the presentation if waiting for the next slide.\n     */\n    resume(): void;\n    requestFirstSlide(): void;\n    requestLastSlide(): void;\n    requestPreviousSlide(): void;\n    requestNextSlide(): void;\n    requestSlide(id: string): void;\n    private run;\n    private reloadScenes;\n    private loop;\n    private request;\n    private updateInfo;\n}\n//# sourceMappingURL=Presenter.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/app/Project.d.ts", content: "import type { Plugin } from '../plugin';\nimport { FullSceneDescription } from '../scenes';\nimport { Logger } from './Logger';\nimport type { ProjectMetadata } from './ProjectMetadata';\nimport { SettingsMetadata } from './SettingsMetadata';\nexport interface ProjectSettings {\n    /**\n     * The name of the project.\n     */\n    name?: string;\n    /**\n     * A list of scene descriptions that make up the project.\n     *\n     * @remarks\n     * A full scene description can be obtained by loading a scene module with a\n     * `?scene` query parameter.\n     *\n     * @example\n     * ```ts\n     * import exampleScene from './example?scene';\n     *\n     * export default makeProject({\n     *   scenes: [exampleScene],\n     * });\n     * ```\n     */\n    scenes: FullSceneDescription[];\n    /**\n     * A list of plugins to include in the project.\n     *\n     * @remarks\n     * When a string is provided, the plugin will be imported dynamically using\n     * the string as the module specifier. This is the preferred way to include\n     * editor plugins because it makes sure that the plugin's source code gets\n     * excluded from the production build.\n     */\n    plugins?: (Plugin | string)[];\n    /**\n     * A custom logger instance to use.\n     */\n    logger?: Logger;\n    /**\n     * An url for the audio track to play alongside the animation.\n     *\n     * @see https://motioncanvas.io/docs/media#audio\n     */\n    audio?: string;\n    /**\n     * @deprecated Configure the offset in the Video Settings tab of th editor.\n     */\n    audioOffset?: number;\n    /**\n     * Default values for project variables.\n     *\n     * @see https://motioncanvas.io/docs/project-variables\n     */\n    variables?: Record<string, unknown>;\n    /**\n     * Enable experimental features.\n     *\n     * @see https://motioncanvas.io/docs/experimental\n     *\n     * @experimental\n     */\n    experimentalFeatures?: boolean;\n}\nexport interface Versions {\n    core: string;\n    two: string | null;\n    ui: string | null;\n    vitePlugin: string | null;\n}\nexport interface Project {\n    name: string;\n    scenes: FullSceneDescription[];\n    plugins: Plugin[];\n    logger: Logger;\n    meta: ProjectMetadata;\n    settings: SettingsMetadata;\n    audio?: string;\n    variables?: Record<string, unknown>;\n    versions: Versions;\n    experimentalFeatures: boolean;\n}\nexport declare function makeProject(settings: ProjectSettings): ProjectSettings;\n//# sourceMappingURL=Project.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/app/ProjectMetadata.d.ts", content: "import { ColorMetaField, EnumMetaField, ExporterMetaField, MetaField, NumberMetaField, ObjectMetaField, RangeMetaField, Vector2MetaField } from '../meta';\nimport { CanvasColorSpace, Color, Vector2 } from '../types';\nimport type { Project } from './Project';\ndeclare function createProjectMetadata(project: Project): {\n    version: MetaField<unknown, number>;\n    shared: ObjectMetaField<{\n        background: ColorMetaField;\n        range: RangeMetaField;\n        size: Vector2MetaField;\n        audioOffset: NumberMetaField;\n    }>;\n    preview: ObjectMetaField<{\n        fps: NumberMetaField;\n        resolutionScale: EnumMetaField<number>;\n    }>;\n    rendering: ObjectMetaField<{\n        fps: NumberMetaField;\n        resolutionScale: EnumMetaField<number>;\n        colorSpace: EnumMetaField<CanvasColorSpace>;\n        exporter: ExporterMetaField;\n    }>;\n};\nexport declare class ProjectMetadata extends ObjectMetaField<ReturnType<typeof createProjectMetadata>> {\n    constructor(project: Project);\n    getFullPreviewSettings(): {\n        fps: number;\n        resolutionScale: number;\n        background: Color | null;\n        range: [number, number];\n        size: Vector2;\n        audioOffset: number;\n    };\n    getFullRenderingSettings(): {\n        fps: number;\n        resolutionScale: number;\n        colorSpace: CanvasColorSpace;\n        background: Color | null;\n        range: [number, number];\n        size: Vector2;\n        audioOffset: number;\n        exporter: {\n            name: string;\n            options: unknown;\n        };\n    };\n}\nexport {};\n//# sourceMappingURL=ProjectMetadata.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/app/Renderer.d.ts", content: "import type { Project } from './Project';\nimport { Stage, StageSettings } from './Stage';\nimport { TimeEstimator } from './TimeEstimator';\nexport interface RendererSettings extends StageSettings {\n    name: string;\n    range: [number, number];\n    fps: number;\n    exporter: {\n        name: string;\n        options: unknown;\n    };\n}\nexport declare enum RendererState {\n    Initial = 0,\n    Working = 1,\n    Aborting = 2\n}\nexport declare enum RendererResult {\n    Success = 0,\n    Error = 1,\n    Aborted = 2\n}\n/**\n * The rendering logic used by the editor to export animations.\n *\n * @remarks\n * This class uses the `PlaybackManager` to render animations. In contrast to a\n * player, a renderer does not use an update loop. It plays through the\n * animation as fast as it can, occasionally pausing to keep the UI responsive.\n *\n * The actual exporting is outsourced to an {@link Exporter}.\n */\nexport declare class Renderer {\n    private project;\n    get onStateChanged(): import(\"../events\").SubscribableValueEvent<RendererState>;\n    private readonly state;\n    get onFinished(): import(\"../events\").Subscribable<RendererResult, import(\"../events\").EventHandler<RendererResult>>;\n    private readonly finished;\n    get onFrameChanged(): import(\"../events\").SubscribableValueEvent<number>;\n    private readonly frame;\n    readonly stage: Stage;\n    readonly estimator: TimeEstimator;\n    private readonly lock;\n    private readonly playback;\n    private readonly status;\n    private readonly sharedWebGLContext;\n    private exporter;\n    private abortController;\n    constructor(project: Project);\n    /**\n     * Render the animation using the provided settings.\n     *\n     * @param settings - The rendering settings.\n     */\n    render(settings: RendererSettings): Promise<void>;\n    /**\n     * Abort the ongoing render process.\n     */\n    abort(): void;\n    /**\n     * Export an individual frame.\n     *\n     * @remarks\n     * This method always uses the default `ImageExporter`.\n     *\n     * @param settings - The rendering settings.\n     * @param time - The timestamp to export.\n     */\n    renderFrame(settings: RendererSettings, time: number): Promise<void>;\n    private run;\n    private reloadScenes;\n    private exportFrame;\n}\n//# sourceMappingURL=Renderer.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/app/SettingsMetadata.d.ts", content: "import { BoolMetaField, ColorMetaField, MetaField, ObjectMetaField, Vector2MetaField } from '../meta';\n/**\n * Create a runtime representation of the settings metadata.\n */\nexport declare function createSettingsMetadata(): ObjectMetaField<{\n    version: MetaField<any, number>;\n    appearance: ObjectMetaField<{\n        color: ColorMetaField;\n        font: BoolMetaField;\n        coordinates: BoolMetaField;\n    }>;\n    defaults: ObjectMetaField<{\n        background: ColorMetaField;\n        size: Vector2MetaField;\n    }>;\n}>;\n/**\n * A runtime representation of the settings metadata.\n */\nexport type SettingsMetadata = ReturnType<typeof createSettingsMetadata>;\n//# sourceMappingURL=SettingsMetadata.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/app/SharedWebGLContext.d.ts", content: "import { Logger } from './Logger';\n/**\n * @internal\n */\nexport interface WebGLContextOwner {\n    setup(gl: WebGL2RenderingContext): void;\n    teardown(gl: WebGL2RenderingContext): void;\n}\nexport declare class SharedWebGLContext {\n    private readonly logger;\n    private gl;\n    private currentOwner;\n    private readonly programLookup;\n    constructor(logger: Logger);\n    borrow(owner: WebGLContextOwner): WebGL2RenderingContext;\n    /**\n     * Dispose the WebGL context to free up resources.\n     */\n    dispose(): void;\n    getProgram(fragment: string, vertex: string): WebGLProgram | null;\n    private getShader;\n    private getGL;\n}\n//# sourceMappingURL=SharedWebGLContext.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/app/Stage.d.ts", content: "import { Scene } from '../scenes';\nimport type { Color } from '../types';\nimport { CanvasColorSpace, Vector2 } from '../types';\nexport interface StageSettings {\n    size: Vector2;\n    resolutionScale: number;\n    colorSpace: CanvasColorSpace;\n    background: Color | string | null;\n}\n/**\n * Manages canvases on which an animation can be displayed.\n */\nexport declare class Stage {\n    private background;\n    private resolutionScale;\n    private colorSpace;\n    private size;\n    readonly finalBuffer: HTMLCanvasElement;\n    private readonly currentBuffer;\n    private readonly previousBuffer;\n    private context;\n    private currentContext;\n    private previousContext;\n    private get canvasSize();\n    constructor();\n    configure({ colorSpace, size, resolutionScale, background, }: Partial<StageSettings>): void;\n    render(currentScene: Scene, previousScene: Scene | null): Promise<void>;\n    resizeCanvas(context: CanvasRenderingContext2D): void;\n}\n//# sourceMappingURL=Stage.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/app/TimeEstimator.d.ts", content: "/**\n * An estimate of the time remaining until the process is finished.\n */\nexport interface TimeEstimate {\n    /**\n     * The completion percentage ranging from `0` to `1`.\n     */\n    completion: number;\n    /**\n     * The time passed since the beginning of the process in milliseconds.\n     */\n    elapsed: number;\n    /**\n     * The estimated time remaining until the process is finished in milliseconds.\n     */\n    eta: number;\n}\n/**\n * Calculates the estimated time remaining until a process is finished.\n */\nexport declare class TimeEstimator {\n    get onCompletionChanged(): import(\"../events\").SubscribableValueEvent<number>;\n    private readonly completion;\n    private startTimestamp;\n    private lastUpdateTimestamp;\n    private nextCompletion;\n    /**\n     * Get the current time estimate.\n     *\n     * @param timestamp - The timestamp to calculate the estimate against.\n     *                    Defaults to `performance.now()`.\n     */\n    estimate(timestamp?: number): TimeEstimate;\n    /**\n     * Update the completion percentage.\n     *\n     * @param completion - The completion percentage ranging from `0` to `1`.\n     * @param timestamp - A timestamp at which the process was updated.\n     *                    Defaults to `performance.now()`.\n     */\n    update(completion: number, timestamp?: number): void;\n    /**\n     * Reset the estimator.\n     *\n     * @param nextCompletion - If known, the completion percentage of the next\n     *                         update.\n     * @param timestamp - A timestamp at which the process started.\n     *                    Defaults to `performance.now()`.\n     */\n    reset(nextCompletion?: number, timestamp?: number): void;\n}\n//# sourceMappingURL=TimeEstimator.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/app/bootstrap.d.ts", content: "import { MetaFile } from '../meta';\nimport { Plugin } from '../plugin';\nimport { Logger } from './Logger';\nimport { Project, ProjectSettings, Versions } from './Project';\n/**\n * Bootstrap a project.\n *\n * @param name - The name of the project.\n * @param versions - Package versions.\n * @param plugins - Loaded plugins.\n * @param config - Project settings.\n * @param metaFile - The project meta file.\n * @param settingsFile - The settings meta file.\n * @param logger - An optional logger instance.\n *\n * @internal\n */\nexport declare function bootstrap(name: string, versions: Versions, plugins: Plugin[], config: ProjectSettings, metaFile: MetaFile<any>, settingsFile: MetaFile<any>, logger?: Logger): Project;\n/**\n * Bootstrap a project together with all editor plugins.\n *\n * @param name - The name of the project.\n * @param versions - Package versions.\n * @param plugins - Loaded plugins.\n * @param config - Project settings.\n * @param metaFile - The project meta file.\n * @param settingsFile - The settings meta file.\n *\n * @internal\n */\nexport declare function editorBootstrap(name: string, versions: Versions, plugins: (Plugin | string)[], config: ProjectSettings, metaFile: MetaFile<any>, settingsFile: MetaFile<any>): Promise<Project>;\n//# sourceMappingURL=bootstrap.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/app/index.d.ts", content: "/**\n * Main Motion Canvas classes.\n *\n * @packageDocumentation\n */\nexport * from './Exporter';\nexport * from './ImageExporter';\nexport * from './Logger';\nexport * from './PlaybackManager';\nexport * from './PlaybackStatus';\nexport * from './Player';\nexport * from './Presenter';\nexport * from './Project';\nexport * from './ProjectMetadata';\nexport * from './Renderer';\nexport * from './SettingsMetadata';\nexport * from './SharedWebGLContext';\nexport * from './Stage';\nexport * from './bootstrap';\n//# sourceMappingURL=index.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/app/presets.d.ts", content: "import { MetaOption } from '../meta';\nimport { CanvasColorSpace, CanvasOutputMimeType } from '../types';\nexport declare const Scales: MetaOption<number>[];\nexport declare const ColorSpaces: MetaOption<CanvasColorSpace>[];\nexport declare const FileTypes: MetaOption<CanvasOutputMimeType>[];\nexport declare const FrameRates: MetaOption<number>[];\n//# sourceMappingURL=presets.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/decorators/decorate.d.ts", content: "export declare function decorate(fn: Callback, ...decorators: MethodDecorator[]): void;\n//# sourceMappingURL=decorate.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/decorators/deprecated.d.ts", content: "/**\n * Create a deprecated decorator that marks methods as deprecated.\n */\nexport declare function deprecated(remarks?: string): MethodDecorator;\n//# sourceMappingURL=deprecated.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/decorators/index.d.ts", content: "/**\n * Property decorators.\n *\n * @packageDocumentation\n */\nexport * from './decorate';\nexport * from './lazy';\nexport * from './threadable';\n//# sourceMappingURL=index.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/decorators/lazy.d.ts", content: "/**\n * Create a lazy decorator.\n *\n * @remarks\n * A property marked as lazy will not be initialized until it's requested for\n * the first time. Lazy properties are read-only.\n *\n * Must be used for any static properties that require the DOM API to be\n * initialized.\n *\n * @param factory - A function that returns the value of this property.\n */\nexport declare function lazy(factory: () => unknown): PropertyDecorator;\n//# sourceMappingURL=lazy.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/decorators/threadable.d.ts", content: "export declare function threadable(customName?: string): MethodDecorator;\n//# sourceMappingURL=threadable.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/events/AsyncEventDispatcher.d.ts", content: "import { EventDispatcherBase, Subscribable } from './EventDispatcherBase';\nexport interface AsyncEventHandler<T> {\n    (value: T): Promise<void>;\n}\n/**\n * Dispatches an asynchronous {@link SubscribableEvent}.\n *\n * @remarks\n * The {@link dispatch} method returns a promise that resolves when all the\n * handlers resolve.\n *\n * @example\n * ```ts\n * class Example {\n *   // expose the event to external classes\n *   public get onValueChanged {\n *     return this.value.subscribable;\n *   }\n *   // create a private dispatcher\n *   private value = new AsyncEventDispatcher<number>();\n *\n *   private async dispatchExample() {\n *     // dispatching returns a Promise.\n *     await this.value.dispatch(0);\n *   }\n * }\n * ```\n *\n * @typeParam T - The type of the argument passed to subscribers.\n */\nexport declare class AsyncEventDispatcher<T> extends EventDispatcherBase<T, AsyncEventHandler<T>> {\n    dispatch(value: T): Promise<void>;\n}\n/**\n * Provides safe access to the public interface of {@link AsyncEventDispatcher}.\n *\n * @remarks\n * External classes can use it to subscribe to an event without being able to\n * dispatch it.\n *\n * @typeParam T - The type of the argument passed to subscribers.\n */\nexport type SubscribableAsyncEvent<T> = Subscribable<T, AsyncEventHandler<T>>;\n//# sourceMappingURL=AsyncEventDispatcher.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/events/EventDispatcher.d.ts", content: "import { EventDispatcherBase, Subscribable } from './EventDispatcherBase';\n/**\n * Dispatches a {@link SubscribableEvent}.\n *\n * @example\n * ```ts\n * class Example {\n *   // expose the event to external classes\n *   public get onValueChanged {\n *     return this.value.subscribable;\n *   }\n *   // create a private dispatcher\n *   private value = new EventDispatcher<number>();\n *\n *   private dispatchExample() {\n *     // dispatching will notify all subscribers.\n *     this.value.dispatch(0);\n *   }\n * }\n * ```\n *\n * @typeParam T - The type of the value argument to subscribers.\n */\nexport declare class EventDispatcher<T> extends EventDispatcherBase<T> {\n    dispatch(value: T): void;\n}\n/**\n * Provides safe access to the public interface of {@link EventDispatcher}.\n *\n * @remarks\n * External classes can use it to subscribe to an event without being able to\n * dispatch it.\n *\n * @typeParam T - The type of the argument passed to subscribers.\n */\nexport type SubscribableEvent<T> = Subscribable<T>;\n//# sourceMappingURL=EventDispatcher.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/events/EventDispatcherBase.d.ts", content: "export interface EventHandler<T> {\n    (value: T): any;\n}\n/**\n * A base for dispatching {@link Subscribable}s.\n *\n * @typeParam TValue - The type of the argument passed to subscribers.\n * @typeParam THandler - The type of the callback function.\n */\nexport declare abstract class EventDispatcherBase<TValue, THandler extends EventHandler<TValue> = EventHandler<TValue>> {\n    readonly subscribable: Subscribable<TValue, THandler>;\n    private subscribers;\n    /**\n     * {@inheritDoc Subscribable.subscribe}\n     */\n    subscribe(handler: THandler): () => void;\n    /**\n     * {@inheritDoc Subscribable.unsubscribe}\n     */\n    unsubscribe(handler: THandler): void;\n    /**\n     * Unsubscribe all subscribers from the event.\n     */\n    clear(): void;\n    protected notifySubscribers(value: TValue): ReturnType<THandler>[];\n}\n/**\n * Provides safe access to the public interface of {@link EventDispatcherBase}.\n *\n * @remarks\n * External classes can use it to subscribe to an event without being able to\n * dispatch it.\n *\n * @typeParam TValue - The type of the argument passed to subscribers.\n * @typeParam THandler - The type of the callback function.\n */\nexport declare class Subscribable<TValue, THandler extends EventHandler<TValue> = EventHandler<TValue>> {\n    protected dispatcher: EventDispatcherBase<TValue, THandler>;\n    constructor(dispatcher: EventDispatcherBase<TValue, THandler>);\n    /**\n     * Subscribe to the event.\n     *\n     * @param handler - The handler to invoke when the event occurs.\n     *\n     * @returns A callback function that cancels the subscription.\n     */\n    subscribe(handler: THandler): () => void;\n    /**\n     * Unsubscribe from the event.\n     *\n     * @param handler - The handler to unsubscribe.\n     */\n    unsubscribe(handler: THandler): void;\n}\n//# sourceMappingURL=EventDispatcherBase.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/events/FlagDispatcher.d.ts", content: "import { EventDispatcherBase, EventHandler, Subscribable } from './EventDispatcherBase';\n/**\n * Dispatches a {@link SubscribableFlagEvent}.\n *\n * @remarks\n * Subscribers are notified only when the flag is set.\n * Subsequent calls to {@link raise} don't trigger anything.\n * Any handlers added while the flag is raised are immediately invoked.\n *\n * Resetting the flag doesn't notify the subscribers, but raising it again does.\n *\n * @example\n * ```ts\n * class Example {\n *   // expose the event to external classes\n *   public get onChanged {\n *     return this.flag.subscribable;\n *   }\n *   // create a private dispatcher\n *   private flag = new FlagDispatcher();\n *\n *   private dispatchExample() {\n *     // setting the flag will notify all subscribers\n *     this.flag.raise();\n *   }\n * }\n * ```\n */\nexport declare class FlagDispatcher extends EventDispatcherBase<void> {\n    private value;\n    /**\n     * Notify all current and future subscribers.\n     */\n    raise(): void;\n    /**\n     * Stop notifying future subscribers.\n     */\n    reset(): void;\n    /**\n     * Are subscribers being notified?\n     */\n    isRaised(): boolean;\n    subscribe(handler: EventHandler<void>): () => void;\n}\n/**\n * Provides safe access to the public interface of {@link FlagDispatcher}.\n *\n * @remarks\n * External classes can use it to subscribe to an event without being able to\n * dispatch it.\n */\nexport type SubscribableFlagEvent = Subscribable<void>;\n//# sourceMappingURL=FlagDispatcher.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/events/ValueDispatcher.d.ts", content: "import { EventDispatcherBase, EventHandler, Subscribable } from './EventDispatcherBase';\n/**\n * Dispatches a {@link SubscribableValueEvent}\n *\n * @remarks\n * Changing the value stored by a value dispatcher will immediately notify all\n * its subscribers.\n *\n * @example\n * ```ts\n * class Example {\n *   // expose the event to external classes\n *   public get onValueChanged {\n *     return this.value.subscribable;\n *   }\n *   // create a private dispatcher\n *   private value = new ValueDispatcher(0);\n *\n *   private changingValueExample() {\n *     // changing the value will notify all subscribers.\n *     this.value.current = 7;\n *   }\n * }\n * ```\n *\n * @typeParam T - The type of the value passed to subscribers.\n */\nexport declare class ValueDispatcher<T> extends EventDispatcherBase<T> {\n    private value;\n    readonly subscribable: SubscribableValueEvent<T>;\n    /**\n     * {@inheritDoc SubscribableValueEvent.current}\n     */\n    get current(): T;\n    /**\n     * Set the current value of this dispatcher.\n     *\n     * @remarks\n     * Setting the value will immediately notify all subscribers.\n     *\n     * @param value - The new value.\n     */\n    set current(value: T);\n    /**\n     * @param value - The initial value.\n     */\n    constructor(value: T);\n    /**\n     * {@inheritDoc SubscribableValueEvent.subscribe}\n     */\n    subscribe(handler: EventHandler<T>, dispatchImmediately?: boolean): () => void;\n}\n/**\n * Provides safe access to the public interface of {@link ValueDispatcher}.\n *\n * @remarks\n * External classes can use it to subscribe to an event without being able to\n * dispatch it.\n *\n * @typeParam T - The type of the value passed to subscribers.\n */\nexport declare class SubscribableValueEvent<T> extends Subscribable<T, EventHandler<T>> {\n    /**\n     * Get the most recent value of this dispatcher.\n     */\n    get current(): T;\n    /**\n     * Subscribe to the event.\n     *\n     * Subscribing will immediately invoke the handler with the most recent value.\n     *\n     * @param handler - The handler to invoke when the event occurs.\n     * @param dispatchImmediately - Whether the handler should be immediately\n     *                              invoked with the most recent value.\n     *\n     * @returns Callback function that cancels the subscription.\n     */\n    subscribe(handler: EventHandler<T>, dispatchImmediately?: boolean): () => void;\n}\n//# sourceMappingURL=ValueDispatcher.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/events/index.d.ts", content: "/**\n * Subscriptions and triggering of events.\n *\n * @packageDocumentation\n */\nexport * from './AsyncEventDispatcher';\nexport * from './EventDispatcher';\nexport * from './EventDispatcherBase';\nexport * from './FlagDispatcher';\nexport * from './ValueDispatcher';\n//# sourceMappingURL=index.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/flow/all.d.ts", content: "import { ThreadGenerator } from '../threading';\n/**\n * Run all tasks concurrently and wait for all of them to finish.\n *\n * @example\n * ```ts\n * // current time: 0s\n * yield* all(\n *   rect.fill('#ff0000', 2),\n *   rect.opacity(1, 1),\n * );\n * // current time: 2s\n * ```\n *\n * @param tasks - A list of tasks to run.\n */\nexport declare function all(...tasks: ThreadGenerator[]): ThreadGenerator;\n//# sourceMappingURL=all.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/flow/any.d.ts", content: "import { ThreadGenerator } from '../threading';\n/**\n * Run all tasks concurrently and wait for any of them to finish.\n *\n * @example\n * ```ts\n * // current time: 0s\n * yield* any(\n *   rect.fill('#ff0000', 2),\n *   rect.opacity(1, 1),\n * );\n * // current time: 1s\n * ```\n *\n * @param tasks - A list of tasks to run.\n */\nexport declare function any(...tasks: ThreadGenerator[]): ThreadGenerator;\n//# sourceMappingURL=any.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/flow/chain.d.ts", content: "import { ThreadGenerator } from '../threading';\n/**\n * Run tasks one after another.\n *\n * @example\n * ```ts\n * // current time: 0s\n * yield* chain(\n *   rect.fill('#ff0000', 2),\n *   rect.opacity(1, 1),\n * );\n * // current time: 3s\n * ```\n *\n * Note that the same animation can be written as:\n * ```ts\n * yield* rect.fill('#ff0000', 2),\n * yield* rect.opacity(1, 1),\n * ```\n *\n * The reason `chain` exists is to make it easier to pass it to other flow\n * functions. For example:\n * ```ts\n * yield* all(\n *   rect.radius(20, 3),\n *   chain(\n *     rect.fill('#ff0000', 2),\n *     rect.opacity(1, 1),\n *   ),\n * );\n * ```\n *\n * @param tasks - A list of tasks to run.\n */\nexport declare function chain(...tasks: (ThreadGenerator | Callback)[]): ThreadGenerator;\n//# sourceMappingURL=chain.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/flow/delay.d.ts", content: "import { ThreadGenerator } from '../threading';\n/**\n * Run the given generator or callback after a specific amount of time.\n *\n * @example\n * ```ts\n * yield* delay(1, rect.fill('#ff0000', 2));\n * ```\n *\n * Note that the same animation can be written as:\n * ```ts\n * yield* waitFor(1),\n * yield* rect.fill('#ff0000', 2),\n * ```\n *\n * The reason `delay` exists is to make it easier to pass it to other flow\n * functions. For example:\n * ```ts\n * yield* all(\n *   rect.opacity(1, 3),\n *   delay(1, rect.fill('#ff0000', 2));\n * );\n * ```\n *\n * @param time - The delay in seconds\n * @param task - The task or callback to run after the delay.\n */\nexport declare function delay(time: number, task: ThreadGenerator | Callback): ThreadGenerator;\n//# sourceMappingURL=delay.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/flow/every.d.ts", content: "import { ThreadGenerator } from '../threading';\nexport interface EveryCallback {\n    /**\n     * A callback called by {@link EveryTimer} every N seconds.\n     *\n     * @param tick - The amount of times the timer has ticked.\n     */\n    (tick: number): void;\n}\nexport interface EveryTimer {\n    /**\n     * The generator responsible for running this timer.\n     */\n    runner: ThreadGenerator;\n    setInterval(value: number): void;\n    setCallback(value: EveryCallback): void;\n    /**\n     * Wait until the timer ticks.\n     */\n    sync(): ThreadGenerator;\n}\n/**\n * Call the given callback every N seconds.\n *\n * @example\n * ```ts\n * const timer = every(2, time => console.log(time));\n * yield timer.runner;\n *\n * // current time: 0s\n * yield* waitFor(5);\n * // current time: 5s\n * yield* timer.sync();\n * // current time: 6s\n * ```\n *\n * @param interval - The interval between subsequent calls.\n * @param callback - The callback to be called.\n */\nexport declare function every(interval: number, callback: EveryCallback): EveryTimer;\n//# sourceMappingURL=every.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/flow/index.d.ts", content: "/**\n * Utilities for controlling the flow and timing of an animation.\n * @packageDocumentation\n */\nexport * from './all';\nexport * from './any';\nexport * from './chain';\nexport * from './delay';\nexport * from './every';\nexport * from './loop';\nexport * from './loopFor';\nexport * from './loopUntil';\nexport * from './noop';\nexport * from './run';\nexport * from './scheduling';\nexport * from './sequence';\n//# sourceMappingURL=index.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/flow/loop.d.ts", content: "import { ThreadGenerator } from '../threading';\nexport interface LoopCallback {\n    /**\n     * A callback called by {@link loop} during each iteration.\n     *\n     * @param i - The current iteration index.\n     */\n    (i: number): ThreadGenerator | void;\n}\n/**\n * Run the given generator in a loop.\n *\n * @remarks\n * Each iteration waits until the previous one is completed.\n * Because this loop never finishes it cannot be used in the main thread.\n * Instead, use `yield` or {@link threading.spawn} to run the loop concurrently.\n *\n * @example\n * Rotate the `rect` indefinitely:\n * ```ts\n * yield loop(\n *   () => rect.rotation(0).rotation(360, 2, linear),\n * );\n * ```\n *\n * @param factory - A function creating the generator to run. Because generators\n *                  can't be reset, a new generator is created on each\n *                  iteration.\n */\nexport declare function loop(factory: LoopCallback): ThreadGenerator;\n/**\n * Run the given generator N times.\n *\n * @remarks\n * Each iteration waits until the previous one is completed.\n *\n * @example\n * ```ts\n * const colors = [\n *   '#ff6470',\n *   '#ffc66d',\n *   '#68abdf',\n *   '#99c47a',\n * ];\n *\n * yield* loop(\n *   colors.length,\n *   i => rect.fill(colors[i], 2),\n * );\n * ```\n *\n * @param iterations - The number of iterations.\n * @param factory - A function creating the generator to run. Because generators\n *                  can't be reset, a new generator is created on each\n *                  iteration.\n */\nexport declare function loop(iterations: number, factory: LoopCallback): ThreadGenerator;\n//# sourceMappingURL=loop.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/flow/loopFor.d.ts", content: "import { ThreadGenerator } from '../threading';\nimport { LoopCallback } from './loop';\n/**\n * Run a generator in a loop for the given amount of time.\n *\n * @remarks\n * Generators are executed completely before the next iteration starts.\n * An iteration is allowed to finish even when the time is up. This means that\n * the actual duration of the loop may be longer than the given duration.\n *\n * @example\n * ```ts\n * yield* loopFor(\n *   3,\n *   () => circle().position.x(-10, 0.1).to(10, 0.1)\n * );\n * ```\n *\n * @param seconds - The duration in seconds.\n * @param factory - A function creating the generator to run. Because generators\n *                  can't be reset, a new generator is created on each\n *                  iteration.\n */\nexport declare function loopFor(seconds: number, factory: LoopCallback): ThreadGenerator;\n//# sourceMappingURL=loopFor.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/flow/loopUntil.d.ts", content: "import { ThreadGenerator } from '../threading';\nimport { LoopCallback } from './loop';\n/**\n * Run a generator in a loop until the given time event.\n *\n * @remarks\n * Generators are executed completely before the next iteration starts.\n * An iteration is allowed to finish even when the time is up. This means that\n * the actual duration of the loop may be longer than the given duration.\n *\n * @example\n * ```ts\n * yield* loopUntil(\n *   'Stop Looping',\n *   () => circle().position.x(-10, 0.1).to(10, 0.1)\n * );\n * ```\n *\n * @param event - The event.\n * @param factory - A function creating the generator to run. Because generators\n *                  can't be reset, a new generator is created on each\n *                  iteration.\n */\nexport declare function loopUntil(event: string, factory: LoopCallback): ThreadGenerator;\n//# sourceMappingURL=loopUntil.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/flow/noop.d.ts", content: "import { ThreadGenerator } from '../threading';\n/**\n * Do nothing.\n */\nexport declare function noop(): ThreadGenerator;\n//# sourceMappingURL=noop.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/flow/run.d.ts", content: "import { ThreadGenerator } from '../threading';\n/**\n * Turn the given generator function into a task.\n *\n * @remarks\n * If you want to immediately run the generator in its own thread, you can use\n * {@link threading.spawn} instead. This function is useful when you want to\n * pass the created task to other flow functions.\n *\n * @example\n * ```ts\n * yield* all(\n *   run(function* () {\n *     // do things\n *   }),\n *   rect.opacity(1, 1),\n * );\n * ```\n *\n * @param runner - A generator function or a factory that creates the generator.\n */\nexport declare function run(runner: () => ThreadGenerator): ThreadGenerator;\n/**\n * Turn the given generator function into a task.\n *\n * @remarks\n * If you want to immediately run the generator in its own thread, you can use\n * {@link threading.spawn} instead. This function is useful when you want to\n * pass the created task to other flow functions.\n *\n * @example\n * ```ts\n * yield* all(\n *   run(function* () {\n *     // do things\n *   }),\n *   rect.opacity(1, 1),\n * );\n * ```\n *\n * @param runner - A generator function or a factory that creates the generator.\n * @param name - An optional name used when displaying this generator in the UI.\n */\nexport declare function run(name: string, runner: () => ThreadGenerator): ThreadGenerator;\n//# sourceMappingURL=run.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/flow/scheduling.d.ts", content: "import { ThreadGenerator } from '../threading';\n/**\n * Wait until the given time event.\n *\n * @remarks\n * Time events are displayed on the timeline and can be edited to adjust the\n * delay. By default, an event happens immediately - without any delay.\n *\n * @example\n * ```ts\n * yield waitUntil('event');\n * ```\n *\n * @param event - The name of the time event.\n * @param after - An optional task to be run after the function completes.\n */\nexport declare function waitUntil(event: string, after?: ThreadGenerator): ThreadGenerator;\n/**\n * Wait for the given amount of time.\n *\n * @example\n * ```ts\n * // current time: 0s\n * yield waitFor(2);\n * // current time: 2s\n * yield waitFor(3);\n * // current time: 5s\n * ```\n *\n * @param seconds - The relative time in seconds.\n * @param after - An optional task to be run after the function completes.\n */\nexport declare function waitFor(seconds?: number, after?: ThreadGenerator): ThreadGenerator;\n//# sourceMappingURL=scheduling.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/flow/sequence.d.ts", content: "import { ThreadGenerator } from '../threading';\n/**\n * Start all tasks one after another with a constant delay between.\n *\n * @remarks\n * The function doesn't wait until the previous task in the sequence has\n * finished. Once the delay has passed, the next task will start even if\n * the previous is still running.\n *\n * @example\n * ```ts\n * yield* sequence(\n *   0.1,\n *   ...rects.map(rect => rect.x(100, 1))\n * );\n * ```\n *\n * @param delay - The delay between each of the tasks.\n * @param tasks - A list of tasks to be run in a sequence.\n */\nexport declare function sequence(delay: number, ...tasks: ThreadGenerator[]): ThreadGenerator;\n//# sourceMappingURL=sequence.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/index.d.ts", content: "export * from './meta';\nexport * from './app';\nexport * from './decorators';\nexport * from './events';\nexport * from './flow';\nexport * from './media';\nexport * from './plugin';\nexport { default as DefaultPlugin } from './plugin/DefaultPlugin';\nexport * from './scenes';\nexport * from './signals';\nexport * from './threading';\nexport * from './transitions';\nexport * from './tweening';\nexport * from './types';\nexport * from './utils';\n//# sourceMappingURL=index.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/media/AudioData.d.ts", content: "export interface AudioData {\n    /**\n     * An array of minimum and maximum waveform data points, interleaved.\n     * Each value is in range of -1 to 1.\n     */\n    peaks: number[];\n    /**\n     * The amount of samples taken.\n     */\n    length: number;\n    /**\n     * The absolute biggest value from the peaks array.\n     */\n    absoluteMax: number;\n    /**\n     * Samples per seconds.\n     */\n    sampleRate: number;\n}\n//# sourceMappingURL=AudioData.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/media/AudioManager.d.ts", content: "import { Logger } from '../app';\nimport { AudioData } from './AudioData';\nexport declare class AudioManager {\n    private readonly logger;\n    get onDataChanged(): import(\"../events\").SubscribableValueEvent<AudioData | null>;\n    private readonly data;\n    private readonly context;\n    private readonly audioElement;\n    private source;\n    private error;\n    private abortController;\n    private offset;\n    constructor(logger: Logger);\n    getTime(): number;\n    setTime(value: number): void;\n    setOffset(value: number): void;\n    setMuted(isMuted: boolean): void;\n    setVolume(volume: number): void;\n    setSource(src: string): void;\n    isInRange(time: number): boolean;\n    toRelativeTime(time: number): number;\n    toAbsoluteTime(time: number): number;\n    isReady(): boolean | \"\" | null;\n    /**\n     * Pause/resume the audio.\n     *\n     * @param isPaused - Whether the audio should be paused or resumed.\n     *\n     * @returns `true` if the audio successfully started playing.\n     */\n    setPaused(isPaused: boolean): Promise<boolean>;\n    private loadData;\n    private decodeAudioData;\n}\n//# sourceMappingURL=AudioManager.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/media/index.d.ts", content: "/**\n * Multi-media management.\n *\n * @packageDocumentation\n */\nexport * from './AudioData';\nexport * from './AudioManager';\nexport * from './loadImage';\n//# sourceMappingURL=index.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/media/loadImage.d.ts", content: "export type ImageDataSource = CanvasImageSource & {\n    width: number;\n    height: number;\n};\nexport declare function loadImage(source: string): Promise<HTMLImageElement>;\nexport declare function loadAnimation(sources: string[]): Promise<HTMLImageElement[]>;\nexport declare function getImageData(image: ImageDataSource): ImageData;\n//# sourceMappingURL=loadImage.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/meta/BoolMetaField.d.ts", content: "import { MetaField } from './MetaField';\n/**\n * Represents a boolean value stored in a meta file.\n */\nexport declare class BoolMetaField extends MetaField<any, boolean> {\n    readonly type: BooleanConstructor;\n    parse(value: any): boolean;\n}\n//# sourceMappingURL=BoolMetaField.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/meta/ColorMetaField.d.ts", content: "import { Color, PossibleColor } from '../types';\nimport { MetaField } from './MetaField';\n/**\n * Represents a color stored in a meta file.\n */\nexport declare class ColorMetaField extends MetaField<PossibleColor | null, Color | null> {\n    readonly type: symbol;\n    parse(value: PossibleColor | null): Color | null;\n    serialize(): PossibleColor | null;\n}\n//# sourceMappingURL=ColorMetaField.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/meta/EnumMetaField.d.ts", content: "import { MetaField } from './MetaField';\nimport { MetaOption } from './MetaOption';\n/**\n * Represents an enum value stored in a meta file.\n */\nexport declare class EnumMetaField<T> extends MetaField<T> {\n    readonly options: MetaOption<T>[];\n    static readonly symbol: unique symbol;\n    readonly type: symbol;\n    constructor(name: string, options: MetaOption<T>[], initial?: T);\n    set(value: T): void;\n    parse(value: T): T;\n    getOption(value: T): MetaOption<T>;\n}\n//# sourceMappingURL=EnumMetaField.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/meta/ExporterMetaFile.d.ts", content: "import type { ExporterClass, Project } from '../app';\nimport { MetaField } from './MetaField';\n/**\n * Represents the exporter configuration.\n */\nexport declare class ExporterMetaField extends MetaField<{\n    name: string;\n    options: unknown;\n}> {\n    private current;\n    readonly type: ObjectConstructor;\n    /**\n     * Triggered when the nested fields change.\n     *\n     * @eventProperty\n     */\n    get onFieldsChanged(): import(\"../events\").SubscribableValueEvent<MetaField<any, any>[]>;\n    private readonly fields;\n    get options(): MetaField<any> | undefined;\n    private readonly exporterField;\n    private readonly optionFields;\n    readonly exporters: ExporterClass[];\n    constructor(name: string, project: Project, current?: number);\n    set(value: {\n        name: string;\n        options: any;\n    }): void;\n    serialize(): {\n        name: string;\n        options: any;\n    };\n    clone(): this;\n    private handleChange;\n}\n//# sourceMappingURL=ExporterMetaFile.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/meta/MetaField.d.ts", content: "import { ValueDispatcher } from '../events';\n/**\n * Represents an entry in the meta file.\n *\n * @typeParam TSerializedValue - The type used to store this field in the meta\n *                               file.\n * @typeParam TValue - The runtime type of this field.\n */\nexport declare class MetaField<TSerializedValue, TValue extends TSerializedValue = TSerializedValue> {\n    readonly name: string;\n    readonly initial: TValue;\n    /**\n     * The type of this field used by the editor to display the correct input.\n     */\n    readonly type: any;\n    spacing: boolean;\n    description: string;\n    /**\n     * Triggered when the data of this field changes.\n     *\n     * @eventProperty\n     */\n    get onChanged(): import(\"../events\").SubscribableValueEvent<TValue>;\n    protected readonly value: ValueDispatcher<TValue>;\n    /**\n     * Triggered when the field becomes disabled or enabled.\n     *\n     * @eventProperty\n     */\n    get onDisabled(): import(\"../events\").SubscribableValueEvent<boolean>;\n    protected readonly disabled: ValueDispatcher<boolean>;\n    /**\n     * @param name - The name of this field displayed in the editor.\n     * @param initial - The initial value of this field.\n     */\n    constructor(name: string, initial: TValue);\n    /**\n     * Get the current value.\n     */\n    get(): TValue;\n    /**\n     * Set the current value.\n     *\n     * @param value - The new value.\n     */\n    set(value: TSerializedValue): void;\n    /**\n     * Convert a serialized value into a runtime type.\n     *\n     * @param value - The serialized value.\n     */\n    parse(value: TSerializedValue): TValue;\n    /**\n     * Serialize the value of this field.\n     */\n    serialize(): TSerializedValue;\n    /**\n     * Create a clone of this field.\n     */\n    clone(): this;\n    /**\n     * Disable or enable the field in the editor.\n     *\n     * @param value - Whether the field should be disabled.\n     */\n    disable(value?: boolean): this;\n    /**\n     * Add or remove spacing at the beginning of this field.\n     *\n     * @param value - Whether to include the spacing.\n     */\n    space(value?: boolean): this;\n    /**\n     * Set the description of this field.\n     *\n     * @param description - The description.\n     */\n    describe(description: string): this;\n}\n//# sourceMappingURL=MetaField.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/meta/MetaFile.d.ts", content: "import type { MetaField } from './MetaField';\n/**\n * Represents the meta file of a given entity.\n *\n * @remarks\n * This class is used exclusively by our Vite plugin as a bridge between\n * physical files and their runtime representation.\n *\n * @typeParam T - The type of the data stored in the meta file.\n *\n * @internal\n */\nexport declare class MetaFile<T> {\n    private readonly name;\n    private source;\n    private readonly lock;\n    private ignoreChange;\n    private cache;\n    private metaField;\n    constructor(name: string, source?: string | false);\n    attach(field: MetaField<T>): void;\n    protected handleChanged: () => Promise<void>;\n    private saveData;\n    /**\n     * Load new metadata from a file.\n     *\n     * @remarks\n     * This method is called during hot module replacement.\n     *\n     * @param data - New metadata.\n     */\n    loadData(data: T): void;\n    private static sourceLookup;\n}\n//# sourceMappingURL=MetaFile.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/meta/MetaOption.d.ts", content: "export interface MetaOption<T> {\n    text: string;\n    value: T;\n}\n//# sourceMappingURL=MetaOption.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/meta/NumberMetaField.d.ts", content: "import { MetaField } from './MetaField';\nimport { MetaOption } from './MetaOption';\n/**\n * Represents a number stored in a meta file.\n */\nexport declare class NumberMetaField extends MetaField<any, number> {\n    readonly type: NumberConstructor;\n    protected presets: MetaOption<number>[];\n    protected min?: number;\n    protected max?: number;\n    parse(value: any): number;\n    getPresets(): MetaOption<number>[];\n    setPresets(options: MetaOption<number>[]): this;\n    setRange(min?: number, max?: number): this;\n    getMin(): number;\n    getMax(): number;\n}\n//# sourceMappingURL=NumberMetaField.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/meta/ObjectMetaField.d.ts", content: "import { ValueDispatcher } from '../events';\nimport { MetaField } from './MetaField';\nexport type ValueOf<T extends Record<string, any>> = {\n    [K in keyof T]: T[K] extends MetaField<any, infer P> ? P : never;\n};\ntype TransformationOf<TObject extends Record<string, any>, TKey extends CallableKeys<MetaField<any>>> = {\n    [K in keyof TObject]: TObject[K] extends MetaField<infer A, infer B> ? ReturnType<MetaField<A, B>[TKey]> : never;\n};\ntype CallableKeys<T> = {\n    [K in keyof T]: T[K] extends () => void ? K : never;\n}[keyof T];\ndeclare class ObjectMetaFieldInternal<T extends Record<string, MetaField<any>>> extends MetaField<ValueOf<T>> {\n    readonly type: ObjectConstructor;\n    /**\n     * Triggered when the nested fields change.\n     *\n     * @eventProperty\n     */\n    get onFieldsChanged(): import(\"../events\").SubscribableValueEvent<MetaField<unknown, unknown>[]>;\n    protected ignoreChange: boolean;\n    protected customFields: Record<string, unknown>;\n    protected readonly fields: Map<string, MetaField<unknown>>;\n    protected readonly event: ValueDispatcher<MetaField<unknown>[]>;\n    constructor(name: string, fields: T);\n    set(value: Partial<ValueOf<T>>): void;\n    serialize(): ValueOf<T>;\n    clone(): this;\n    protected handleChange: () => void;\n    protected transform<TKey extends CallableKeys<MetaField<any>>>(fn: TKey): TransformationOf<T, TKey>;\n}\n/**\n * Represents an object with nested meta-fields.\n */\nexport type ObjectMetaField<T extends Record<string, MetaField<any>>> = ObjectMetaFieldInternal<T> & T;\n/**\n * Represents an object with nested meta-fields.\n */\nexport declare const ObjectMetaField: new <T extends Record<string, MetaField<any, any>>>(name: string, data: T) => ObjectMetaField<T>;\nexport {};\n//# sourceMappingURL=ObjectMetaField.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/meta/RangeMetaField.d.ts", content: "import { MetaField } from './MetaField';\n/**\n * Represents a range stored in a meta file.\n *\n * @remarks\n * Range is an array with two elements denoting the beginning and end of a\n * range, respectively.\n */\nexport declare class RangeMetaField extends MetaField<[\n    number,\n    number | null\n], [\n    number,\n    number\n]> {\n    static readonly symbol: unique symbol;\n    readonly type: symbol;\n    parse(value: [number, number | null]): [number, number];\n    /**\n     * Convert the given range from frames to seconds and update this field.\n     *\n     * @remarks\n     * This helper method applies additional validation to the range, preventing\n     * it from overflowing the timeline.\n     *\n     * @param startFrame - The beginning of the range.\n     * @param endFrame - The end of the range.\n     * @param duration - The current duration in frames.\n     * @param fps - The current framerate.\n     */\n    update(startFrame: number, endFrame: number, duration: number, fps: number): void;\n    protected parseRange(duration: number, startFrame?: number, endFrame?: number): [number, number];\n}\n//# sourceMappingURL=RangeMetaField.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/meta/StringMetaField.d.ts", content: "import { MetaField } from './MetaField';\nimport { MetaOption } from './MetaOption';\n/**\n * Represents a string stored in a meta file.\n */\nexport declare class StringMetaField<T extends string = string> extends MetaField<T> {\n    readonly type: StringConstructor;\n    protected presets: MetaOption<T>[];\n    getPresets(): MetaOption<T>[];\n    setPresets(options: MetaOption<T>[]): this;\n}\n//# sourceMappingURL=StringMetaField.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/meta/Vector2MetaField.d.ts", content: "import { PossibleVector2, Vector2 } from '../types';\nimport { MetaField } from './MetaField';\n/**\n * Represents a two-dimensional vector stored in a meta file.\n */\nexport declare class Vector2MetaField extends MetaField<PossibleVector2, Vector2> {\n    readonly type: symbol;\n    parse(value: PossibleVector2): Vector2;\n    serialize(): PossibleVector2;\n}\n//# sourceMappingURL=Vector2MetaField.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/meta/index.d.ts", content: "/**\n * The runtime representation of meta files.\n *\n * @packageDocumentation\n */\nexport * from './MetaField';\nexport * from './ObjectMetaField';\nexport * from './BoolMetaField';\nexport * from './ColorMetaField';\nexport * from './EnumMetaField';\nexport * from './ExporterMetaFile';\nexport * from './MetaFile';\nexport * from './MetaOption';\nexport * from './NumberMetaField';\nexport * from './RangeMetaField';\nexport * from './StringMetaField';\nexport * from './Vector2MetaField';\n//# sourceMappingURL=index.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/plugin/DefaultPlugin.d.ts", content: "/**\n * The default plugin included in every Motion Canvas project.\n *\n * @internal\n */\ndeclare const _default: () => import(\"./Plugin\").Plugin;\nexport default _default;\n//# sourceMappingURL=DefaultPlugin.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/plugin/Plugin.d.ts", content: "import type { ExporterClass, Player, Presenter, Project, ProjectSettings, Renderer } from '../app';\n/**\n * Represents a runtime Motion Canvas plugin.\n */\nexport interface Plugin {\n    /**\n     * A unique name of the plugin.\n     *\n     * @remarks\n     * The name should be unique across the entire ecosystem of Motion Canvas.\n     * If a plugin with the same name has already been registered, this plugin\n     * will be ignored.\n     *\n     * If you intend to publish your plugin to npm, it is recommended to prefix\n     * this name with the name of your npm package.\n     *\n     * Other identifiers defined by the plugin, such as a tab id, will be\n     * automatically prefixed with this name and as such don't have to be unique.\n     */\n    name: string;\n    /**\n     * Modify the project settings before the project is initialized.\n     *\n     * @param settings - The project settings.\n     */\n    settings?(settings: ProjectSettings): ProjectSettings | void;\n    /**\n     * Receive the project instance right after it is initialized.\n     *\n     * @param project - The project instance.\n     */\n    project?(project: Project): void;\n    /**\n     * Receive the player instance right after it is initialized.\n     *\n     * @param player - The player instance.\n     */\n    player?(player: Player): void;\n    /**\n     * Receive the presenter instance right after it is initialized.\n     *\n     * @param presenter - The presenter instance.\n     */\n    presenter?(presenter: Presenter): void;\n    /**\n     * Receive the renderer instance right after it is initialized.\n     *\n     * @param renderer - The renderer instance.\n     */\n    renderer?(renderer: Renderer): void;\n    /**\n     * Provide custom exporters for the project.\n     *\n     * @param project - The project instance.\n     */\n    exporters?(project: Project): ExporterClass[];\n}\n//# sourceMappingURL=Plugin.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/plugin/index.d.ts", content: "export * from './Plugin';\nexport * from './makePlugin';\n//# sourceMappingURL=index.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/plugin/makePlugin.d.ts", content: "import type { Plugin } from './Plugin';\n/**\n * A helper function for exporting Motion Canvas plugins.\n *\n * @param plugin - The plugin configuration.\n *\n * @example\n * ```ts\n * export default makePlugin({\n *   name: 'my-custom-plugin',\n * });\n * ```\n */\nexport declare function makePlugin(plugin: Plugin | (() => Plugin)): () => Plugin;\n//# sourceMappingURL=makePlugin.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/scenes/GeneratorScene.d.ts", content: "import { Logger, PlaybackStatus } from '../app';\nimport { EventDispatcher } from '../events';\nimport { SignalValue } from '../signals';\nimport { Thread, ThreadGenerator } from '../threading';\nimport { Vector2 } from '../types';\nimport { LifecycleEvents } from './LifecycleEvents';\nimport { Random } from './Random';\nimport { CachedSceneData, FullSceneDescription, Scene, SceneDescriptionReload, SceneRenderEvent } from './Scene';\nimport { SceneMetadata } from './SceneMetadata';\nimport { Shaders } from './Shaders';\nimport { Slides } from './Slides';\nimport { Threadable } from './Threadable';\nimport { Variables } from './Variables';\nimport { TimeEvents } from './timeEvents';\nexport interface ThreadGeneratorFactory<T> {\n    (view: T): ThreadGenerator;\n}\n/**\n * The default implementation of the {@link Scene} interface.\n *\n * Uses generators to control the animation.\n */\nexport declare abstract class GeneratorScene<T> implements Scene<ThreadGeneratorFactory<T>>, Threadable {\n    readonly name: string;\n    readonly playback: PlaybackStatus;\n    readonly logger: Logger;\n    readonly meta: SceneMetadata;\n    readonly timeEvents: TimeEvents;\n    readonly shaders: Shaders;\n    readonly slides: Slides;\n    readonly variables: Variables;\n    random: Random;\n    creationStack?: string;\n    previousOnTop: SignalValue<boolean>;\n    get firstFrame(): number;\n    get lastFrame(): number;\n    get onCacheChanged(): import(\"../events\").SubscribableValueEvent<CachedSceneData>;\n    private readonly cache;\n    get onReloaded(): import(\"../events\").Subscribable<void, import(\"../events\").EventHandler<void>>;\n    private readonly reloaded;\n    get onRecalculated(): import(\"../events\").Subscribable<void, import(\"../events\").EventHandler<void>>;\n    private readonly recalculated;\n    get onThreadChanged(): import(\"../events\").SubscribableValueEvent<Thread | null>;\n    private readonly thread;\n    get onRenderLifecycle(): import(\"../events\").Subscribable<[SceneRenderEvent, CanvasRenderingContext2D], import(\"../events\").EventHandler<[SceneRenderEvent, CanvasRenderingContext2D]>>;\n    protected readonly renderLifecycle: EventDispatcher<[SceneRenderEvent, CanvasRenderingContext2D]>;\n    get onReset(): import(\"../events\").Subscribable<void, import(\"../events\").EventHandler<void>>;\n    private readonly afterReset;\n    readonly lifecycleEvents: LifecycleEvents;\n    get LifecycleEvents(): LifecycleEvents;\n    get previous(): Scene<unknown> | null;\n    readonly experimentalFeatures: boolean;\n    protected resolutionScale: number;\n    private runnerFactory;\n    private previousScene;\n    private runner;\n    private state;\n    private cached;\n    private counters;\n    private size;\n    constructor(description: FullSceneDescription<ThreadGeneratorFactory<T>>);\n    abstract getView(): T;\n    /**\n     * Update the view.\n     *\n     * Invoked after each step of the main generator.\n     * Can be used for calculating layout.\n     *\n     * Can modify the state of the view.\n     */\n    update(): void;\n    render(context: CanvasRenderingContext2D): Promise<void>;\n    protected abstract draw(context: CanvasRenderingContext2D): void;\n    reload({ config, size, stack, resolutionScale, }?: SceneDescriptionReload<ThreadGeneratorFactory<T>>): void;\n    recalculate(setFrame: (frame: number) => void): Promise<void>;\n    next(): Promise<void>;\n    reset(previousScene?: Scene | null): Promise<void>;\n    getSize(): Vector2;\n    getRealSize(): Vector2;\n    isAfterTransitionIn(): boolean;\n    canTransitionOut(): boolean;\n    isFinished(): boolean;\n    enterInitial(): void;\n    enterAfterTransitionIn(): void;\n    enterCanTransitionOut(): void;\n    isCached(): boolean;\n    /**\n     * Invoke the given callback in the context of this scene.\n     *\n     * @remarks\n     * This method makes sure that the context of this scene is globally available\n     * during the execution of the callback.\n     *\n     * @param callback - The callback to invoke.\n     */\n    protected execute<T>(callback: () => T): T;\n}\n//# sourceMappingURL=GeneratorScene.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/scenes/Inspectable.d.ts", content: "import { Vector2 } from '../types/Vector';\n/**\n * Represents an element to inspect.\n *\n * @remarks\n * The type is not important because the UI does not interact with it.\n * It serves as a key that will be passed back to an Inspectable scene to\n * receive more information about said element.\n */\nexport type InspectedElement = unknown;\n/**\n * Represents attributes of an inspected element.\n */\nexport type InspectedAttributes = {\n    stack?: string;\n    [K: string]: any;\n};\n/**\n * Scenes can implement this interface to make their components\n * inspectable through the UI.\n */\nexport interface Inspectable {\n    /**\n     * Get a possible element to inspect at a given position.\n     *\n     * @param x - The x coordinate.\n     * @param y - The y coordinate.\n     */\n    inspectPosition(x: number, y: number): InspectedElement | null;\n    /**\n     * Check if the inspected element is still valid.\n     *\n     * @remarks\n     * If a scene destroys and recreates its components upon every reset, the\n     * reference may no longer be valid. Even though the component is still\n     * present. This method should check that and return a new reference.\n     *\n     * @param element - The element to validate.\n     */\n    validateInspection(element: InspectedElement | null): InspectedElement | null;\n    /**\n     * Return the attributes of the inspected element.\n     *\n     * @remarks\n     * This information will be displayed in the \"Properties\" panel.\n     *\n     * @param element - The element to inspect.\n     */\n    inspectAttributes(element: InspectedElement): InspectedAttributes | null;\n    /**\n     * Draw an overlay for the inspected element.\n     *\n     * @remarks\n     * This method can be used to overlay additional information about an\n     * element on top of the animation.\n     *\n     * @param element - The element for which to draw an overlay.\n     * @param matrix - A local-to-screen matrix.\n     * @param context - The context to draw with.\n     */\n    drawOverlay(element: InspectedElement, matrix: DOMMatrix, context: CanvasRenderingContext2D): void;\n    /**\n     * Transform the absolute mouse coordinates into the scene's coordinate system.\n     *\n     * @param x - The x coordinate.\n     * @param y - The y coordinate.\n     */\n    transformMousePosition(x: number, y: number): Vector2 | null;\n}\nexport declare function isInspectable(value: any): value is Inspectable;\n//# sourceMappingURL=Inspectable.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/scenes/LifecycleEvents.d.ts", content: "import { EventDispatcher } from '../events';\nimport { Scene } from './Scene';\n/**\n * Lifecycle events for {@link Scene} that are cleared on every reset.\n */\nexport declare class LifecycleEvents {\n    private readonly scene;\n    get onBeforeRender(): import(\"../events\").Subscribable<CanvasRenderingContext2D, import(\"../events\").EventHandler<CanvasRenderingContext2D>>;\n    protected readonly beforeRender: EventDispatcher<CanvasRenderingContext2D>;\n    get onBeginRender(): import(\"../events\").Subscribable<CanvasRenderingContext2D, import(\"../events\").EventHandler<CanvasRenderingContext2D>>;\n    protected readonly beginRender: EventDispatcher<CanvasRenderingContext2D>;\n    get onFinishRender(): import(\"../events\").Subscribable<CanvasRenderingContext2D, import(\"../events\").EventHandler<CanvasRenderingContext2D>>;\n    protected readonly finishRender: EventDispatcher<CanvasRenderingContext2D>;\n    get onAfterRender(): import(\"../events\").Subscribable<CanvasRenderingContext2D, import(\"../events\").EventHandler<CanvasRenderingContext2D>>;\n    protected readonly afterRender: EventDispatcher<CanvasRenderingContext2D>;\n    constructor(scene: Scene);\n}\n//# sourceMappingURL=LifecycleEvents.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/scenes/Random.d.ts", content: "/**\n * A random number generator based on\n * {@link https://gist.github.com/tommyettinger/46a874533244883189143505d203312c | Mulberry32}.\n */\nexport declare class Random {\n    private state;\n    /**\n     * Previously generated Gaussian random number.\n     *\n     * @remarks\n     * This is an optimization.\n     * Since {@link gauss} generates a pair of independent Gaussian random\n     * numbers, it returns one immediately and stores the other for the next call\n     * to {@link gauss}.\n     */\n    private nextGauss;\n    constructor(state: number);\n    /**\n     * @internal\n     */\n    static createSeed(): number;\n    /**\n     * Get the next random float in the given range.\n     *\n     * @param from - The start of the range.\n     * @param to - The end of the range.\n     */\n    nextFloat(from?: number, to?: number): number;\n    /**\n     * Get the next random integer in the given range.\n     *\n     * @param from - The start of the range.\n     * @param to - The end of the range. Exclusive.\n     */\n    nextInt(from?: number, to?: number): number;\n    /**\n     * Get a random float from a gaussian distribution.\n     * @param mean - The mean of the distribution.\n     * @param stdev - The standard deviation of the distribution.\n     */\n    gauss(mean?: number, stdev?: number): number;\n    /**\n     * Get an array filled with random floats in the given range.\n     *\n     * @param size - The size of the array.\n     * @param from - The start of the range.\n     * @param to - The end of the range.\n     */\n    floatArray(size: number, from?: number, to?: number): number[];\n    /**\n     Get an array filled with random integers in the given range.\n     *\n     * @param size - The size of the array.\n     * @param from - The start of the range.\n     * @param to - The end of the range. Exclusive.\n     */\n    intArray(size: number, from?: number, to?: number): number[];\n    /**\n     * Create a new independent generator.\n     */\n    spawn(): Random;\n    private next;\n}\n//# sourceMappingURL=Random.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/scenes/Scene.d.ts", content: "import type { Logger, PlaybackStatus, SharedWebGLContext } from '../app';\nimport type { SubscribableEvent, SubscribableValueEvent, ValueDispatcher } from '../events';\nimport type { Plugin } from '../plugin';\nimport type { SignalValue } from '../signals';\nimport type { Vector2 } from '../types';\nimport type { LifecycleEvents } from './LifecycleEvents';\nimport type { Random } from './Random';\nimport type { SceneMetadata } from './SceneMetadata';\nimport type { Shaders } from './Shaders';\nimport type { Slides } from './Slides';\nimport type { Variables } from './Variables';\nimport type { TimeEvents } from './timeEvents';\n/**\n * The constructor used when creating new scenes.\n *\n * @remarks\n * Each class implementing the {@link Scene} interface should have a matching\n * constructor.\n *\n * @typeParam T - The type of the configuration object. This object will be\n *                passed to the constructor from\n *                {@link SceneDescription.config}.\n */\nexport interface SceneConstructor<T> {\n    new (description: FullSceneDescription<T>): Scene;\n}\n/**\n * Describes a scene exposed by scene files.\n *\n * @typeParam T - The type of the configuration object.\n */\nexport interface SceneDescription<T = unknown> {\n    /**\n     * The class used to instantiate the scene.\n     */\n    klass: SceneConstructor<T>;\n    /**\n     * Configuration object.\n     */\n    config: T;\n    /**\n     * The stack trace at the moment of creation.\n     */\n    stack?: string;\n    /**\n     * A list of plugins to include in the project.\n     */\n    plugins?: (Plugin | string)[];\n    meta: SceneMetadata;\n}\n/**\n * Describes a complete scene together with the meta file.\n *\n * @typeParam T - The type of the configuration object.\n */\nexport interface FullSceneDescription<T = unknown> extends SceneDescription<T> {\n    name: string;\n    size: Vector2;\n    resolutionScale: number;\n    variables: Variables;\n    playback: PlaybackStatus;\n    logger: Logger;\n    onReplaced: ValueDispatcher<FullSceneDescription<T>>;\n    timeEventsClass: new (scene: Scene) => TimeEvents;\n    sharedWebGLContext: SharedWebGLContext;\n    experimentalFeatures?: boolean;\n}\n/**\n * A part of the {@link SceneDescription} that can be updated during reload.\n *\n * @typeParam T - The type of the configuration object.\n */\nexport interface SceneDescriptionReload<T = unknown> {\n    size?: Vector2;\n    resolutionScale?: number;\n    config?: T;\n    stack?: string;\n}\nexport type DescriptionOf<TScene> = TScene extends Scene<infer TConfig> ? SceneDescription<TConfig> : never;\n/**\n * Describes cached information about the timing of a scene.\n */\nexport interface CachedSceneData {\n    firstFrame: number;\n    lastFrame: number;\n    transitionDuration: number;\n    duration: number;\n}\n/**\n * Signifies the various stages of a {@link Scene}'s render lifecycle.\n */\nexport declare enum SceneRenderEvent {\n    /**\n     * Occurs before the render starts when the Scene transitions are applied.\n     */\n    BeforeRender = 0,\n    /**\n     * Occurs at the beginning of a render when the Scene's\n     * {@link utils.useContext} handlers are applied.\n     */\n    BeginRender = 1,\n    /**\n     * Occurs at the end of a render when the Scene's\n     * {@link utils.useContextAfter} handlers are applied.\n     */\n    FinishRender = 2,\n    /**\n     * Occurs after a render ends.\n     */\n    AfterRender = 3\n}\n/**\n * The main interface for scenes.\n *\n * @remarks\n * Any class implementing this interface should have a constructor matching\n * {@link SceneConstructor}.\n *\n * @typeParam T - The type of the configuration object.\n */\nexport interface Scene<T = unknown> {\n    /**\n     * Name of the scene.\n     *\n     * @remarks\n     * Will be passed as the second argument to the constructor.\n     */\n    readonly name: string;\n    /**\n     * Reference to the project.\n     */\n    readonly playback: PlaybackStatus;\n    readonly timeEvents: TimeEvents;\n    /**\n     * @experimental\n     */\n    readonly shaders: Shaders;\n    readonly slides: Slides;\n    readonly logger: Logger;\n    readonly variables: Variables;\n    readonly random: Random;\n    readonly meta: SceneMetadata;\n    creationStack?: string;\n    /**\n     * The frame at which this scene starts.\n     */\n    get firstFrame(): number;\n    /**\n     * The frame at which this scene ends.\n     */\n    get lastFrame(): number;\n    /**\n     * Triggered when the cached data changes.\n     *\n     * @eventProperty\n     */\n    get onCacheChanged(): SubscribableValueEvent<CachedSceneData>;\n    /**\n     * Triggered when the scene is reloaded.\n     *\n     * @eventProperty\n     */\n    get onReloaded(): SubscribableEvent<void>;\n    /**\n     * Triggered after scene is recalculated.\n     *\n     * @eventProperty\n     */\n    get onRecalculated(): SubscribableEvent<void>;\n    /**\n     * The {@link scenes.LifecycleEvents} of this scene.\n     */\n    get lifecycleEvents(): LifecycleEvents;\n    /**\n     * The {@link scenes.LifecycleEvents} of this scene.\n     *\n     * @deprecated Use {@link lifecycleEvents} instead.\n     */\n    get LifecycleEvents(): LifecycleEvents;\n    /**\n     * Triggered at various stages of the render lifecycle with an event title and a Context2D.\n     *\n     * @eventProperty\n     */\n    get onRenderLifecycle(): SubscribableEvent<[\n        SceneRenderEvent,\n        CanvasRenderingContext2D\n    ]>;\n    /**\n     * Triggered when the scene is reset.\n     *\n     * @eventProperty\n     */\n    get onReset(): SubscribableEvent<void>;\n    /**\n     * The scene directly before this scene, or null if omitted for performance.\n     */\n    get previous(): Scene | null;\n    /**\n     * Whether experimental features are enabled.\n     */\n    get experimentalFeatures(): boolean;\n    /**\n     * Render the scene onto a canvas.\n     *\n     * @param context - The context to used when rendering.\n     */\n    render(context: CanvasRenderingContext2D): Promise<void>;\n    /**\n     * Reload the scene.\n     *\n     * @remarks\n     * This method is called whenever something related to this scene has changed:\n     * time events, source code, metadata, etc.\n     *\n     * Should trigger {@link onReloaded}.\n     *\n     * @param description - If present, an updated version of the description.\n     */\n    reload(description?: SceneDescriptionReload<T>): void;\n    /**\n     * Recalculate the scene.\n     *\n     * @remarks\n     * The task of this method is to calculate new timings stored in the cache.\n     * When this method is invoked, `this.project.frame` is set to the frame at\n     * which this scene should start ({@link firstFrame}).\n     *\n     * At the end of execution, this method should set `this.project.frame` to the\n     * frame at which this scene ends ({@link lastFrame}).\n     *\n     * Should trigger {@link onRecalculated}.\n     */\n    recalculate(setFrame: (frame: number) => void): Promise<void>;\n    /**\n     * Progress this scene one frame forward.\n     */\n    next(): Promise<void>;\n    /**\n     * Reset this scene to its initial state.\n     *\n     * @param previous - If present, the previous scene.\n     */\n    reset(previous?: Scene): Promise<void>;\n    /**\n     * Get the size of this scene.\n     *\n     * @remarks\n     * Usually returns `this.project.getSize()`.\n     */\n    getSize(): Vector2;\n    /**\n     * Get the real size of this scene.\n     *\n     * @remarks\n     * Returns the size of the scene multiplied by the resolution scale.\n     * This is the actual size of the canvas onto which the scene is rendered.\n     */\n    getRealSize(): Vector2;\n    /**\n     * Is this scene in the {@link SceneState.AfterTransitionIn} state?\n     */\n    isAfterTransitionIn(): boolean;\n    /**\n     * Is this scene in the {@link SceneState.CanTransitionOut} state?\n     */\n    canTransitionOut(): boolean;\n    /**\n     * Is this scene in the {@link SceneState.Finished} state?\n     */\n    isFinished(): boolean;\n    /**\n     * Enter the {@link SceneState.Initial} state.\n     */\n    enterInitial(): void;\n    /**\n     * Enter the {@link SceneState.AfterTransitionIn} state.\n     */\n    enterAfterTransitionIn(): void;\n    /**\n     * Enter the {@link SceneState.CanTransitionOut} state.\n     */\n    enterCanTransitionOut(): void;\n    /**\n     * Is this scene cached?\n     *\n     * @remarks\n     * Used only by {@link GeneratorScene}. Seeking through a project that\n     * contains at least one uncached scene will log a warning to the console.\n     *\n     * Should always return `true`.\n     */\n    isCached(): boolean;\n    /**\n     * Should this scene be rendered below the previous scene during a transition?\n     */\n    previousOnTop: SignalValue<boolean>;\n}\n//# sourceMappingURL=Scene.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/scenes/SceneMetadata.d.ts", content: "import { MetaField, ObjectMetaField } from '../meta';\nimport { SerializedTimeEvent } from './timeEvents';\n/**\n * Create a runtime representation of the scene metadata.\n */\nexport declare function createSceneMetadata(): ObjectMetaField<{\n    version: MetaField<any, number>;\n    timeEvents: MetaField<SerializedTimeEvent[], SerializedTimeEvent[]>;\n    seed: MetaField<any, number>;\n}>;\n/**\n * A runtime representation of the scene metadata.\n */\nexport type SceneMetadata = ReturnType<typeof createSceneMetadata>;\n//# sourceMappingURL=SceneMetadata.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/scenes/SceneState.d.ts", content: "/**\n * Describes the state of a scene.\n */\nexport declare enum SceneState {\n    /**\n     * The scene has just been created/reset.\n     */\n    Initial = 0,\n    /**\n     * The scene has finished transitioning in.\n     *\n     * @remarks\n     * Informs the Project that the previous scene is no longer necessary and can\n     * be disposed of.\n     */\n    AfterTransitionIn = 1,\n    /**\n     * The scene is ready to transition out.\n     *\n     * @remarks\n     * Informs the project that the next scene can begin.\n     * The {@link Scene.next} method will still be invoked until the next scene\n     * enters {@link AfterTransitionIn}.\n     */\n    CanTransitionOut = 2,\n    /**\n     * The scene has finished.\n     *\n     * @remarks\n     * Invoking {@link Scene.next} won't have any effect.\n     */\n    Finished = 3\n}\n//# sourceMappingURL=SceneState.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/scenes/Shaders.d.ts", content: "import { SharedWebGLContext, WebGLContextOwner } from '../app/SharedWebGLContext';\nimport { Scene } from './Scene';\n/**\n * @internal\n */\nexport declare const UNIFORM_RESOLUTION = \"resolution\";\n/**\n * @internal\n */\nexport declare const UNIFORM_DESTINATION_TEXTURE = \"destinationTexture\";\n/**\n * @internal\n */\nexport declare const UNIFORM_SOURCE_TEXTURE = \"sourceTexture\";\n/**\n * @internal\n */\nexport declare const UNIFORM_TIME = \"time\";\n/**\n * @internal\n */\nexport declare const UNIFORM_DELTA_TIME = \"deltaTime\";\n/**\n * @internal\n */\nexport declare const UNIFORM_FRAMERATE = \"framerate\";\n/**\n * @internal\n */\nexport declare const UNIFORM_FRAME = \"frame\";\n/**\n * @internal\n */\nexport declare const UNIFORM_SOURCE_MATRIX = \"sourceMatrix\";\n/**\n * @internal\n */\nexport declare const UNIFORM_DESTINATION_MATRIX = \"destinationMatrix\";\n/**\n * @internal\n */\nexport declare class Shaders implements WebGLContextOwner {\n    private readonly scene;\n    private readonly sharedContext;\n    private gl;\n    private positionBuffer;\n    private sourceTexture;\n    private destinationTexture;\n    private positionLocation;\n    private readonly quadPositions;\n    constructor(scene: Scene, sharedContext: SharedWebGLContext);\n    setup(gl: WebGL2RenderingContext): void;\n    teardown(gl: WebGL2RenderingContext): void;\n    private handleReload;\n    private updateViewport;\n    getGL(): WebGL2RenderingContext;\n    getProgram(fragment: string): WebGLProgram | null;\n    copyTextures(destination: TexImageSource, source: TexImageSource): void;\n    clear(): void;\n    render(): void;\n    private copyTexture;\n}\n//# sourceMappingURL=Shaders.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/scenes/Slides.d.ts", content: "import type { Scene } from './Scene';\nexport interface Slide {\n    id: string;\n    name: string;\n    time: number;\n    scene: Scene;\n    stack?: string;\n}\nexport declare class Slides {\n    private readonly scene;\n    get onChanged(): import(\"../events\").SubscribableValueEvent<Slide[]>;\n    private readonly slides;\n    private readonly lookup;\n    private readonly collisionLookup;\n    private current;\n    private canResume;\n    private waitsForId;\n    private targetId;\n    constructor(scene: Scene);\n    setTarget(target: string | null): void;\n    resume(): void;\n    isWaitingFor(slide: string): boolean;\n    isWaiting(): boolean;\n    didHappen(slide: string): boolean;\n    getCurrent(): Slide | null;\n    register(name: string, initialTime: number): void;\n    shouldWait(name: string): boolean;\n    private handleReload;\n    private handleReset;\n    private handleRecalculated;\n    private toId;\n}\n//# sourceMappingURL=Slides.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/scenes/Threadable.d.ts", content: "import { SubscribableValueEvent } from '../events';\nimport { Thread } from '../threading';\n/**\n * Scenes can implement this interface to display their thread hierarchy in the\n * UI.\n *\n * @remarks\n * This interface is only useful when a scene uses thread generators to run.\n */\nexport interface Threadable {\n    /**\n     * Triggered when the main thread changes.\n     *\n     * @eventProperty\n     */\n    get onThreadChanged(): SubscribableValueEvent<Thread | null>;\n}\nexport declare function isThreadable(value: any): value is Threadable;\n//# sourceMappingURL=Threadable.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/scenes/Variables.d.ts", content: "import type { Scene } from './Scene';\nexport declare class Variables {\n    private readonly scene;\n    private signals;\n    private variables;\n    constructor(scene: Scene);\n    /**\n     * Get variable signal if exists or create signal if not\n     *\n     * @param name - The name of the variable.\n     * @param initial - The initial value of the variable. It will be used if the\n     *                  variable was not configured from the outside.\n     */\n    get<T>(name: string, initial: T): () => T;\n    /**\n     * Update all signals with new project variable values.\n     */\n    updateSignals(variables: Record<string, unknown>): void;\n    /**\n     * Reset all stored signals.\n     */\n    handleReset: () => void;\n}\n//# sourceMappingURL=Variables.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/scenes/index.d.ts", content: "/**\n * Abstract scene representations and related utilities.\n *\n * @packageDocumentation\n */\nexport * from './GeneratorScene';\nexport * from './Inspectable';\nexport * from './LifecycleEvents';\nexport * from './Random';\nexport * from './Scene';\nexport * from './SceneMetadata';\nexport * from './SceneState';\nexport * from './Shaders';\nexport * from './Slides';\nexport * from './Threadable';\nexport * from './Variables';\n//# sourceMappingURL=index.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/scenes/timeEvents/EditableTimeEvents.d.ts", content: "import type { Scene } from '../Scene';\nimport type { TimeEvent } from './TimeEvent';\nimport type { TimeEvents } from './TimeEvents';\n/**\n * Manages time events during editing.\n */\nexport declare class EditableTimeEvents implements TimeEvents {\n    private readonly scene;\n    get onChanged(): import(\"../../events\").SubscribableValueEvent<TimeEvent[]>;\n    private readonly events;\n    private registeredEvents;\n    private lookup;\n    private collisionLookup;\n    private previousReference;\n    private didEventsChange;\n    private preserveTiming;\n    constructor(scene: Scene);\n    set(name: string, offset: number, preserve?: boolean): void;\n    register(name: string, initialTime: number): number;\n    /**\n     * Called when the parent scene gets reloaded.\n     */\n    private handleReload;\n    /**\n     * Called when the parent scene gets recalculated.\n     */\n    private handleRecalculated;\n    private handleReset;\n    /**\n     * Called when the meta of the parent scene changes.\n     */\n    private handleMetaChanged;\n    private load;\n}\n//# sourceMappingURL=EditableTimeEvents.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/scenes/timeEvents/ReadOnlyTimeEvents.d.ts", content: "import type { Scene } from '../Scene';\nimport type { TimeEvent } from './TimeEvent';\nimport type { TimeEvents } from './TimeEvents';\n/**\n * Manages time events during rendering and presentation.\n */\nexport declare class ReadOnlyTimeEvents implements TimeEvents {\n    private readonly scene;\n    get onChanged(): import(\"../../events\").SubscribableValueEvent<TimeEvent[]>;\n    private readonly events;\n    private lookup;\n    constructor(scene: Scene);\n    set(): void;\n    register(name: string, initialTime: number): number;\n    /**\n     * Called when the parent scene gets reloaded.\n     */\n    private handleReload;\n}\n//# sourceMappingURL=ReadOnlyTimeEvents.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/scenes/timeEvents/SerializedTimeEvent.d.ts", content: "/**\n * Represents a time event stored in a meta file.\n */\nexport interface SerializedTimeEvent {\n    /**\n     * {@inheritDoc TimeEvent.name}\n     */\n    name: string;\n    /**\n     * {@inheritDoc TimeEvent.targetTime}\n     */\n    targetTime: number;\n}\n//# sourceMappingURL=SerializedTimeEvent.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/scenes/timeEvents/TimeEvent.d.ts", content: "/**\n * Represents a time event at runtime.\n */\nexport interface TimeEvent {\n    /**\n     * Name of the event.\n     */\n    name: string;\n    /**\n     * Time in seconds, relative to the beginning of the scene, at which the event\n     * was registered.\n     *\n     * @remarks\n     * In other words, the moment at which {@link flow.waitUntil} for this event\n     * was invoked.\n     */\n    initialTime: number;\n    /**\n     * Time in seconds, relative to the beginning of the scene, at which the event\n     * should end.\n     */\n    targetTime: number;\n    /**\n     * Duration of the event in seconds.\n     */\n    offset: number;\n    /**\n     * Stack trace at the moment of registration.\n     */\n    stack?: string;\n}\n//# sourceMappingURL=TimeEvent.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/scenes/timeEvents/TimeEvents.d.ts", content: "import type { SubscribableValueEvent } from '../../events';\nimport type { TimeEvent } from './TimeEvent';\n/**\n * An interface for classes managing the time events.\n */\nexport interface TimeEvents {\n    /**\n     * Triggered when time events change.\n     *\n     * @eventProperty\n     */\n    get onChanged(): SubscribableValueEvent<TimeEvent[]>;\n    /**\n     * Change the time offset of the given event.\n     *\n     * @param name - The name of the event.\n     * @param offset - The time offset in seconds.\n     * @param preserve - Whether the timing of the consecutive events should be\n     *                   preserved. When set to `true` their offsets will be\n     *                   adjusted to keep them in place.\n     */\n    set(name: string, offset: number, preserve?: boolean): void;\n    /**\n     * Register a time event.\n     *\n     * @param name - The name of the event.\n     * @param initialTime - Time in seconds, relative to the beginning of the\n     *                      scene, at which the event was registered.\n     *\n     * @returns The duration of the event in seconds.\n     *\n     * @internal\n     */\n    register(name: string, initialTime: number): number;\n}\n//# sourceMappingURL=TimeEvents.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/scenes/timeEvents/index.d.ts", content: "export * from './EditableTimeEvents';\nexport * from './ReadOnlyTimeEvents';\nexport * from './SerializedTimeEvent';\nexport * from './TimeEvent';\nexport * from './TimeEvents';\n//# sourceMappingURL=index.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/signals/CompoundSignalContext.d.ts", content: "import { InterpolationFunction } from '../tweening';\nimport { Signal, SignalContext } from './SignalContext';\nimport { SignalExtensions, SignalValue } from './types';\nexport type CompoundSignal<TSetterValue, TValue extends TSetterValue, TKeys extends keyof TValue = keyof TValue, TOwner = void, TContext = CompoundSignalContext<TSetterValue, TValue, TKeys, TOwner>> = Signal<TSetterValue, TValue, TOwner, TContext> & {\n    [K in TKeys]: Signal<TValue[K], TValue[K], TOwner extends void ? CompoundSignal<TSetterValue, TValue, TKeys, TOwner, TContext> : TOwner>;\n};\nexport declare class CompoundSignalContext<TSetterValue, TValue extends TSetterValue, TKeys extends keyof TValue = keyof TValue, TOwner = void> extends SignalContext<TSetterValue, TValue, TOwner> {\n    private readonly entries;\n    readonly signals: [keyof TValue, Signal<any, any, TOwner>][];\n    constructor(entries: (TKeys | [keyof TValue, Signal<any, any, TOwner>])[], parser: (value: TSetterValue) => TValue, initial: SignalValue<TSetterValue>, interpolation: InterpolationFunction<TValue>, owner?: TOwner, extensions?: Partial<SignalExtensions<TSetterValue, TValue>>);\n    toSignal(): CompoundSignal<TSetterValue, TValue, TKeys, TOwner>;\n    parse(value: TSetterValue): TValue;\n    getter(): TValue;\n    setter(value: SignalValue<TValue>): TOwner;\n    reset(): TOwner;\n    save(): TOwner;\n    isInitial(): boolean;\n    raw(): TSetterValue;\n}\n//# sourceMappingURL=CompoundSignalContext.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/signals/ComputedContext.d.ts", content: "import { DependencyContext } from './DependencyContext';\nexport interface Computed<TValue> {\n    (...args: any[]): TValue;\n    context: ComputedContext<TValue>;\n}\nexport declare class ComputedContext<TValue> extends DependencyContext<any> {\n    private readonly factory;\n    private last;\n    constructor(factory: (...args: any[]) => TValue, owner?: any);\n    toSignal(): Computed<TValue>;\n    dispose(): void;\n    protected invoke(...args: any[]): TValue;\n}\n//# sourceMappingURL=ComputedContext.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/signals/DeferredEffectContext.d.ts", content: "import { DependencyContext } from './DependencyContext';\nexport declare class DeferredEffectContext extends DependencyContext {\n    private readonly callback;\n    private readonly unsubscribe;\n    constructor(callback: () => void);\n    private update;\n    dispose(): void;\n}\n//# sourceMappingURL=DeferredEffectContext.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/signals/DependencyContext.d.ts", content: "import { FlagDispatcher, Subscribable } from '../events';\nimport { Promisable } from '../threading';\nexport interface PromiseHandle<T> {\n    promise: Promise<T>;\n    value: T;\n    stack?: string;\n    owner?: any;\n}\nexport declare class DependencyContext<TOwner = void> implements Promisable<DependencyContext<TOwner>> {\n    protected owner: TOwner;\n    protected static collectionSet: Set<DependencyContext<any>>;\n    protected static collectionStack: DependencyContext<any>[];\n    protected static promises: PromiseHandle<any>[];\n    static collectPromise<T>(promise: Promise<T>): PromiseHandle<T | null>;\n    static collectPromise<T>(promise: Promise<T>, initialValue: T): PromiseHandle<T>;\n    static hasPromises(): boolean;\n    static consumePromises(): Promise<PromiseHandle<any>[]>;\n    protected readonly invokable: any;\n    protected dependencies: Set<Subscribable<void, import(\"../events\").EventHandler<void>>>;\n    protected event: FlagDispatcher;\n    protected markDirty: () => void;\n    constructor(owner: TOwner);\n    protected invoke(): void;\n    protected startCollecting(): void;\n    protected finishCollecting(): void;\n    protected clearDependencies(): void;\n    protected collect(): void;\n    dispose(): void;\n    toPromise(): Promise<this>;\n}\n//# sourceMappingURL=DependencyContext.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/signals/EffectContext.d.ts", content: "import { DependencyContext } from './DependencyContext';\nexport declare class EffectContext extends DependencyContext {\n    private readonly callback;\n    constructor(callback: () => void);\n    private update;\n}\n//# sourceMappingURL=EffectContext.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/signals/SignalContext.d.ts", content: "import { ThreadGenerator } from '../threading';\nimport { InterpolationFunction, TimingFunction } from '../tweening';\nimport { DependencyContext } from './DependencyContext';\nimport { DEFAULT } from './symbols';\nimport { SignalExtensions, SignalGenerator, SignalGetter, SignalSetter, SignalTween, SignalValue } from './types';\nexport type SimpleSignal<TValue, TReturn = void> = Signal<TValue, TValue, TReturn>;\nexport interface Signal<TSetterValue, TValue extends TSetterValue, TOwner = void, TContext = SignalContext<TSetterValue, TValue, TOwner>> extends SignalSetter<TSetterValue, TOwner>, SignalGetter<TValue>, SignalTween<TSetterValue, TValue> {\n    /**\n     * {@inheritDoc SignalContext.reset}\n     */\n    reset(): TOwner;\n    /**\n     * {@inheritDoc SignalContext.save}\n     */\n    save(): TOwner;\n    /**\n     * {@inheritDoc SignalContext.isInitial}\n     */\n    isInitial(): boolean;\n    context: TContext;\n}\nexport declare class SignalContext<TSetterValue, TValue extends TSetterValue = TSetterValue, TOwner = void> extends DependencyContext<TOwner> {\n    private initial;\n    private readonly interpolation;\n    protected parser: (value: TSetterValue) => TValue;\n    protected extensions: SignalExtensions<TSetterValue, TValue>;\n    protected current: SignalValue<TSetterValue> | undefined;\n    protected last: TValue | undefined;\n    protected tweening: boolean;\n    constructor(initial: SignalValue<TSetterValue> | undefined, interpolation: InterpolationFunction<TValue>, owner?: TOwner, parser?: (value: TSetterValue) => TValue, extensions?: Partial<SignalExtensions<TSetterValue, TValue>>);\n    toSignal(): Signal<TSetterValue, TValue, TOwner>;\n    parse(value: TSetterValue): TValue;\n    set(value: SignalValue<TSetterValue> | typeof DEFAULT): TOwner;\n    setter(value: SignalValue<TSetterValue> | typeof DEFAULT): TOwner;\n    get(): TValue;\n    getter(): TValue;\n    protected invoke(value?: SignalValue<TSetterValue> | typeof DEFAULT, duration?: number, timingFunction?: TimingFunction, interpolationFunction?: InterpolationFunction<TValue>): TValue | TOwner | SignalGenerator<TSetterValue, TValue>;\n    protected createQueue(defaultTimingFunction: TimingFunction, defaultInterpolationFunction: InterpolationFunction<TValue>): SignalGenerator<TSetterValue, TValue>;\n    protected tween(value: SignalValue<TSetterValue> | typeof DEFAULT, duration: number, timingFunction: TimingFunction, interpolationFunction: InterpolationFunction<TValue>): ThreadGenerator;\n    tweener(value: SignalValue<TSetterValue>, duration: number, timingFunction: TimingFunction, interpolationFunction: InterpolationFunction<TValue>): ThreadGenerator;\n    dispose(): void;\n    /**\n     * Reset the signal to its initial value (if one has been set).\n     *\n     * @example\n     * ```ts\n     * const signal = createSignal(7);\n     *\n     * signal.reset();\n     * // same as:\n     * signal(7);\n     * ```\n     */\n    reset(): TOwner;\n    /**\n     * Compute the current value of the signal and immediately set it.\n     *\n     * @remarks\n     * This method can be used to stop the signal from updating while keeping its\n     * current value.\n     *\n     * @example\n     * ```ts\n     * signal.save();\n     * // same as:\n     * signal(signal());\n     * ```\n     */\n    save(): TOwner;\n    /**\n     * Check if the signal is currently using its initial value.\n     *\n     * @example\n     * ```ts\n     *\n     * const signal = createSignal(0);\n     * signal.isInitial(); // true\n     *\n     * signal(5);\n     * signal.isInitial(); // false\n     *\n     * signal(DEFAULT);\n     * signal.isInitial(); // true\n     * ```\n     */\n    isInitial(): boolean;\n    /**\n     * Get the initial value of this signal.\n     */\n    getInitial(): SignalValue<TSetterValue> | undefined;\n    /**\n     * Get the raw value of this signal.\n     *\n     * @remarks\n     * If the signal was provided with a factory function, the function itself\n     * will be returned, without invoking it.\n     *\n     * This method can be used to create copies of signals.\n     *\n     * @example\n     * ```ts\n     * const a = createSignal(2);\n     * const b = createSignal(() => a);\n     * // b() == 2\n     *\n     * const bClone = createSignal(b.raw());\n     * // bClone() == 2\n     *\n     * a(4);\n     * // b() == 4\n     * // bClone() == 4\n     * ```\n     */\n    raw(): SignalValue<TSetterValue> | undefined;\n    /**\n     * Is the signal undergoing a tween?\n     */\n    isTweening(): boolean;\n}\n//# sourceMappingURL=SignalContext.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/signals/Vector2SignalContext.d.ts", content: "import { InterpolationFunction, TimingFunction } from '../tweening';\nimport { PossibleVector2, Vector2 } from '../types';\nimport { CompoundSignal, CompoundSignalContext } from './CompoundSignalContext';\nimport { Signal } from './SignalContext';\nimport { SignalExtensions, SignalGenerator, SignalValue } from './types';\nexport interface Vector2Edit<TOwner> {\n    (callback: (current: Vector2) => SignalValue<PossibleVector2>): TOwner;\n    (callback: (current: Vector2) => SignalValue<PossibleVector2>, duration: number, timingFunction?: TimingFunction, interpolationFunction?: InterpolationFunction<Vector2>): SignalGenerator<PossibleVector2, Vector2>;\n}\nexport interface Vector2Operation<TOwner> {\n    (value: PossibleVector2): TOwner;\n    (value: PossibleVector2, duration: number, timingFunction?: TimingFunction, interpolationFunction?: InterpolationFunction<Vector2>): SignalGenerator<PossibleVector2, Vector2>;\n}\nexport interface Vector2SignalHelpers<TOwner> {\n    edit: Vector2Edit<TOwner>;\n    mul: Vector2Operation<TOwner>;\n    div: Vector2Operation<TOwner>;\n    add: Vector2Operation<TOwner>;\n    sub: Vector2Operation<TOwner>;\n    dot: Vector2Operation<TOwner>;\n    cross: Vector2Operation<TOwner>;\n    mod: Vector2Operation<TOwner>;\n}\nexport type Vector2Signal<TOwner = void, TContext = Vector2SignalContext<TOwner>> = CompoundSignal<PossibleVector2, Vector2, 'x' | 'y', TOwner, TContext> & Vector2SignalHelpers<TOwner>;\nexport declare class Vector2SignalContext<TOwner = void> extends CompoundSignalContext<PossibleVector2, Vector2, 'x' | 'y', TOwner> implements Vector2SignalHelpers<TOwner> {\n    constructor(entries: ('x' | 'y' | [keyof Vector2, Signal<any, any, TOwner>])[], parser: (value: PossibleVector2) => Vector2, initial: SignalValue<PossibleVector2>, interpolation: InterpolationFunction<Vector2>, owner?: TOwner, extensions?: Partial<SignalExtensions<PossibleVector2, Vector2>>);\n    toSignal(): Vector2Signal<TOwner>;\n    edit(callback: (current: Vector2) => SignalValue<PossibleVector2>): TOwner;\n    edit(callback: (current: Vector2) => SignalValue<PossibleVector2>, duration: number, timingFunction?: TimingFunction, interpolationFunction?: InterpolationFunction<Vector2>): SignalGenerator<PossibleVector2, Vector2>;\n    mul(value: PossibleVector2): TOwner;\n    mul(value: PossibleVector2, duration: number, timingFunction?: TimingFunction, interpolationFunction?: InterpolationFunction<Vector2>): SignalGenerator<PossibleVector2, Vector2>;\n    div(value: PossibleVector2): TOwner;\n    div(value: PossibleVector2, duration: number, timingFunction?: TimingFunction, interpolationFunction?: InterpolationFunction<Vector2>): SignalGenerator<PossibleVector2, Vector2>;\n    add(value: PossibleVector2): TOwner;\n    add(value: PossibleVector2, duration: number, timingFunction?: TimingFunction, interpolationFunction?: InterpolationFunction<Vector2>): SignalGenerator<PossibleVector2, Vector2>;\n    sub(value: PossibleVector2): TOwner;\n    sub(value: PossibleVector2, duration: number, timingFunction?: TimingFunction, interpolationFunction?: InterpolationFunction<Vector2>): SignalGenerator<PossibleVector2, Vector2>;\n    dot(value: PossibleVector2): TOwner;\n    dot(value: PossibleVector2, duration: number, timingFunction?: TimingFunction, interpolationFunction?: InterpolationFunction<Vector2>): SignalGenerator<PossibleVector2, Vector2>;\n    cross(value: PossibleVector2): TOwner;\n    cross(value: PossibleVector2, duration: number, timingFunction?: TimingFunction, interpolationFunction?: InterpolationFunction<Vector2>): SignalGenerator<PossibleVector2, Vector2>;\n    mod(value: PossibleVector2): TOwner;\n    mod(value: PossibleVector2, duration: number, timingFunction?: TimingFunction, interpolationFunction?: InterpolationFunction<Vector2>): SignalGenerator<PossibleVector2, Vector2>;\n}\n//# sourceMappingURL=Vector2SignalContext.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/signals/createComputed.d.ts", content: "import { Computed } from '../signals';\nexport declare function createComputed<TValue>(factory: (...args: any[]) => TValue, owner?: any): Computed<TValue>;\n//# sourceMappingURL=createComputed.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/signals/createComputedAsync.d.ts", content: "import { Computed } from '../signals';\nexport declare function createComputedAsync<T>(factory: () => Promise<T>): Computed<T | null>;\nexport declare function createComputedAsync<T>(factory: () => Promise<T>, initial: T): Computed<T>;\n//# sourceMappingURL=createComputedAsync.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/signals/createDeferredEffect.d.ts", content: "/**\n * Invoke the callback at the end of each frame if any of its dependencies\n * changed.\n *\n * @param callback - The callback to invoke.\n */\nexport declare function createDeferredEffect(callback: () => void): () => void;\n//# sourceMappingURL=createDeferredEffect.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/signals/createEffect.d.ts", content: "/**\n * Invoke the callback immediately after any of its dependencies change.\n *\n * @param callback - The callback to invoke.\n */\nexport declare function createEffect(callback: () => void): () => void;\n//# sourceMappingURL=createEffect.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/signals/createSignal.d.ts", content: "import { SignalValue, SimpleSignal } from '../signals';\nimport { InterpolationFunction } from '../tweening';\nexport declare function createSignal<TValue, TOwner = void>(initial?: SignalValue<TValue>, interpolation?: InterpolationFunction<TValue>, owner?: TOwner): SimpleSignal<TValue, TOwner>;\n//# sourceMappingURL=createSignal.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/signals/index.d.ts", content: "/**\n * Value wrappers for easy dependency tracking and cache invalidation.\n *\n * @packageDocumentation\n */\nexport * from './CompoundSignalContext';\nexport * from './ComputedContext';\nexport * from './DeferredEffectContext';\nexport * from './DependencyContext';\nexport * from './EffectContext';\nexport * from './SignalContext';\nexport * from './Vector2SignalContext';\nexport * from './createComputed';\nexport * from './createComputedAsync';\nexport * from './createDeferredEffect';\nexport * from './createEffect';\nexport * from './createSignal';\nexport * from './symbols';\nexport * from './types';\nexport * from './utils';\n//# sourceMappingURL=index.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/signals/symbols.d.ts", content: "export declare const DEFAULT: unique symbol;\n//# sourceMappingURL=symbols.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/signals/types.d.ts", content: "import type { ThreadGenerator } from '../threading';\nimport type { InterpolationFunction, TimingFunction } from '../tweening';\nimport { DEFAULT } from './symbols';\nexport type SignalValue<TValue> = TValue | (() => TValue);\nexport type SignalGenerator<TSetterValue, TValue extends TSetterValue> = ThreadGenerator & {\n    /**\n     * Tween to the specified value.\n     */\n    to: SignalTween<TSetterValue, TValue>;\n    /**\n     * Tween back to the original value.\n     *\n     * @param time - The duration of the tween.\n     * @param timingFunction - The timing function of the tween.\n     * @param interpolationFunction - The interpolation function of the tween.\n     */\n    back: (time: number, timingFunction?: TimingFunction, interpolationFunction?: InterpolationFunction<TValue>) => SignalGenerator<TSetterValue, TValue>;\n    /**\n     * Wait for the specified duration.\n     *\n     * @param duration - The duration to wait.\n     */\n    wait: (duration: number) => SignalGenerator<TSetterValue, TValue>;\n    /**\n     * Run the given task.\n     *\n     * @param task - The generator to run.\n     */\n    run: (task: ThreadGenerator) => SignalGenerator<TSetterValue, TValue>;\n    /**\n     * Invoke the given callback.\n     *\n     * @param callback - The callback to invoke.\n     */\n    do: (callback: () => void) => SignalGenerator<TSetterValue, TValue>;\n};\nexport interface SignalSetter<TValue, TOwner = void> {\n    (value: SignalValue<TValue> | typeof DEFAULT): TOwner;\n}\nexport interface SignalGetter<TValue> {\n    (): TValue;\n}\nexport interface SignalTween<TSetterValue, TValue extends TSetterValue> {\n    (value: SignalValue<TSetterValue> | typeof DEFAULT, time: number, timingFunction?: TimingFunction, interpolationFunction?: InterpolationFunction<TValue>): SignalGenerator<TSetterValue, TValue>;\n}\nexport interface SignalExtensions<TSetterValue, TValue extends TSetterValue> {\n    getter: SignalGetter<TValue>;\n    setter: SignalSetter<TSetterValue>;\n    tweener(value: SignalValue<TSetterValue>, time: number, timingFunction?: TimingFunction, interpolationFunction?: InterpolationFunction<TValue>): ThreadGenerator;\n}\n//# sourceMappingURL=types.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/signals/utils.d.ts", content: "import { SignalValue } from './types';\nexport declare function isReactive<T>(value: SignalValue<T>): value is () => T;\nexport declare function modify<TFrom, TTo>(value: SignalValue<TFrom>, modification: (value: TFrom) => TTo): SignalValue<TTo>;\nexport declare function unwrap<T>(value: SignalValue<T>): T;\n//# sourceMappingURL=utils.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/threading/Thread.d.ts", content: "import { ThreadGenerator } from './ThreadGenerator';\n/**\n * A class representing an individual thread.\n *\n * @remarks\n * Thread is a wrapper for a generator that can be executed concurrently.\n *\n * Aside from the main thread, all threads need to have a parent.\n * If a parent finishes execution, all of its child threads are terminated.\n */\nexport declare class Thread {\n    /**\n     * The generator wrapped by this thread.\n     */\n    readonly runner: ThreadGenerator & {\n        task?: Thread;\n    };\n    get onDeferred(): import(\"../events\").Subscribable<void, import(\"../events\").EventHandler<void>>;\n    private deferred;\n    children: Thread[];\n    /**\n     * The next value to be passed to the wrapped generator.\n     */\n    value: unknown;\n    /**\n     * The current time of this thread.\n     *\n     * @remarks\n     * Used by {@link flow.waitFor} and other time-based functions to properly\n     * support durations shorter than one frame.\n     */\n    readonly time: import(\"../signals\").SimpleSignal<number, void>;\n    /**\n     * The fixed time of this thread.\n     *\n     * @remarks\n     * Fixed time is a multiple of the frame duration. It can be used to account\n     * for the difference between this thread's {@link time} and the time of the\n     * current animation frame.\n     */\n    get fixed(): number;\n    /**\n     * Check if this thread or any of its ancestors has been canceled.\n     */\n    get canceled(): boolean;\n    get paused(): boolean;\n    get root(): Thread;\n    parent: Thread | null;\n    private isCanceled;\n    private isPaused;\n    private fixedTime;\n    private queue;\n    constructor(\n    /**\n     * The generator wrapped by this thread.\n     */\n    runner: ThreadGenerator & {\n        task?: Thread;\n    });\n    /**\n     * Progress the wrapped generator once.\n     */\n    next(): IteratorYieldResult<void | Promise<any> | ThreadGenerator | import(\"./ThreadGenerator\").Promisable<any>> | IteratorReturnResult<void> | {\n        value: null;\n        done: boolean;\n    };\n    /**\n     * Prepare the thread for the next update cycle.\n     *\n     * @param dt - The delta time of the next cycle.\n     */\n    update(dt: number): void;\n    spawn(child: ThreadGenerator | (() => ThreadGenerator)): ThreadGenerator;\n    add(child: Thread): void;\n    drain(callback: (task: ThreadGenerator) => void): void;\n    cancel(): void;\n    pause(value: boolean): void;\n    runDeferred(): void;\n}\n//# sourceMappingURL=Thread.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/threading/ThreadGenerator.d.ts", content: "import { Thread } from './Thread';\nexport interface Promisable<T> {\n    toPromise(): Promise<T>;\n}\nexport declare function isPromisable(value: any): value is Promisable<any>;\n/**\n * The main generator type produced by all generator functions in Motion Canvas.\n *\n * @example\n * Yielded values can be used to control the flow of animation:\n *\n * Progress to the next frame:\n * ```ts\n * yield;\n * ```\n *\n * Run another generator synchronously:\n * ```ts\n * yield* generatorFunction();\n * ```\n *\n * Run another generator concurrently:\n * ```ts\n * const task = yield generatorFunction();\n * ```\n *\n * Await a Promise:\n * ```ts\n * const result = yield asyncFunction();\n * ```\n */\nexport type ThreadGenerator = Generator<ThreadGenerator | Promise<any> | Promisable<any> | void, void, Thread | any>;\n/**\n * Check if the given value is a {@link ThreadGenerator}.\n *\n * @param value - A possible thread {@link ThreadGenerator}.\n */\nexport declare function isThreadGenerator(value: unknown): value is ThreadGenerator;\n//# sourceMappingURL=ThreadGenerator.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/threading/cancel.d.ts", content: "import { ThreadGenerator } from './ThreadGenerator';\n/**\n * Cancel all listed tasks.\n *\n * Example:\n * ```ts\n * const task = yield generatorFunction();\n *\n * // do something concurrently\n *\n * yield* cancel(task);\n * ```\n *\n * @param tasks - A list of tasks to cancel.\n */\nexport declare function cancel(...tasks: ThreadGenerator[]): void;\n//# sourceMappingURL=cancel.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/threading/index.d.ts", content: "/**\n * Thread management.\n *\n * @packageDocumentation\n */\nexport * from './Thread';\nexport * from './ThreadGenerator';\nexport * from './cancel';\nexport * from './join';\nexport * from './names';\nexport * from './spawn';\nexport * from './threads';\n//# sourceMappingURL=index.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/threading/join.d.ts", content: "import { ThreadGenerator } from './ThreadGenerator';\n/**\n * Pause the current generator until all listed tasks are finished.\n *\n * @example\n * ```ts\n * const task = yield generatorFunction();\n *\n * // do something concurrently\n *\n * yield* join(task);\n * ```\n *\n * @param tasks - A list of tasks to join.\n */\nexport declare function join(...tasks: ThreadGenerator[]): ThreadGenerator;\n/**\n * Pause the current generator until listed tasks are finished.\n *\n * @example\n * ```ts\n * const taskA = yield generatorFunctionA();\n * const taskB = yield generatorFunctionB();\n *\n * // do something concurrently\n *\n * // await any of the tasks\n * yield* join(false, taskA, taskB);\n * ```\n *\n * @param all - Whether we should wait for all tasks or for at least one.\n * @param tasks - A list of tasks to join.\n */\nexport declare function join(all: boolean, ...tasks: ThreadGenerator[]): ThreadGenerator;\n//# sourceMappingURL=join.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/threading/names.d.ts", content: "export declare function setTaskName(task: Generator, source: Generator | string): void;\nexport declare function getTaskName(task: Generator): string;\n//# sourceMappingURL=names.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/threading/spawn.d.ts", content: "import { ThreadGenerator } from './ThreadGenerator';\n/**\n * Run the given task concurrently.\n *\n * @example\n * Using an existing task:\n * ```ts\n * spawn(rect().opacity(1, 1));\n * ```\n * Using a generator function:\n * ```ts\n * spawn(function* () {\n *   yield* rect().opacity(1, 1);\n *   yield* waitFor('click');\n *   yield* rect().opacity(0, 1);\n * });\n * ```\n * Await the spawned task:\n * ```ts\n * const task = spawn(rect().opacity(1, 1));\n * // do some other things\n * yield* join(task); // await the task\n * ```\n *\n * @param task - Either a generator function or a task to run.\n */\nexport declare function spawn(task: ThreadGenerator | (() => ThreadGenerator)): ThreadGenerator;\n//# sourceMappingURL=spawn.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/threading/threads.d.ts", content: "import { Thread } from './Thread';\nimport { ThreadGenerator } from './ThreadGenerator';\n/**\n * Check if the given value is a [Promise][promise].\n *\n * @param value - A possible [Promise][promise].\n *\n * [promise]: https://developer.mozilla.org/en-US/docs/web/javascript/reference/global_objects/promise\n */\nexport declare function isPromise(value: any): value is Promise<any>;\n/**\n * A generator function or a normal function that returns a generator.\n */\nexport interface ThreadsFactory {\n    (): ThreadGenerator;\n}\nexport interface ThreadsCallback {\n    (root: Thread): void;\n}\n/**\n * Create a context in which generators can be run concurrently.\n *\n * @remarks\n * From the perspective of the external generator, `threads` is executed\n * synchronously. By default, each scene generator is wrapped in its own\n * `threads` generator.\n *\n * @example\n * ```ts\n * // first\n *\n * yield* threads(function* () {\n *   const task = yield generatorFunction();\n *   // second\n * }); // <- `task` will be terminated here because the scope\n *     //    of this `threads` generator has ended\n *\n * // third\n * ```\n *\n * @param factory - A function that returns the generator to run.\n * @param callback - Called whenever threads are created, canceled or finished.\n *                   Used for debugging purposes.\n */\nexport declare function threads(factory: ThreadsFactory, callback?: ThreadsCallback): ThreadGenerator;\n//# sourceMappingURL=threads.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/transitions/fadeTransition.d.ts", content: "import { ThreadGenerator } from '../threading';\n/**\n * Perform a transition that fades between the scenes.\n *\n * @param duration - The duration of the transition.\n */\nexport declare function fadeTransition(duration?: number): ThreadGenerator;\n//# sourceMappingURL=fadeTransition.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/transitions/index.d.ts", content: "/**\n * Transitions between scenes.\n *\n * @packageDocumentation\n */\nexport * from './fadeTransition';\nexport * from './slideTransition';\nexport * from './useTransition';\nexport * from './waitTransition';\nexport * from './zoomInTransition';\nexport * from './zoomOutTransition';\n//# sourceMappingURL=index.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/transitions/slideTransition.d.ts", content: "import { ThreadGenerator } from '../threading';\nimport { Direction, Origin } from '../types';\n/**\n * Perform a transition that slides the scene in the given direction.\n *\n * @param direction - The direction in which to slide.\n * @param duration - The duration of the transition.\n */\nexport declare function slideTransition(direction: Direction, duration?: number): ThreadGenerator;\n/**\n * Perform a transition that slides the scene towards the given origin.\n *\n * @param origin - The origin towards which to slide.\n * @param duration - The duration of the transition.\n */\nexport declare function slideTransition(origin: Origin, duration?: number): ThreadGenerator;\n//# sourceMappingURL=slideTransition.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/transitions/useTransition.d.ts", content: "import { SignalValue } from '../signals/types';\n/**\n * Transition to the current scene by altering the Context2D before scenes are rendered.\n *\n * @param current - The callback to use before the current scene is rendered.\n * @param previous - The callback to use before the previous scene is rendered.\n * @param previousOnTop - Whether the previous scene should be rendered on top.\n */\nexport declare function useTransition(current: (ctx: CanvasRenderingContext2D) => void, previous?: (ctx: CanvasRenderingContext2D) => void, previousOnTop?: SignalValue<boolean>): () => void;\n//# sourceMappingURL=useTransition.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/transitions/waitTransition.d.ts", content: "import { SignalValue } from '../signals';\nimport { ThreadGenerator } from '../threading';\n/**\n * Perform a transition that doesn't do anything.\n *\n * @remarks\n * This is useful when you want to achieve a transition effect by animating\n * objects in the scenes. It will overlay the scenes on top of each other for\n * the duration of the transition.\n *\n * @param duration - The duration of the transition.\n * @param previousOnTop - Whether the previous scene should be rendered on top.\n */\nexport declare function waitTransition(duration?: number, previousOnTop?: SignalValue<boolean>): ThreadGenerator;\n//# sourceMappingURL=waitTransition.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/transitions/zoomInTransition.d.ts", content: "import { ThreadGenerator } from '../threading';\nimport { BBox } from '../types';\n/**\n * Perform a transition that zooms in on a given area of the scene.\n *\n * @param area - The area on which to zoom in.\n * @param duration - The duration of the transition.\n */\nexport declare function zoomInTransition(area: BBox, duration?: number): ThreadGenerator;\n//# sourceMappingURL=zoomInTransition.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/transitions/zoomOutTransition.d.ts", content: "import { ThreadGenerator } from '../threading';\nimport { BBox } from '../types';\n/**\n * Perform a transition that zooms out from a given area of the scene.\n *\n * @param area - The area from which to zoom out.\n * @param duration - The duration of the transition.\n */\nexport declare function zoomOutTransition(area: BBox, duration?: number): ThreadGenerator;\n//# sourceMappingURL=zoomOutTransition.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/tweening/index.d.ts", content: "/**\n * Interpolation and timing of tweens.\n *\n * @packageDocumentation\n */\nexport * from './interpolationFunctions';\nexport * from './spring';\nexport * from './timingFunctions';\nexport * from './tween';\n//# sourceMappingURL=index.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/tweening/interpolationFunctions.d.ts", content: "import { Vector2 } from '../types';\nexport interface InterpolationFunction<T, TRest extends any[] = any[]> {\n    (from: T, to: T, value: number, ...args: TRest): T;\n}\nexport declare function textLerp(fromString: string, toString: string, value: number): string;\n/**\n * Interpolate between any two Records, including objects and Maps, even with\n * mismatched keys.\n *\n * @remarks\n * Any old key that is missing in `to` will be removed immediately once value is\n * not 0. Any new key that is missing in `from` will be added once value reaches\n * 1.\n *\n * @param from - The input to favor when value is 0.\n * @param to - The input to favor when value is 1.\n * @param value - On a scale between 0 and 1, how closely to favor from vs to.\n *\n * @returns A value matching the structure of from and to.\n */\nexport declare function deepLerp<TFrom extends Record<any, unknown>, TTo extends Record<any, unknown>>(from: TFrom, to: TTo, value: number): TFrom | TTo;\nexport declare function deepLerp<TFrom extends Record<any, unknown>, TTo extends Record<any, unknown>>(from: TFrom, to: TTo, value: number, suppressWarnings: boolean): TFrom | TTo;\n/**\n * Interpolate between any two values, including objects, arrays, and Maps.\n *\n * @param from - The input to favor when value is 0.\n * @param to - The input to favor when value is 1.\n * @param value - On a scale between 0 and 1, how closely to favor from vs to.\n *\n * @returns A value matching the structure of from and to.\n */\nexport declare function deepLerp<T>(from: T, to: T, value: number): T;\nexport declare function deepLerp<T>(from: T, to: T, value: number, suppressWarnings: boolean): T;\nexport declare function boolLerp<T>(from: T, to: T, value: number): T;\nexport declare function map(from: number, to: number, value: number): number;\nexport declare function remap(fromIn: number, toIn: number, fromOut: number, toOut: number, value: number): number;\nexport declare function clamp(min: number, max: number, value: number): number;\nexport declare function clampRemap(fromIn: number, toIn: number, fromOut: number, toOut: number, value: number): number;\nexport declare function arcLerp(value: number, reverse: boolean, ratio: number): Vector2;\n//# sourceMappingURL=interpolationFunctions.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/tweening/spring.d.ts", content: "import { ThreadGenerator } from '../threading';\ntype ProgressFunction = (value: number, time: number) => void;\nexport declare function spring(spring: Spring | null, from: number, to: number, settleTolerance: number, onProgress: ProgressFunction, onEnd?: ProgressFunction): ThreadGenerator;\nexport declare function spring(spring: Spring | null, from: number, to: number, onProgress: ProgressFunction, onEnd?: ProgressFunction): ThreadGenerator;\nexport interface Spring {\n    mass: number;\n    stiffness: number;\n    damping: number;\n    initialVelocity?: number;\n}\nexport declare function makeSpring(mass: number, stiffness: number, damping: number, initialVelocity?: number): Spring;\nexport declare const BeatSpring: Spring;\nexport declare const PlopSpring: Spring;\nexport declare const BounceSpring: Spring;\nexport declare const SwingSpring: Spring;\nexport declare const JumpSpring: Spring;\nexport declare const StrikeSpring: Spring;\nexport declare const SmoothSpring: Spring;\nexport {};\n//# sourceMappingURL=spring.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/tweening/timingFunctions.d.ts", content: "export interface TimingFunction {\n    (value: number, from?: number, to?: number): number;\n}\nexport declare function sin(value: number, from?: number, to?: number): number;\nexport declare function easeInSine(value: number, from?: number, to?: number): number;\nexport declare function easeOutSine(value: number, from?: number, to?: number): number;\nexport declare function easeInOutSine(value: number, from?: number, to?: number): number;\nexport declare function easeInQuad(value: number, from?: number, to?: number): number;\nexport declare function easeOutQuad(value: number, from?: number, to?: number): number;\nexport declare function easeInOutQuad(value: number, from?: number, to?: number): number;\nexport declare function easeInCubic(value: number, from?: number, to?: number): number;\nexport declare function easeOutCubic(value: number, from?: number, to?: number): number;\nexport declare function easeInOutCubic(value: number, from?: number, to?: number): number;\nexport declare function easeInQuart(value: number, from?: number, to?: number): number;\nexport declare function easeOutQuart(value: number, from?: number, to?: number): number;\nexport declare function easeInOutQuart(value: number, from?: number, to?: number): number;\nexport declare function easeInQuint(value: number, from?: number, to?: number): number;\nexport declare function easeOutQuint(value: number, from?: number, to?: number): number;\nexport declare function easeInOutQuint(value: number, from?: number, to?: number): number;\nexport declare function easeInExpo(value: number, from?: number, to?: number): number;\nexport declare function easeOutExpo(value: number, from?: number, to?: number): number;\nexport declare function easeInOutExpo(value: number, from?: number, to?: number): number;\nexport declare function easeInCirc(value: number, from?: number, to?: number): number;\nexport declare function easeOutCirc(value: number, from?: number, to?: number): number;\nexport declare function easeInOutCirc(value: number, from?: number, to?: number): number;\nexport declare function createEaseInBack(s?: number): TimingFunction;\nexport declare function createEaseOutBack(s?: number): TimingFunction;\nexport declare function createEaseInOutBack(s?: number, v?: number): TimingFunction;\nexport declare function createEaseInElastic(s?: number): TimingFunction;\nexport declare function createEaseOutElastic(s?: number): TimingFunction;\nexport declare function createEaseInOutElastic(s?: number): TimingFunction;\nexport declare function createEaseInBounce(n?: number, d?: number): TimingFunction;\nexport declare function createEaseOutBounce(n?: number, d?: number): TimingFunction;\nexport declare function createEaseInOutBounce(n?: number, d?: number): TimingFunction;\nexport declare function linear(value: number, from?: number, to?: number): number;\nexport declare function cos(value: number, from?: number, to?: number): number;\nexport declare const easeInBack: TimingFunction;\nexport declare const easeOutBack: TimingFunction;\nexport declare const easeInOutBack: TimingFunction;\nexport declare const easeInBounce: TimingFunction;\nexport declare const easeOutBounce: TimingFunction;\nexport declare const easeInOutBounce: TimingFunction;\nexport declare const easeInElastic: TimingFunction;\nexport declare const easeOutElastic: TimingFunction;\nexport declare const easeInOutElastic: TimingFunction;\n//# sourceMappingURL=timingFunctions.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/tweening/tween.d.ts", content: "import { ThreadGenerator } from '../threading';\nexport declare function tween(seconds: number, onProgress: (value: number, time: number) => void, onEnd?: (value: number, time: number) => void): ThreadGenerator;\n//# sourceMappingURL=tween.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/types/BBox.d.ts", content: "import { CompoundSignal, SignalValue } from '../signals';\nimport { InterpolationFunction } from '../tweening';\nimport { PossibleMatrix2D } from './Matrix2D';\nimport { PossibleSpacing } from './Spacing';\nimport { Type, WebGLConvertible } from './Type';\nimport { Vector2 } from './Vector';\nexport type SerializedBBox = {\n    x: number;\n    y: number;\n    width: number;\n    height: number;\n};\nexport type PossibleBBox = SerializedBBox | [number, number, number, number] | Vector2 | undefined;\nexport type RectSignal<T> = CompoundSignal<PossibleBBox, BBox, 'x' | 'y' | 'width' | 'height', T>;\nexport declare class BBox implements Type, WebGLConvertible {\n    static readonly symbol: unique symbol;\n    x: number;\n    y: number;\n    width: number;\n    height: number;\n    static createSignal(initial?: SignalValue<PossibleBBox>, interpolation?: InterpolationFunction<BBox>): RectSignal<void>;\n    static lerp(from: BBox, to: BBox, value: number | Vector2 | BBox): BBox;\n    static arcLerp(from: BBox, to: BBox, value: number, reverse?: boolean, ratio?: number): BBox;\n    static fromSizeCentered(size: Vector2): BBox;\n    static fromPoints(...points: Vector2[]): BBox;\n    static fromBBoxes(...boxes: BBox[]): BBox;\n    lerp(to: BBox, value: number | Vector2 | BBox): BBox;\n    get position(): Vector2;\n    set position(value: Vector2);\n    get size(): Vector2;\n    get center(): Vector2;\n    get left(): number;\n    set left(value: number);\n    get right(): number;\n    set right(value: number);\n    get top(): number;\n    set top(value: number);\n    get bottom(): number;\n    set bottom(value: number);\n    get topLeft(): Vector2;\n    get topRight(): Vector2;\n    get bottomLeft(): Vector2;\n    get bottomRight(): Vector2;\n    get corners(): [Vector2, Vector2, Vector2, Vector2];\n    get pixelPerfect(): BBox;\n    constructor();\n    constructor(from: PossibleBBox);\n    constructor(position: Vector2, size: Vector2);\n    constructor(x: number, y?: number, width?: number, height?: number);\n    transform(matrix: PossibleMatrix2D): BBox;\n    transformCorners(matrix: PossibleMatrix2D): Vector2[];\n    /**\n     * Expand the bounding box to accommodate the given spacing.\n     *\n     * @param value - The value to expand the bounding box by.\n     */\n    expand(value: PossibleSpacing): BBox;\n    /**\n     * {@inheritDoc expand}\n     *\n     * @deprecated Use {@link expand} instead.\n     */\n    addSpacing(value: PossibleSpacing): BBox;\n    includes(point: Vector2): boolean;\n    intersects(other: BBox): boolean;\n    intersection(other: BBox): BBox;\n    union(other: BBox): BBox;\n    toSymbol(): symbol;\n    toString(): string;\n    toUniform(gl: WebGL2RenderingContext, location: WebGLUniformLocation): void;\n    serialize(): SerializedBBox;\n}\n//# sourceMappingURL=BBox.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/types/Canvas.d.ts", content: "export type CanvasColorSpace = 'srgb' | 'display-p3';\nexport type CanvasOutputMimeType = 'image/png' | 'image/jpeg' | 'image/webp';\n//# sourceMappingURL=Canvas.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/types/Color.d.ts", content: "import { Color } from 'chroma-js';\nimport { Signal, SignalValue } from '../signals';\nimport type { InterpolationFunction } from '../tweening';\nimport type { Type, WebGLConvertible } from './Type';\nexport type SerializedColor = string;\nexport type PossibleColor = SerializedColor | number | Color | {\n    r: number;\n    g: number;\n    b: number;\n    a: number;\n};\nexport type ColorSignal<T> = Signal<PossibleColor, Color, T>;\ndeclare module 'chroma-js' {\n    interface Color extends Type, WebGLConvertible {\n        serialize(): string;\n        lerp(to: ColorInterface | string, value: number, colorSpace?: ColorSpace): ColorInterface;\n    }\n    type ColorInterface = import('chroma-js').Color;\n    type ColorSpace = import('chroma-js').InterpolationMode;\n    interface ColorStatic {\n        symbol: symbol;\n        lerp(from: ColorInterface | string | null, to: ColorInterface | string | null, value: number, colorSpace?: ColorSpace): ColorInterface;\n        createLerp(colorSpace: ColorSpace): InterpolationFunction<ColorInterface>;\n        createSignal(initial?: SignalValue<PossibleColor>, interpolation?: InterpolationFunction<ColorInterface>): ColorSignal<void>;\n    }\n    interface ChromaStatic {\n        Color: ColorStatic & (new (color: PossibleColor) => ColorInterface);\n    }\n}\n/**\n * Represents a color.\n *\n * @remarks\n * This is the same class as the one created by\n * {@link https://gka.github.io/chroma.js/ | chroma.js}. Check out their\n * documentation for more information on how to use it.\n */\ntype ExtendedColor = Color;\ndeclare const ExtendedColor: typeof Color;\nexport { ExtendedColor as Color };\n//# sourceMappingURL=Color.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/types/Matrix.d.ts", content: "export declare function transformAngle(angle: number, matrix: DOMMatrix): number;\nexport declare function transformScalar(scalar: number, matrix: DOMMatrix): number;\n//# sourceMappingURL=Matrix.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/types/Matrix2D.d.ts", content: "import { Type, WebGLConvertible } from './Type';\nimport { PossibleVector2, Vector2 } from './Vector';\nexport type PossibleMatrix2D = Matrix2D | DOMMatrix | [number, number, number, number, number, number] | [PossibleVector2, PossibleVector2, PossibleVector2] | undefined;\n/**\n * A specialized 2x3 Matrix representing a 2D transformation.\n *\n * A Matrix2D contains six elements defined as\n * [a, b,\n *  c, d,\n *  tx, ty]\n *\n * This is a shortcut for a 3x3 matrix of the form\n * [a, b, 0,\n *  c, d, 0\n *  tx, ty, 1]\n *\n * Note that because a Matrix2D ignores the z-values of each component vectors,\n * it does not satisfy all properties of a \"real\" 3x3 matrix.\n *\n *   - A Matrix2D has no transpose\n *   - A(B + C) = AB + AC does not hold for a Matrix2D\n *   - (rA)^-1 = r^-1 A^-1, r != 0 does not hold for a Matrix2D\n *   - r(AB) = (rA)B = A(rB) does not hold for a Matrix2D\n */\nexport declare class Matrix2D implements Type, WebGLConvertible {\n    static readonly symbol: unique symbol;\n    readonly values: Float32Array;\n    static readonly identity: Matrix2D;\n    static readonly zero: Matrix2D;\n    static fromRotation(angle: number): Matrix2D;\n    static fromTranslation(translation: PossibleVector2): Matrix2D;\n    static fromScaling(scale: PossibleVector2): Matrix2D;\n    get x(): Vector2;\n    get y(): Vector2;\n    get scaleX(): number;\n    set scaleX(value: number);\n    get skewX(): number;\n    set skewX(value: number);\n    get scaleY(): number;\n    set scaleY(value: number);\n    get skewY(): number;\n    set skewY(value: number);\n    get translateX(): number;\n    set translateX(value: number);\n    get translateY(): number;\n    set translateY(value: number);\n    get rotation(): number;\n    set rotation(angle: number);\n    get translation(): Vector2;\n    set translation(translation: PossibleVector2);\n    get scaling(): Vector2;\n    set scaling(value: PossibleVector2);\n    /**\n     * Get the inverse of the matrix.\n     *\n     * @remarks\n     * If the matrix is not invertible, i.e. its determinant is `0`, this will\n     * return `null`, instead.\n     *\n     * @example\n     * ```ts\n     * const matrix = new Matrix2D(\n     *   [1, 2],\n     *   [3, 4],\n     *   [5, 6],\n     * );\n     *\n     * const inverse = matrix.inverse;\n     * // => Matrix2D(\n     * //      [-2, 1],\n     * //      [1.5, -0.5],\n     * //      [1, -2],\n     * //   )\n     * ```\n     */\n    get inverse(): Matrix2D | null;\n    /**\n     * Get the determinant of the matrix.\n     */\n    get determinant(): number;\n    get domMatrix(): DOMMatrix;\n    constructor();\n    constructor(matrix: PossibleMatrix2D);\n    constructor(x: PossibleVector2, y: PossibleVector2, z: PossibleVector2);\n    constructor(a: number, b: number, c: number, d: number, tx: number, ty: number);\n    /**\n     * Get the nth component vector of the matrix. Only defined for 0, 1, and 2.\n     *\n     * @example\n     * ```ts\n     * const matrix = new Matrix2D(\n     *   [1, 0],\n     *   [0, 0],\n     *   [1, 0],\n     * );\n     *\n     * const x = matrix.column(0);\n     * // Vector2(1, 0)\n     *\n     * const y = matrix.column(1);\n     * // Vector2(0, 0)\n     *\n     * const z = matrix.column(1);\n     * // Vector2(1, 0)\n     * ```\n     *\n     * @param index - The index of the component vector to retrieve.\n     */\n    column(index: number): Vector2;\n    /**\n     * Returns the nth row of the matrix. Only defined for 0 and 1.\n     *\n     * @example\n     * ```ts\n     * const matrix = new Matrix2D(\n     *   [1, 0],\n     *   [0, 0],\n     *   [1, 0],\n     * );\n     *\n     * const firstRow = matrix.column(0);\n     * // [1, 0, 1]\n     *\n     * const secondRow = matrix.column(1);\n     * // [0, 0, 0]\n     * ```\n     *\n     * @param index - The index of the row to retrieve.\n     */\n    row(index: number): [number, number, number];\n    /**\n     * Returns the matrix product of this matrix with the provided matrix.\n     *\n     * @remarks\n     * This method returns a new matrix representing the result of the\n     * computation. It will not modify the source matrix.\n     *\n     * @example\n     * ```ts\n     * const a = new Matrix2D(\n     *   [1, 2],\n     *   [0, 1],\n     *   [1, 1],\n     * );\n     * const b = new Matrix2D(\n     *   [2, 1],\n     *   [1, 1],\n     *   [1, 1],\n     * );\n     *\n     * const result = a.mul(b);\n     * // => Matrix2D(\n     * //     [2, 5],\n     * //     [1, 3],\n     * //     [2, 4],\n     * //   )\n     * ```\n     *\n     * @param other - The matrix to multiply with\n     */\n    mul(other: Matrix2D): Matrix2D;\n    /**\n     * Rotate the matrix by the provided angle. By default, the angle is\n     * provided in degrees.\n     *\n     * @remarks\n     * This method returns a new matrix representing the result of the\n     * computation. It will not modify the source matrix.\n     *\n     * @example\n     * ```ts\n     * const a = new Matrix2D(\n     *   [1, 2],\n     *   [3, 4],\n     *   [5, 6],\n     * );\n     *\n     * const result = a.rotate(90);\n     * // => Matrix2D(\n     * //     [3, 4],\n     * //     [-1, -2],\n     * //     [5, 6],\n     * //   )\n     *\n     * // Provide the angle in radians\n     * const result = a.rotate(Math.PI * 0.5, true);\n     * // => Matrix2D(\n     * //     [3, 4],\n     * //     [-1, -2],\n     * //     [5, 6],\n     * //   )\n     * ```\n     *\n     * @param angle - The angle by which to rotate the matrix.\n     * @param degrees - Whether the angle is provided in degrees.\n     */\n    rotate(angle: number, degrees?: boolean): Matrix2D;\n    /**\n     * Scale the x and y component vectors of the matrix.\n     *\n     * @remarks\n     * If `vec` is provided as a vector, the x and y component vectors of the\n     * matrix will be scaled by the x and y parts of the vector, respectively.\n     *\n     * If `vec` is provided as a scalar, the x and y component vectors will be\n     * scaled uniformly by this factor.\n     *\n     * This method returns a new matrix representing the result of the\n     * computation. It will not modify the source matrix.\n     *\n     * @example\n     * ```ts\n     * const matrix = new Matrix2D(\n     *   [1, 2],\n     *   [3, 4],\n     *   [5, 6],\n     * );\n     *\n     * const result1 = matrix.scale([2, 3]);\n     * // => new Matrix2D(\n     * //      [2, 4],\n     * //      [9, 12],\n     * //      [5, 6],\n     * //    )\n     *\n     * const result2 = matrix.scale(2);\n     * // => new Matrix2D(\n     * //      [2, 4],\n     * //      [6, 8],\n     * //      [5, 6],\n     * //    )\n     * ```\n     *\n     * @param vec - The factor by which to scale the matrix\n     */\n    scale(vec: PossibleVector2): Matrix2D;\n    /**\n     * Multiply each value of the matrix by a scalar.\n     *\n     * * @example\n     * ```ts\n     * const matrix = new Matrix2D(\n     *   [1, 2],\n     *   [3, 4],\n     *   [5, 6],\n     * );\n     *\n     * const result1 = matrix.mulScalar(2);\n     * // => new Matrix2D(\n     * //      [2, 4],\n     * //      [6, 8],\n     * //      [10, 12],\n     * //    )\n     * ```\n     *\n     * @param s - The value by which to scale each term\n     */\n    mulScalar(s: number): Matrix2D;\n    /**\n     * Translate the matrix by the dimensions of the provided vector.\n     *\n     * @remarks\n     * If `vec` is provided as a scalar, matrix will be translated uniformly\n     * by this factor.\n     *\n     * This method returns a new matrix representing the result of the\n     * computation. It will not modify the source matrix.\n     *\n     * @example\n     * ```ts\n     * const matrix = new Matrix2D(\n     *   [1, 2],\n     *   [3, 4],\n     *   [5, 6],\n     * );\n     *\n     * const result1 = matrix.translate([2, 3]);\n     * // => new Matrix2D(\n     * //      [1, 2],\n     * //      [3, 4],\n     * //      [16, 22],\n     * //    )\n     *\n     * const result2 = matrix.translate(2);\n     * // => new Matrix2D(\n     * //      [1, 2],\n     * //      [3, 4],\n     * //      [13, 18],\n     * //    )\n     * ```\n     *\n     * @param vec - The vector by which to translate the matrix\n     */\n    translate(vec: PossibleVector2): Matrix2D;\n    /**\n     * Add the provided matrix to this matrix.\n     *\n     * @remarks\n     * This method returns a new matrix representing the result of the\n     * computation. It will not modify the source matrix.\n     *\n     * @example\n     * ```ts\n     * const a = new Matrix2D(\n     *   [1, 2],\n     *   [3, 4],\n     *   [5, 6],\n     * );\n     * const a = new Matrix2D(\n     *   [7, 8],\n     *   [9, 10],\n     *   [11, 12],\n     * );\n     *\n     * const result = a.add(b);\n     * // => Matrix2D(\n     * //      [8, 10],\n     * //      [12, 14],\n     * //      [16, 18],\n     * //    )\n     * ```\n     *\n     * @param other - The matrix to add\n     */\n    add(other: Matrix2D): Matrix2D;\n    /**\n     * Subtract the provided matrix from this matrix.\n     *\n     * @remarks\n     * This method returns a new matrix representing the result of the\n     * computation. It will not modify the source matrix.\n     *\n     * @example\n     * ```ts\n     * const a = new Matrix2D(\n     *   [1, 2],\n     *   [3, 4],\n     *   [5, 6],\n     * );\n     * const a = new Matrix2D(\n     *   [7, 8],\n     *   [9, 10],\n     *   [11, 12],\n     * );\n     *\n     * const result = a.sub(b);\n     * // => Matrix2D(\n     * //      [-6, -6],\n     * //      [-6, -6],\n     * //      [-6, -6],\n     * //    )\n     * ```\n     *\n     * @param other - The matrix to subract\n     */\n    sub(other: Matrix2D): Matrix2D;\n    toSymbol(): symbol;\n    toUniform(gl: WebGL2RenderingContext, location: WebGLUniformLocation): void;\n    equals(other: Matrix2D, threshold?: number): boolean;\n    exactlyEquals(other: Matrix2D): boolean;\n}\n//# sourceMappingURL=Matrix2D.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/types/Origin.d.ts", content: "import { Vector2 } from './Vector';\nexport declare enum Center {\n    Vertical = 1,\n    Horizontal = 2\n}\nexport declare enum Direction {\n    Top = 4,\n    Bottom = 8,\n    Left = 16,\n    Right = 32\n}\nexport declare enum Origin {\n    Middle = 3,\n    Top = 5,\n    Bottom = 9,\n    Left = 18,\n    Right = 34,\n    TopLeft = 20,\n    TopRight = 36,\n    BottomLeft = 24,\n    BottomRight = 40\n}\nexport declare function flipOrigin(origin: Direction, axis?: Center): Direction;\nexport declare function flipOrigin(origin: Origin, axis?: Center): Origin;\n/**\n * Convert the given origin to a vector representing its offset.\n *\n * @example\n * ```ts\n * const bottomRight = originToOffset(Origin.TopRight);\n * // bottomRight = {x: 1, y: -1}\n * ```\n *\n * @param origin - The origin to convert.\n */\nexport declare function originToOffset(origin: Origin | Direction): Vector2;\n//# sourceMappingURL=Origin.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/types/Spacing.d.ts", content: "import { CompoundSignal, SignalValue } from '../signals';\nimport { InterpolationFunction } from '../tweening';\nimport { Type, WebGLConvertible } from './Type';\nexport type SerializedSpacing = {\n    top: number;\n    right: number;\n    bottom: number;\n    left: number;\n};\nexport type PossibleSpacing = SerializedSpacing | number | [number, number] | [number, number, number] | [number, number, number, number] | undefined;\nexport type SpacingSignal<T> = CompoundSignal<PossibleSpacing, Spacing, 'top' | 'right' | 'bottom' | 'left', T>;\nexport declare class Spacing implements Type, WebGLConvertible {\n    static readonly symbol: unique symbol;\n    top: number;\n    right: number;\n    bottom: number;\n    left: number;\n    static createSignal(initial?: SignalValue<PossibleSpacing>, interpolation?: InterpolationFunction<Spacing>): SpacingSignal<void>;\n    static lerp(from: Spacing, to: Spacing, value: number): Spacing;\n    get x(): number;\n    get y(): number;\n    constructor();\n    constructor(from: PossibleSpacing);\n    constructor(all: number);\n    constructor(vertical: number, horizontal: number);\n    constructor(top: number, horizontal: number, bottom: number);\n    constructor(top: number, right: number, bottom: number, left: number);\n    lerp(to: Spacing, value: number): Spacing;\n    scale(value: number): Spacing;\n    addScalar(value: number): Spacing;\n    toSymbol(): symbol;\n    toString(): string;\n    toUniform(gl: WebGL2RenderingContext, location: WebGLUniformLocation): void;\n    serialize(): SerializedSpacing;\n}\n//# sourceMappingURL=Spacing.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/types/Type.d.ts", content: "export declare const EPSILON = 0.000001;\nexport interface Type {\n    toSymbol(): symbol;\n}\nexport interface WebGLConvertible {\n    toUniform(gl: WebGL2RenderingContext, location: WebGLUniformLocation): void;\n}\nexport declare function isType(value: any): value is Type;\n//# sourceMappingURL=Type.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/types/Vector.d.ts", content: "import { Signal, SignalValue, Vector2Signal } from '../signals';\nimport { InterpolationFunction } from '../tweening/interpolationFunctions';\nimport { PossibleMatrix2D } from './Matrix2D';\nimport { Direction, Origin } from './Origin';\nimport { Type, WebGLConvertible } from './Type';\nexport type SerializedVector2<T = number> = {\n    x: T;\n    y: T;\n};\nexport type PossibleVector2<T = number> = SerializedVector2<T> | {\n    width: T;\n    height: T;\n} | T | [T, T] | undefined;\nexport type SimpleVector2Signal<T> = Signal<PossibleVector2, Vector2, T>;\n/**\n * Represents a two-dimensional vector.\n */\nexport declare class Vector2 implements Type, WebGLConvertible {\n    static readonly symbol: unique symbol;\n    static readonly zero: Vector2;\n    static readonly one: Vector2;\n    static readonly right: Vector2;\n    static readonly left: Vector2;\n    static readonly up: Vector2;\n    static readonly down: Vector2;\n    /**\n     * A constant equal to `Vector2(0, -1)`\n     */\n    static readonly top: Vector2;\n    /**\n     * A constant equal to `Vector2(0, 1)`\n     */\n    static readonly bottom: Vector2;\n    /**\n     * A constant equal to `Vector2(-1, -1)`\n     */\n    static readonly topLeft: Vector2;\n    /**\n     * A constant equal to `Vector2(1, -1)`\n     */\n    static readonly topRight: Vector2;\n    /**\n     * A constant equal to `Vector2(-1, 1)`\n     */\n    static readonly bottomLeft: Vector2;\n    /**\n     * A constant equal to `Vector2(1, 1)`\n     */\n    static readonly bottomRight: Vector2;\n    x: number;\n    y: number;\n    static createSignal(initial?: SignalValue<PossibleVector2>, interpolation?: InterpolationFunction<Vector2>, owner?: any): Vector2Signal<void>;\n    static lerp(from: Vector2, to: Vector2, value: number | Vector2): Vector2;\n    static arcLerp(from: Vector2, to: Vector2, value: number, reverse?: boolean, ratio?: number): Vector2;\n    static createArcLerp(reverse?: boolean, ratio?: number): (from: Vector2, to: Vector2, value: number) => Vector2;\n    /**\n     * Interpolates between two vectors on the polar plane by interpolating\n     * the angles and magnitudes of the vectors individually.\n     *\n     * @param from - The starting vector.\n     * @param to - The target vector.\n     * @param value - The t-value of the interpolation.\n     * @param counterclockwise - Whether the vector should get rotated\n     *                           counterclockwise. Defaults to `false`.\n     * @param origin - The center of rotation. Defaults to the origin.\n     *\n     * @remarks\n     * This function is useful when used in conjunction with {@link rotate} to\n     * animate an object's position on a circular arc (see examples).\n     *\n     * @example\n     * Animating an object in a circle around the origin\n     * ```tsx\n     * circle().position(\n     *   circle().position().rotate(180),\n     *   1,\n     *   easeInOutCubic,\n     *   Vector2.polarLerp\n     * );\n     * ```\n     * @example\n     * Rotating an object around the point `[-200, 100]`\n     * ```ts\n     * circle().position(\n     *   circle().position().rotate(180, [-200, 100]),\n     *   1,\n     *   easeInOutCubic,\n     *   Vector2.createPolarLerp(false, [-200, 100]),\n     * );\n     * ```\n     * @example\n     * Rotating an object counterclockwise around the origin\n     * ```ts\n     * circle().position(\n     *   circle().position().rotate(180),\n     *   1,\n     *   easeInOutCubic,\n     *   Vector2.createPolarLerp(true),\n     * );\n     * ```\n     */\n    static polarLerp(from: Vector2, to: Vector2, value: number, counterclockwise?: boolean, origin?: Vector2): Vector2;\n    /**\n     * Helper function to create a {@link Vector2.polarLerp} interpolation\n     * function with additional parameters.\n     *\n     * @param counterclockwise - Whether the point should get rotated\n     *                           counterclockwise.\n     * @param center - The center of rotation. Defaults to the origin.\n     */\n    static createPolarLerp(counterclockwise?: boolean, center?: PossibleVector2): (from: Vector2, to: Vector2, value: number) => Vector2;\n    static fromOrigin(origin: Origin | Direction): Vector2;\n    static fromScalar(value: number): Vector2;\n    static fromRadians(radians: number): Vector2;\n    static fromDegrees(degrees: number): Vector2;\n    /**\n     * Return the angle in radians between the vector described by x and y and the\n     * positive x-axis.\n     *\n     * @param x - The x component of the vector.\n     * @param y - The y component of the vector.\n     */\n    static radians(x: number, y: number): number;\n    /**\n     * Return the angle in degrees between the vector described by x and y and the\n     * positive x-axis.\n     *\n     * @param x - The x component of the vector.\n     * @param y - The y component of the vector.\n     *\n     * @remarks\n     * The returned angle will be between -180 and 180 degrees.\n     */\n    static degrees(x: number, y: number): number;\n    static magnitude(x: number, y: number): number;\n    static squaredMagnitude(x: number, y: number): number;\n    static angleBetween(u: Vector2, v: Vector2): number;\n    get width(): number;\n    set width(value: number);\n    get height(): number;\n    set height(value: number);\n    get magnitude(): number;\n    get squaredMagnitude(): number;\n    get normalized(): Vector2;\n    get safe(): Vector2;\n    get flipped(): Vector2;\n    get floored(): Vector2;\n    get rounded(): Vector2;\n    get ceiled(): Vector2;\n    get perpendicular(): Vector2;\n    /**\n     * Return the angle in radians between the vector and the positive x-axis.\n     */\n    get radians(): number;\n    /**\n     * Return the angle in degrees between the vector and the positive x-axis.\n     *\n     * @remarks\n     * The returned angle will be between -180 and 180 degrees.\n     */\n    get degrees(): number;\n    get ctg(): number;\n    constructor();\n    constructor(from: PossibleVector2);\n    constructor(x: number, y: number);\n    lerp(to: Vector2, value: Vector2 | number): Vector2;\n    getOriginOffset(origin: Origin | Direction): Vector2;\n    scale(value: number): Vector2;\n    transformAsPoint(matrix: PossibleMatrix2D): Vector2;\n    transform(matrix: PossibleMatrix2D): Vector2;\n    mul(possibleVector: PossibleVector2): Vector2;\n    div(possibleVector: PossibleVector2): Vector2;\n    add(possibleVector: PossibleVector2): Vector2;\n    sub(possibleVector: PossibleVector2): Vector2;\n    dot(possibleVector: PossibleVector2): number;\n    cross(possibleVector: PossibleVector2): number;\n    mod(possibleVector: PossibleVector2): Vector2;\n    /**\n     * Rotate the vector around a point by the provided angle.\n     *\n     * @param angle - The angle by which to rotate in degrees.\n     * @param center - The center of rotation. Defaults to the origin.\n     */\n    rotate(angle: number, center?: PossibleVector2): Vector2;\n    addX(value: number): Vector2;\n    addY(value: number): Vector2;\n    /**\n     * Transform the components of the vector.\n     *\n     * @example\n     * Raise the components to the power of 2.\n     * ```ts\n     * const vector = new Vector2(2, 3);\n     * const result = vector.transform(value => value ** 2);\n     * ```\n     *\n     * @param callback - A callback to apply to each component.\n     */\n    map(callback: (value: number, index: number) => number): Vector2;\n    toSymbol(): symbol;\n    toString(): string;\n    toArray(): number[];\n    toUniform(gl: WebGL2RenderingContext, location: WebGLUniformLocation): void;\n    serialize(): SerializedVector2;\n    /**\n     * Check if two vectors are exactly equal to each other.\n     *\n     * @remarks\n     * If you need to compensate for floating point inaccuracies, use the\n     * {@link equals} method, instead.\n     *\n     * @param other - The vector to compare.\n     */\n    exactlyEquals(other: Vector2): boolean;\n    /**\n     * Check if two vectors are equal to each other.\n     *\n     * @remarks\n     * This method allows passing an allowed error margin when comparing vectors\n     * to compensate for floating point inaccuracies. To check if two vectors are\n     * exactly equal, use the {@link exactlyEquals} method, instead.\n     *\n     * @param other - The vector to compare.\n     * @param threshold - The allowed error threshold when comparing the vectors.\n     */\n    equals(other: Vector2, threshold?: number): boolean;\n    [Symbol.iterator](): Generator<number, void, unknown>;\n}\n//# sourceMappingURL=Vector.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/types/index.d.ts", content: "/**\n * Complex types used in animations.\n *\n * @packageDocumentation\n */\nexport * from './BBox';\nexport * from './Canvas';\nexport * from './Color';\nexport * from './Matrix';\nexport * from './Matrix2D';\nexport * from './Origin';\nexport * from './Spacing';\nexport * from './Type';\nexport * from './Vector';\n//# sourceMappingURL=index.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/utils/DetailedError.d.ts", content: "import type { LogPayload } from '../app';\ntype DetailedErrorProps = Pick<LogPayload, 'message' | 'remarks' | 'object' | 'durationMs' | 'inspect'>;\nexport declare class DetailedError extends Error {\n    /**\n     * {@inheritDoc app.LogPayload.message}\n     */\n    readonly remarks?: string;\n    /**\n     * {@inheritDoc app.LogPayload.object}\n     */\n    readonly object?: any;\n    /**\n     * {@inheritDoc app.LogPayload.durationMs}\n     */\n    readonly durationMs?: number;\n    /**\n     * {@inheritDoc app.LogPayload.inspect}\n     */\n    readonly inspect?: string;\n    constructor(message: string, remarks?: string);\n    constructor(props: DetailedErrorProps);\n}\nexport {};\n//# sourceMappingURL=DetailedError.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/utils/ExperimentalError.d.ts", content: "import type { LogPayload } from '../app';\nimport { DetailedError } from './DetailedError';\ntype ExperimentalErrorProps = Pick<LogPayload, 'message' | 'remarks' | 'object' | 'durationMs' | 'inspect'>;\nexport declare class ExperimentalError extends DetailedError {\n    constructor(message: string, remarks?: string);\n    constructor(props: ExperimentalErrorProps);\n}\nexport {};\n//# sourceMappingURL=ExperimentalError.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/utils/Semaphore.d.ts", content: "/**\n * A simple semaphore implementation with a capacity of 1.\n *\n * @internal\n */\nexport declare class Semaphore {\n    private resolveCurrent;\n    private current;\n    acquire(): Promise<void>;\n    release(): void;\n}\n//# sourceMappingURL=Semaphore.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/utils/beginSlide.d.ts", content: "import type { ThreadGenerator } from '../threading';\nexport declare function beginSlide(name: string): ThreadGenerator;\n//# sourceMappingURL=beginSlide.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/utils/capitalize.d.ts", content: "export declare function capitalize<T extends string>(value: T): Capitalize<T>;\n//# sourceMappingURL=capitalize.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/utils/createRef.d.ts", content: "export interface ReferenceReceiver<T> {\n    (reference: T): void;\n}\nexport interface Reference<T> extends ReferenceReceiver<T> {\n    (): T;\n}\nexport declare function createRef<T>(): Reference<T>;\nexport declare function makeRef<TObject, TKey extends keyof TObject>(object: TObject, key: TKey): ReferenceReceiver<TObject[TKey]>;\nexport type RefsProperty<TValue> = TValue extends (config: {\n    refs?: infer TReference;\n}) => void ? TReference : never;\nexport declare function makeRefs<T extends (config: {\n    refs?: any;\n}) => void>(): RefsProperty<T>;\n//# sourceMappingURL=createRef.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/utils/createRefArray.d.ts", content: "import { Reference } from './createRef';\nexport type ReferenceArray<T> = T[] & Reference<T>;\n/**\n * Create an array of references.\n *\n * @remarks\n * The returned object is both an array and a reference that can be passed\n * directly to the `ref` property of a node.\n *\n * @example\n * ```tsx\n * const labels = createRefArray<Txt>();\n *\n * view.add(['A', 'B'].map(text => <Txt ref={labels}>{text}</Txt>));\n * view.add(<Txt ref={labels}>C</Txt>);\n *\n * // accessing the references individually:\n * yield* labels[0].text('A changes', 0.3);\n * yield* labels[1].text('B changes', 0.3);\n * yield* labels[2].text('C changes', 0.3);\n *\n * // accessing all references at once:\n * yield* all(...labels.map(label => label.fill('white', 0.3)));\n * ```\n */\nexport declare function createRefArray<T>(): ReferenceArray<T>;\n//# sourceMappingURL=createRefArray.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/utils/createRefMap.d.ts", content: "import { Reference } from './createRef';\nexport type ReferenceMap<T> = Map<string, Reference<T>> & Record<string, Reference<T>> & {\n    /**\n     * Maps the references in this group to a new array.\n     *\n     * @param callback - The function to transform each reference.\n     *\n     * @returns An array of the transformed references.\n     */\n    mapRefs<TValue>(callback: (value: T, index: number) => TValue): TValue[];\n};\n/**\n * Create a group of references.\n *\n * @remarks\n * The returned object lets you easily create multiple references to the same\n * type without initializing them individually.\n *\n * You can retrieve references by accessing the object's properties. If the\n * reference for a given property does not exist, it will be created\n * automatically.\n *\n * @example\n * ```tsx\n * const labels = createRefMap<Txt>();\n *\n * view.add(\n *   <>\n *     <Txt ref={labels.a}>A</Txt>\n *     <Txt ref={labels.b}>B</Txt>\n *     <Txt ref={labels.c}>C</Txt>\n *   </>,\n * );\n *\n * // accessing the references individually:\n * yield* labels.a().text('A changes', 0.3);\n * yield* labels.b().text('B changes', 0.3);\n * yield* labels.c().text('C changes', 0.3);\n *\n * // checking if the given reference exists:\n * if ('d' in labels) {\n *   yield* labels.d().text('D changes', 0.3);\n * }\n *\n * // accessing all references at once:\n * yield* all(...labels.mapRefs(label => label.fill('white', 0.3)));\n * ```\n */\nexport declare function createRefMap<T>(): ReferenceMap<T>;\n//# sourceMappingURL=createRefMap.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/utils/debug.d.ts", content: "/**\n * Logs a debug message with an arbitrary payload.\n *\n * @remarks\n * This method is a shortcut for calling `useLogger().debug()` which allows\n * you to more easily log non-string values as well.\n *\n * @example\n * ```ts\n * export default makeScene2D(function* (view) {\n *   const circle = createRef<Circle>();\n *\n *   view.add(\n *     <Circle ref={circle} width={320} height={320} fill={'lightseagreen'} />,\n *   );\n *\n *   debug(circle().position());\n * });\n * ```\n *\n * @param payload - The payload to log\n */\nexport declare function debug(payload: any): void;\n//# sourceMappingURL=debug.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/utils/deprecate.d.ts", content: "/**\n * Mark the given function as deprecated.\n *\n * @param fn - The function to deprecate.\n * @param message - The log message.\n * @param remarks - The optional log remarks.\n */\nexport declare function deprecate<TArgs extends any[], TReturn>(fn: (...args: TArgs) => TReturn, message: string, remarks?: string): (...args: TArgs) => TReturn;\n//# sourceMappingURL=deprecate.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/utils/errorToLog.d.ts", content: "import type { LogPayload } from '../app';\nexport declare function errorToLog(error: any): LogPayload;\n//# sourceMappingURL=errorToLog.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/utils/experimentalLog.d.ts", content: "import { LogPayload } from '../app';\nexport declare function experimentalLog(message: string, remarks?: string): LogPayload;\n//# sourceMappingURL=experimentalLog.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/utils/getContext.d.ts", content: "export declare function getContext(options?: CanvasRenderingContext2DSettings, canvas?: HTMLCanvasElement): CanvasRenderingContext2D;\n//# sourceMappingURL=getContext.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/utils/index.d.ts", content: "/**\n * General utilities and helper functions.\n *\n * @packageDocumentation\n */\nexport * from './DetailedError';\nexport * from './ExperimentalError';\nexport * from './Semaphore';\nexport * from './beginSlide';\nexport * from './capitalize';\nexport * from './createRef';\nexport * from './createRefArray';\nexport * from './createRefMap';\nexport * from './debug';\nexport * from './deprecate';\nexport * from './errorToLog';\nexport * from './experimentalLog';\nexport * from './getContext';\nexport * from './math';\nexport * from './proxyUtils';\nexport * from './range';\nexport * from './useContext';\nexport * from './useDuration';\nexport * from './usePlayback';\nexport * from './useRandom';\nexport * from './useScene';\nexport * from './useThread';\nexport * from './useTime';\n//# sourceMappingURL=index.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/utils/math.d.ts", content: "/**\n * A constant for converting radians to degrees\n *\n * @example\n * const degrees = 0.6 * RAD2DEG;\n */\nexport declare const RAD2DEG: number;\n/**\n * A constant for converting degrees to radians\n *\n * @example\n * const radians = 30 * DEG2RAD;\n */\nexport declare const DEG2RAD: number;\n//# sourceMappingURL=math.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/utils/proxyUtils.d.ts", content: "/**\n * Utility to redirect remote sources via Proxy\n *\n * This utility is used to rewrite a request to be routed through\n * the Proxy instead.\n */\n/**\n * Route the given url through a local proxy.\n *\n * @example\n * This rewrites a remote url like `https://via.placeholder.com/300.png/09f/fff`\n * into a URI-Component-Encoded string like\n * `/cors-proxy/https%3A%2F%2Fvia.placeholder.com%2F300.png%2F09f%2Ffff`\n */\nexport declare function viaProxy(url: string): string;\n/**\n * Check if the proxy is enabled via the plugin by checking\n * for `import.meta.env.VITE_MC_PROXY_ENABLED`\n *\n * @remarks The value can either be 'true' of 'false'\n * (as strings) if present, or be undefined if not run\n * from a vite context or run without the MC Plugin.\n */\nexport declare function isProxyEnabled(): boolean;\n//# sourceMappingURL=proxyUtils.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/utils/range.d.ts", content: "/**\n * Create an array containing a range of numbers.\n *\n * @example\n * ```ts\n * const array1 = range(3); // [0, 1, 2]\n * const array2 = range(-3); // [0, -1, -2]\n * ```\n *\n * @param length - The length of the array.\n */\nexport declare function range(length: number): number[];\n/**\n * Create an array containing a range of numbers.\n *\n * @example\n * ```ts\n * const array1 = range(3, 7); // [3, 4, 5, 6]\n * const array2 = range(7, 3); // [7, 6, 5, 4]\n * ```\n *\n * @param from - The start of the range.\n * @param to - The end of the range. `to` itself is not included in the result.\n */\nexport declare function range(from: number, to: number): number[];\n/**\n * Create an array containing a range of numbers.\n *\n * @example\n * ```ts\n * const array1 = range(1, 2, 0.25); // [1, 1.25, 1.5, 1.75]\n * const array2 = range(2, 1, -0.25); // [2, 1.75, 1.5, 1.25]\n * ```\n *\n * @param from - The start of the range.\n * @param to - The end of the range. `to` itself is not included in the result.\n * @param step - The value by which to increment or decrement.\n */\nexport declare function range(from: number, to: number, step: number): number[];\n//# sourceMappingURL=range.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/utils/useContext.d.ts", content: "/**\n * Provide a function to access the Context2D before the scene is rendered.\n *\n * @param callback - The function that will be provided the context before render.\n */\nexport declare function useContext(callback: (ctx: CanvasRenderingContext2D) => void): () => void;\n/**\n * Provide a function to access the Context2D after the scene is rendered.\n *\n * @param callback - The function that will be provided the context after render.\n */\nexport declare function useContextAfter(callback: (ctx: CanvasRenderingContext2D) => void): () => void;\n//# sourceMappingURL=useContext.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/utils/useDuration.d.ts", content: "/**\n * Register a time event and get its duration in seconds.\n *\n * @remarks\n * This can be used to better specify when an animation should start\n * as well as how long this animation should take\n *\n * @example\n * ```ts\n * export default makeScene2D(function* (view) {\n *   const circle = createRef<Circle>();\n *\n *   view.add(\n *     <Circle ref={circle} width={320} height={320} fill={'lightseagreen'} />,\n *   );\n *\n *   yield* circle().scale(2, useDuration('circleGrow'));\n * });\n * ```\n *\n * @param name - The name of the event.\n *\n * @returns The duration of the event in seconds.\n */\nexport declare function useDuration(name: string): number;\n//# sourceMappingURL=useDuration.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/utils/usePlayback.d.ts", content: "import { PlaybackStatus } from '../app';\n/**\n * Get a reference to the playback status.\n */\nexport declare function usePlayback(): PlaybackStatus;\nexport declare function startPlayback(playback: PlaybackStatus): void;\nexport declare function endPlayback(playback: PlaybackStatus): void;\n//# sourceMappingURL=usePlayback.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/utils/useRandom.d.ts", content: "import { Random } from '../scenes';\n/**\n * Get the random number generator for the current scene.\n **/\nexport declare function useRandom(): Random;\n/**\n * Get the random number generator for the given seed.\n *\n * @param seed - The seed for the generator.\n * @param fixed - Whether the seed should be fixed. Fixed seeds remain\n *                the same even when the main scene seed changes.\n */\nexport declare function useRandom(seed: number, fixed?: boolean): Random;\n//# sourceMappingURL=useRandom.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/utils/useScene.d.ts", content: "import type { Scene } from '../scenes';\n/**\n * Get a reference to the current scene.\n */\nexport declare function useScene(): Scene;\nexport declare function startScene(scene: Scene): void;\nexport declare function endScene(scene: Scene): void;\nexport declare function useLogger(): Console | import(\"..\").Logger;\n/**\n * Mark the current scene as ready to transition out.\n *\n * @remarks\n * Usually used together with transitions. When a scene is marked as finished,\n * the transition will start but the scene generator will continue running.\n */\nexport declare function finishScene(): void;\n//# sourceMappingURL=useScene.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/utils/useThread.d.ts", content: "import type { Thread } from '../threading';\n/**\n * Get a reference to the current thread.\n */\nexport declare function useThread(): Thread;\nexport declare function startThread(thread: Thread): void;\nexport declare function endThread(thread: Thread): void;\n//# sourceMappingURL=useThread.d.ts.map" },
  { path: "node_modules/@motion-canvas/core/lib/utils/useTime.d.ts", content: "/**\n * Get the real time since the start of the animation.\n *\n * @remarks\n * The returned value accounts for offsets caused by functions such as\n * {@link flow.waitFor}.\n *\n * @example\n * ```ts\n * // current time: 0s\n * yield* waitFor(0.02);\n *\n * // current time: 0.016(6)s\n * // real time: 0.02s\n * const realTime = useTime();\n * ```\n */\nexport declare function useTime(): number;\n//# sourceMappingURL=useTime.d.ts.map" },
  { path: "node_modules/d3-geo/package.json", content: "{\"name\":\"d3-geo\",\"types\":\"./index.d.ts\"}" },
  { path: "node_modules/d3-geo/index.d.ts", content: "// Last module patch version validated against: 3.0.1\n\nimport * as GeoJSON from \"geojson\";\n\n// ----------------------------------------------------------------------\n// Shared Interfaces and Types\n// ----------------------------------------------------------------------\n\n/**\n * A basic geometry for a sphere, which is supported by d3-geo\n * beyond the GeoJSON geometries.\n */\nexport interface GeoSphere {\n    /**\n     * Sphere geometry type\n     */\n    type: \"Sphere\";\n}\n\n/**\n * Type Alias for GeoJSON Geometry Object and GeoSphere additional\n * geometry supported by d3-geo\n */\nexport type GeoGeometryObjects = GeoJSON.GeometryObject | GeoSphere;\n\n/**\n * A GeoJSON-style GeometryCollection which supports GeoJSON geometry objects\n * and additionally GeoSphere.\n *\n * The generic refers to the type(s) of d3-geo geometry objects contained in the collection.\n */\nexport interface ExtendedGeometryCollection<GeometryType extends GeoGeometryObjects = GeoGeometryObjects> {\n    type: string;\n    bbox?: number[] | undefined;\n    crs?: {\n        type: string;\n        properties: any;\n    } | undefined;\n    geometries: GeometryType[];\n}\n\n/**\n * A GeoJSON-style Feature which support features built on GeoJSON GeometryObjects\n * or GeoSphere.\n *\n * The first generic refers to the type(s) of d3-geo geometry objects underlying the ExtendedFeature.\n * Unless explicitly ruled out, the geometry value is nullable.\n *\n * The second generic refers to the data type of the properties of the ExtendedFeature. Unless explicitly ruled out,\n * the properties value is nullable.\n */\nexport interface ExtendedFeature<\n    GeometryType extends GeoGeometryObjects | null = GeoGeometryObjects | null,\n    Properties extends GeoJSON.GeoJsonProperties = GeoJSON.GeoJsonProperties,\n> extends GeoJSON.GeoJsonObject {\n    geometry: GeometryType;\n    properties: Properties;\n    id?: string | number | undefined;\n}\n\n/**\n * A GeoJSON-style FeatureCollection which supports GeoJSON features\n * and features built on GeoSphere\n *\n * The generic refers to the type of ExtendedFeature contained in the ExtendedFeatureCollection.\n */\nexport interface ExtendedFeatureCollection<FeatureType extends ExtendedFeature = ExtendedFeature>\n    extends GeoJSON.GeoJsonObject\n{\n    features: FeatureType[];\n}\n\n/**\n * Type Alias for permissible objects which can be used with d3-geo\n * methods\n */\nexport type GeoPermissibleObjects =\n    | GeoGeometryObjects\n    | ExtendedGeometryCollection\n    | ExtendedFeature\n    | ExtendedFeatureCollection;\n\n// ----------------------------------------------------------------------\n// Spherical Math\n// ----------------------------------------------------------------------\n\n/**\n * Returns the spherical area of the specified GeoJSON object in steradians.\n * This is the spherical equivalent of path.area.\n */\nexport function geoArea(\n    object: ExtendedFeature | ExtendedFeatureCollection | GeoGeometryObjects | ExtendedGeometryCollection,\n): number;\n\n/**\n * Returns the spherical bounding box for the specified GeoJSON object.\n * The bounding box is represented by a two-dimensional array: [[left, bottom], [right, top]],\n * where left is the minimum longitude, bottom is the minimum latitude, right is maximum longitude, and top is the maximum latitude.\n * All coordinates are given in degrees.\n * (Note that in projected planar coordinates, the minimum latitude is typically the maximum y-value, and the maximum latitude is typically the minimum y-value.)\n * This is the spherical equivalent of path.bounds.\n */\nexport function geoBounds(\n    object: ExtendedFeature | ExtendedFeatureCollection | GeoGeometryObjects | ExtendedGeometryCollection,\n): [[number, number], [number, number]];\n\n/**\n * Returns the spherical centroid of the specified GeoJSON object.\n * This is the spherical equivalent of path.centroid.\n */\nexport function geoCentroid(\n    object: ExtendedFeature | ExtendedFeatureCollection | GeoGeometryObjects | ExtendedGeometryCollection,\n): [number, number];\n\n/**\n * Returns true if and only if the specified GeoJSON object contains the specified point, or false if the object does not contain the point.\n * The point must be specified as a two-element array [longitude, latitude] in degrees.\n * For Point and MultiPoint geometries, an exact test is used; for a Sphere, true is always returned; for other geometries, an epsilon threshold is applied.\n */\nexport function geoContains(\n    object: ExtendedFeature | ExtendedFeatureCollection | GeoGeometryObjects | ExtendedGeometryCollection,\n    point: [number, number],\n): boolean;\n\n/**\n * Returns the great-arc distance in radians between the two points a and b.\n * Each point must be specified as a two-element array [longitude, latitude] in degrees.\n *\n * @param a Point specified as a two-element array [longitude, latitude] in degrees.\n * @param b Point specified as a two-element array [longitude, latitude] in degrees.\n */\nexport function geoDistance(a: [number, number], b: [number, number]): number;\n\n/**\n * Returns the great-arc length of the specified GeoJSON object in radians.\n * For polygons, returns the perimeter of the exterior ring plus that of any interior rings.\n * This is the spherical equivalent of path.measure.\n */\nexport function geoLength(\n    object: ExtendedFeature | ExtendedFeatureCollection | GeoGeometryObjects | ExtendedGeometryCollection,\n): number;\n\n/**\n * Returns an interpolator function given two points a and b.\n * Each point must be specified as a two-element array [longitude, latitude] in degrees.\n *\n * @param a Point specified as a two-element array [longitude, latitude] in degrees.\n * @param b Point specified as a two-element array [longitude, latitude] in degrees.\n */\nexport function geoInterpolate(a: [number, number], b: [number, number]): (t: number) => [number, number];\n\n/**\n * A Geo Rotation\n */\nexport interface GeoRotation {\n    /**\n     * Returns a new array [longitude, latitude] in degrees representing the rotated point of the given point.\n     *\n     * @param point The point must be specified as a two-element array [longitude, latitude] in degrees.\n     */\n    (point: [number, number]): [number, number];\n\n    /**\n     * Returns a new array [longitude, latitude] in degrees representing the point of the given rotated point; the inverse of rotation.\n     *\n     * @param point The rotated point must be specified as a two-element array [longitude, latitude] in degrees.\n     */\n    invert(point: [number, number]): [number, number];\n}\n\n/**\n * Returns a rotation function for the given angles.\n *\n * @param angles  A two- or three-element array of numbers [lambda, phi, gamma] specifying the rotation angles in degrees about each spherical axis.\n * (These correspond to yaw, pitch and roll.) If the rotation angle gamma is omitted, it defaults to 0.\n */\nexport function geoRotation(angles: [number, number] | [number, number, number]): GeoRotation;\n\n// ----------------------------------------------------------------------\n// Spherical Shapes\n// ----------------------------------------------------------------------\n\n// geoCircle ============================================================\n\n/**\n * A new circle generator\n *\n * The first generic corresponds to the \"this\"-context within which the geo circle generator will be invoked.\n *\n * The second generic corresponds to the type of the Datum which will be passed into the geo circle generator.\n */\nexport interface GeoCircleGenerator<This = any, Datum = any> {\n    /**\n     * Returns a new GeoJSON geometry object of type “Polygon” approximating a circle on the surface of a sphere,\n     * with the current center, radius and precision. Any arguments are passed to the accessors.\n     */\n    (this: This, d?: Datum, ...args: any[]): GeoJSON.Polygon;\n\n    /**\n     * Returns the current center accessor, which defaults to a function returning [0, 0].\n     */\n    center(): (this: This, d: Datum, ...args: any[]) => [number, number];\n    /**\n     * Sets the circle center to the specified point [longitude, latitude] in degrees, and returns this circle generator.\n     * The center may also be specified as a function; this function will be invoked whenever a circle is generated, being passed any arguments passed to the circle generator.\n     */\n    center(center: [number, number] | ((this: This, d: Datum, ...args: any[]) => [number, number])): this;\n\n    /**\n     * Returns the current radius accessor, which defaults to a function returning 90.\n     */\n    radius(): (this: This, d: Datum, ...args: any[]) => number;\n    /**\n     * Sets the circle radius to the specified angle in degrees, and returns this circle generator.\n     * The radius may also be specified as a function; this function will be invoked whenever a circle is generated, being passed any arguments passed to the circle generator.\n     */\n    radius(radius: number | ((this: This, d: Datum, ...args: any[]) => number)): this;\n\n    /**\n     * Returns the current precision accessor, which defaults to a function returning 6.\n     */\n    precision(): (this: This, d: Datum, ...args: any[]) => number;\n    /**\n     * Sets the circle precision to the specified angle in degrees, and returns this circle generator.\n     * The precision may also be specified as a function; this function will be invoked whenever a circle is generated, being passed any arguments passed to the circle generator.\n     */\n    precision(precision: number | ((this: This, d: Datum, ...args: any[]) => number)): this;\n}\n\n/**\n * Returns a new geo circle generator\n */\nexport function geoCircle(): GeoCircleGenerator;\n/**\n * Returns a new geo circle generator\n *\n * The generic corresponds to the data type of the first argument passed into the geo circle generator and its accessor functions.\n */\n// eslint-disable-next-line @definitelytyped/no-unnecessary-generics\nexport function geoCircle<Datum>(): GeoCircleGenerator<any, Datum>;\n/**\n * Returns a new geo circle generator\n *\n * The first generic corresponds to the \"this\" context within which the geo circle generator and its accessors will be invoked.\n *\n * The second generic corresponds to the data type of the first argument passed into the geo circle generator and its accessor functions.\n */\n// eslint-disable-next-line @definitelytyped/no-unnecessary-generics\nexport function geoCircle<This, Datum>(): GeoCircleGenerator<This, Datum>;\n\n// geoGraticule ============================================================\n\n/**\n * A Feature generator for graticules: a uniform grid of meridians and parallels for showing projection distortion.\n * The default graticule has meridians and parallels every 10° between ±80° latitude; for the polar regions, there are meridians every 90°.\n */\nexport interface GeoGraticuleGenerator {\n    /**\n     * Returns a GeoJSON MultiLineString geometry object representing all meridians and parallels for this graticule.\n     */\n    (): GeoJSON.MultiLineString;\n\n    /**\n     * Returns an array of GeoJSON LineString geometry objects, one for each meridian or parallel for this graticule.\n     */\n    lines(): GeoJSON.LineString[];\n\n    /**\n     * Returns a GeoJSON Polygon geometry object representing the outline of this graticule, i.e. along the meridians and parallels defining its extent.\n     */\n    outline(): GeoJSON.Polygon;\n\n    /**\n     * Returns the current minor extent, which defaults to ⟨⟨-180°, -80° - ε⟩, ⟨180°, 80° + ε⟩⟩.\n     */\n    extent(): [[number, number], [number, number]];\n    /**\n     * Sets the major and minor extents of this graticule.\n     *\n     * @param extent Extent to use for major and minor extent of graticule.\n     */\n    extent(extent: [[number, number], [number, number]]): this;\n\n    /**\n     * Returns the current major extent, which defaults to ⟨⟨-180°, -90° + ε⟩, ⟨180°, 90° - ε⟩⟩.\n     */\n    extentMajor(): [[number, number], [number, number]];\n    /**\n     * Sets the major extent of this graticule.\n     *\n     * @param extent Major extent of graticule.\n     */\n    extentMajor(extent: [[number, number], [number, number]]): this;\n\n    /**\n     * Returns the current minor extent, which defaults to  ⟨⟨-180°, -80° - ε⟩, ⟨180°, 80° + ε⟩⟩.\n     */\n    extentMinor(): [[number, number], [number, number]];\n    /**\n     * Sets the minor extent of this graticule.\n     *\n     * @param extent Minor extent of graticule.\n     */\n    extentMinor(extent: [[number, number], [number, number]]): this;\n\n    /**\n     * Returns the current minor step, which defaults to ⟨10°, 10°⟩.\n     */\n    step(): [number, number];\n    /**\n     * Sets the major and minor step for this graticule\n     *\n     * @param step Major and minor step to use for this graticule.\n     */\n    step(step: [number, number]): this;\n\n    /**\n     * Returns the current major step, which defaults to ⟨90°, 360°⟩.\n     */\n    stepMajor(): [number, number];\n    /**\n     * Sets the major step for this graticule.\n     *\n     * @param step Major step.\n     */\n    stepMajor(step: [number, number]): this;\n\n    /**\n     * Returns the current major step, which defaults to ⟨10°, 10°⟩.\n     */\n    stepMinor(): [number, number];\n    /**\n     * Sets the minor step for this graticule.\n     *\n     * @param step Minor step.\n     */\n    stepMinor(step: [number, number]): this;\n\n    /**\n     * Returns the current precision, which defaults to 2.5°.\n     */\n    precision(): number;\n    /**\n     * Sets the precision for this graticule, in degrees.\n     *\n     * @param angle Precision in degrees.\n     */\n    precision(angle: number): this;\n}\n\n/**\n * Constructs a feature generator for creating graticules: a uniform grid of meridians and parallels for showing projection distortion.\n * The default graticule has meridians and parallels every 10° between ±80° latitude; for the polar regions, there are meridians every 90°.\n */\nexport function geoGraticule(): GeoGraticuleGenerator;\n\n/**\n * A convenience method for directly generating the default 10° global graticule as a GeoJSON MultiLineString geometry object.\n */\nexport function geoGraticule10(): GeoJSON.MultiLineString;\n\n// ----------------------------------------------------------------------\n// Projections\n// ----------------------------------------------------------------------\n\n/**\n * A D3 geo stream. D3 transforms geometry using a sequence of function calls, rather than materializing intermediate representations, to minimize overhead.\n * Streams must implement several methods to receive input geometry. Streams are inherently stateful; the meaning of a point depends on whether the point is inside of a line,\n * and likewise a line is distinguished from a ring by a polygon. Despite the name “stream”, these method calls are currently synchronous.\n */\nexport interface GeoStream {\n    /**\n     * Indicates the end of a line or ring. Within a polygon, indicates the end of a ring.\n     * Unlike GeoJSON, the redundant closing coordinate of a ring is not indicated via point, and instead is implied via lineEnd within a polygon.\n     */\n    lineEnd(): void;\n\n    /**\n     * Indicates the start of a line or ring. Within a polygon, indicates the start of a ring. The first ring of a polygon is the exterior ring, and is typically clockwise.\n     * Any subsequent rings indicate holes in the polygon, and are typically counterclockwise.\n     */\n    lineStart(): void;\n\n    /**\n     * Indicates a point with the specified coordinates x and y (and optionally z). The coordinate system is unspecified and implementation-dependent;\n     * for example, projection streams require spherical coordinates in degrees as input. Outside the context of a polygon or line,\n     * a point indicates a point geometry object (Point or MultiPoint). Within a line or polygon ring, the point indicates a control point.\n     *\n     * @param x x-coordinate of point.\n     * @param y y-coordinate of point.\n     * @param z Optional z-coordinate of point.\n     */\n    point(x: number, y: number, z?: number): void;\n\n    /**\n     * Indicates the end of a polygon.\n     */\n    polygonEnd(): void;\n\n    /**\n     * Indicates the start of a polygon. The first line of a polygon indicates the exterior ring, and any subsequent lines indicate interior holes.\n     */\n    polygonStart(): void;\n\n    /**\n     * Indicates the sphere (the globe; the unit sphere centered at ⟨0,0,0⟩).\n     */\n    sphere?(): void;\n}\n\n// geoStream(...) =======================================================\n\n/**\n * Streams the specified GeoJSON object to the specified projection stream.\n * While both features and geometry objects are supported as input, the stream interface only describes the geometry, and thus additional feature properties are not visible to streams.\n */\nexport function geoStream(\n    object: ExtendedFeature | ExtendedFeatureCollection | GeoGeometryObjects | ExtendedGeometryCollection,\n    stream: GeoStream,\n): void;\n\n// ----------------------------------------------------------------------\n// Projections\n// ----------------------------------------------------------------------\n\n/**\n * Raw projections are point transformation functions that are used to implement custom projections; they typically passed to d3.geoProjection or d3.geoProjectionMutator.\n * They are exposed here to facilitate the derivation of related projections.\n * Raw projections take spherical coordinates [lambda, phi] in radians (not degrees!) and return a point [x, y], typically in the unit square centered around the origin.\n */\nexport interface GeoRawProjection {\n    /**\n     * Projects the specified point [lambda, phi] in radians, returning a new point [x, y] in unitless coordinates.\n     * @param lambda Spherical lambda coordinate in radians.\n     * @param phi Spherical phi coordinate in radians.\n     */\n    (lambda: number, phi: number): [number, number];\n\n    /**\n     * Inverts the projected point [x, y] in unitless coordinates, returning an unprojected point in spherical coordinates [lambda, phi] in radians.\n     * @param x x-coordinate (unitless).\n     * @param y y-coordinate (unitless).\n     */\n    invert?(x: number, y: number): [number, number];\n}\n\n/**\n * An object implementing a stream method\n */\nexport interface GeoStreamWrapper {\n    /**\n     * Returns a projection stream for the specified output stream. Any input geometry is projected before being streamed to the output stream.\n     * A typical projection involves several geometry transformations: the input geometry is first converted to radians, rotated on three axes,\n     * clipped to the small circle or cut along the antimeridian, and lastly projected to the plane with adaptive resampling, scale and translation.\n     *\n     * @param stream An input stream\n     */\n    stream(stream: GeoStream): GeoStream;\n}\n\n/**\n * A Geographic Projection to transform spherical polygonal geometry to planar polygonal geometry.\n * D3 provides implementations of several classes of standard projections:\n *\n * - Azimuthal\n * - Composite\n * - Conic\n * - Cylindrical\n *\n * For many more projections, see d3-geo-projection. You can implement custom projections using d3.geoProjection or d3.geoProjectionMutator.\n */\nexport interface GeoProjection extends GeoStreamWrapper {\n    /**\n     * Returns a new array [x, y] (typically in pixels) representing the projected point of the given point.\n     * The point must be specified as a two-element array [longitude, latitude] in degrees.\n     * May return null if the specified point has no defined projected position, such as when the point is outside the clipping bounds of the projection.\n     *\n     * @param point A point specified as a two-dimensional array [longitude, latitude] in degrees.\n     */\n    (point: [number, number]): [number, number] | null;\n\n    /**\n     * Returns a new array [longitude, latitude] in degrees representing the unprojected point of the given projected point.\n     * May return null if the specified point has no defined projected position, such as when the point is outside the clipping bounds of the projection.\n     *\n     * @param point The projected point, specified as a two-element array [x, y] (typically in pixels).\n     */\n    invert?(point: [number, number]): [number, number] | null;\n\n    /**\n     * Returns the current spherical clipping function.\n     * Pre-clipping occurs in geographic coordinates. Cutting along the antimeridian line,\n     * or clipping along a small circle are the most common strategies.\n     */\n    preclip(): (stream: GeoStream) => GeoStream;\n    /**\n     * Sets the projection’s spherical clipping to the specified function and returns the projection.\n     * Pre-clipping occurs in geographic coordinates. Cutting along the antimeridian line, or clipping along a small circle are the most common strategies.\n     *\n     * @param preclip A spherical clipping function. Clipping functions are implemented as transformations of a projection stream.\n     * Pre-clipping operates on spherical coordinates, in radians.\n     */\n    preclip(preclip: (stream: GeoStream) => GeoStream): this;\n\n    /**\n     * Returns the current cartesian clipping function.\n     * Post-clipping occurs on the plane, when a projection is bounded to a certain extent such as a rectangle.\n     */\n    postclip(): (stream: GeoStream) => GeoStream;\n    /**\n     * Sets the projection’s cartesian clipping to the specified function and returns the projection.\n     *\n     * @param postclip A cartesian clipping function. Clipping functions are implemented as transformations of a projection stream.\n     * Post-clipping operates on planar coordinates, in pixels.\n     */\n    postclip(postclip: (stream: GeoStream) => GeoStream): this;\n\n    /**\n     * Returns the current clip angle which defaults to null.\n     *\n     * null switches to antimeridian cutting rather than small-circle clipping.\n     */\n    clipAngle(): number | null;\n    /**\n     * Sets the projection’s clipping circle radius to the specified angle in degrees and returns the projection.\n     * If angle is null, switches to antimeridian cutting rather than small-circle clipping.\n     */\n    clipAngle(angle: null | number): this;\n\n    /**\n     * Returns the current viewport clip extent which defaults to null.\n     */\n    clipExtent(): [[number, number], [number, number]] | null;\n    /**\n     * Sets the projection’s viewport clip extent to the specified bounds in pixels and returns the projection.\n     * The extent bounds are specified as an array [[x₀, y₀], [x₁, y₁]], where x₀ is the left-side of the viewport, y₀ is the top, x₁ is the right and y₁ is the bottom.\n     * If extent is null, no viewport clipping is performed.\n     */\n    clipExtent(extent: null | [[number, number], [number, number]]): this;\n\n    /**\n     * Returns the current scale factor; the default scale is projection-specific.\n     *\n     * The scale factor corresponds linearly to the distance between projected points; however, absolute scale factors are not equivalent across projections.\n     */\n    scale(): number;\n    /**\n     * Sets the projection’s scale factor to the specified value and returns the projection.\n     * The scale factor corresponds linearly to the distance between projected points; however, absolute scale factors are not equivalent across projections.\n     *\n     * @param scale Scale factor to be used for the projection; the default scale is projection-specific.\n     */\n    scale(scale: number): this;\n\n    /**\n     * Returns the current translation offset which defaults to [480, 250] and places ⟨0°,0°⟩ at the center of a 960×500 area.\n     * The translation offset determines the pixel coordinates of the projection’s center.\n     */\n    translate(): [number, number];\n    /**\n     * Sets the projection’s translation offset to the specified two-element array [tx, ty] and returns the projection.\n     * The translation offset determines the pixel coordinates of the projection’s center. The default translation offset places ⟨0°,0°⟩ at the center of a 960×500 area.\n     *\n     * @param point A two-element array [tx, ty] specifying the translation offset. The default translation offset of defaults to [480, 250] places ⟨0°,0°⟩ at the center of a 960×500 area.\n     */\n    translate(point: [number, number]): this;\n\n    /**\n     * Returns the current center of the projection, which defaults to ⟨0°,0°⟩.\n     */\n    center(): [number, number];\n    /**\n     * Sets the projection’s center to the specified center,\n     * a two-element array of longitude and latitude in degrees and returns the projection.\n     * The default is ⟨0°,0°⟩.\n     *\n     * @param point A point specified as a two-dimensional array [longitude, latitude] in degrees.\n     */\n    center(point: [number, number]): this;\n\n    /**\n     * Returns the projection’s current angle, which defaults to 0°.\n     */\n    angle(): number;\n    /**\n     * Sets the projection’s post-projection planar rotation angle to the specified angle in degrees and returns the projection.\n     * @param angle The new rotation angle of the projection.\n     */\n    angle(angle: number): this;\n\n    /**\n     * Returns true if x-reflection is enabled, which defaults to false.\n     */\n    reflectX(): boolean;\n    /**\n     * Sets whether or not the x-dimension is reflected (negated) in the output.\n     * @param reflect Whether or not the x-dimension is reflected (negated) in the output.\n     */\n    reflectX(reflect: boolean): this;\n\n    /**\n     * Returns true if y-reflection is enabled, which defaults to false.\n     */\n    reflectY(): boolean;\n    /**\n     * Sets whether or not the y-dimension is reflected (negated) in the output.\n     * @param reflect Whether or not the y-dimension is reflected (negated) in the output.\n     */\n    reflectY(reflect: boolean): this;\n\n    /**\n     * Returns the current rotation [lambda, phi, gamma] specifying the rotation angles in degrees about each spherical axis.\n     * (These correspond to yaw, pitch and roll.) which defaults [0, 0, 0].\n     */\n    rotate(): [number, number, number];\n\n    /**\n     * Sets the projection’s three-axis rotation to the specified angles, which must be a two- or three-element array of numbers.\n     *\n     * @param angles  A two- or three-element array of numbers [lambda, phi, gamma] specifying the rotation angles in degrees about each spherical axis.\n     * (These correspond to yaw, pitch and roll.) If the rotation angle gamma is omitted, it defaults to 0.\n     */\n    rotate(angles: [number, number] | [number, number, number]): this;\n\n    /**\n     * Returns the projection’s current resampling precision which defaults to square root of 0.5.\n     * This value corresponds to the Douglas–Peucker distance.\n     */\n    precision(): number;\n    /**\n     * Sets the threshold for the projection’s adaptive resampling to the specified value in pixels and returns the projection.\n     * This value corresponds to the Douglas–Peucker distance.\n     *\n     * @param precision A numeric value in pixels to use as the threshold for the projection’s adaptive resampling.\n     */\n    precision(precision: number): this;\n\n    /**\n     * Sets the projection’s scale and translate to fit the specified GeoJSON object in the center of the given extent.\n     * The extent is specified as an array [[x₀, y₀], [x₁, y₁]], where x₀ is the left side of the bounding box, y₀ is the top, x₁ is the right and y₁ is the bottom.\n     * Returns the projection.\n     */\n    fitExtent(\n        extent: [[number, number], [number, number]],\n        object: ExtendedFeature | ExtendedFeatureCollection | GeoGeometryObjects | ExtendedGeometryCollection,\n    ): this;\n\n    /**\n     * A convenience method for projection.fitExtent where the top-left corner of the extent is [0, 0].\n     */\n    fitSize(\n        size: [number, number],\n        object: ExtendedFeature | ExtendedFeatureCollection | GeoGeometryObjects | ExtendedGeometryCollection,\n    ): this;\n\n    /**\n     * A convenience method for projection.fitSize where the height is automatically chosen from the aspect ratio of object and the given constraint on width.\n     */\n    fitWidth(\n        width: number,\n        object: ExtendedFeature | ExtendedFeatureCollection | GeoGeometryObjects | ExtendedGeometryCollection,\n    ): this;\n\n    /**\n     * A convenience method for projection.fitSize where the width is automatically chosen from the aspect ratio of object and the given constraint on height.\n     */\n    fitHeight(\n        height: number,\n        object: ExtendedFeature | ExtendedFeatureCollection | GeoGeometryObjects | ExtendedGeometryCollection,\n    ): this;\n}\n\n/**\n * A Conic Projection\n */\nexport interface GeoConicProjection extends GeoProjection {\n    /**\n     * Return the standard parallels for the conic projection in degrees.\n     */\n    parallels(): [number, number];\n    /**\n     * Set the standard parallels for the conic projection in degrees and return the projection.\n     *\n     * @param value A two-dimensional array representing the standard parallels in degrees.\n     */\n    parallels(value: [number, number]): this;\n}\n\n// geoPath ==============================================================\n\n/**\n * A minimal rendering context for a GeoPath generator. The minimum implemented\n * methods are a subset of the CanvasRenderingContext2D API.\n *\n * For reference to the CanvasRenderingContext2D see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D\n */\nexport interface GeoContext {\n    /**\n     * Adds an arc to the path with center point (x, y) and radius r starting at startAngle and ending at endAngle.\n     * The arc is drawn in clockwise direction by default.\n     *\n     * @param x x-coordinate of arc center point.\n     * @param y y-coordinate of arc center point.\n     * @param radius Radius of arc.\n     * @param startAngle The starting angle of the arc, measured clockwise from the positive x axis and expressed in radians.\n     * @param endAngle The end angle of the arc, measured clockwise from the positive x axis and expressed in radians.\n     * @param anticlockwise Optional boolean flag, if true the arc is drawn counter-clockwise between the two angles.\n     */\n    arc(x: number, y: number, radius: number, startAngle: number, endAngle: number, anticlockwise?: boolean): void;\n\n    /**\n     * Start a new path by emptying the list of sub-paths.\n     */\n    beginPath(): void;\n\n    /**\n     * Causes the point of the pen to move back to the start of the current sub-path.\n     * It tries to draw a straight line from the current point to the start.\n     * If the shape has already been closed or has only one point, this function does nothing.\n     */\n    closePath(): void;\n\n    /**\n     * Connects the last point in the sub-path to the x, y coordinates with a straight line (but does not actually draw it).\n     *\n     * @param x The x-coordinate for the end of the line.\n     * @param y The y-coordinate for the end of the line.\n     */\n    lineTo(x: number, y: number): void;\n\n    /**\n     * Move the starting point of a new sub-path to the (x, y) coordinates.\n     *\n     * @param x The x-coordinate for the new starting point.\n     * @param y The y-coordinate for the new starting point.\n     */\n    moveTo(x: number, y: number): void;\n}\n\n/**\n * A Geo Path generator\n *\n * The first generic corresponds to the \"this\"-context within which the geo path generator will be invoked.\n * This could be e.g. the DOMElement bound to \"this\" when using selection.attr(\"d\", ...) with the path generator.\n *\n * The second generic corresponds to the type of the DatumObject which will be passed into the geo path generator for rendering.\n */\nexport interface GeoPath<This = any, DatumObject extends GeoPermissibleObjects = GeoPermissibleObjects> {\n    /**\n     * Renders the given object, which may be any GeoJSON feature or geometry object:\n     *\n     * + Point - a single position.\n     * + MultiPoint - an array of positions.\n     * + LineString - an array of positions forming a continuous line.\n     * + MultiLineString - an array of arrays of positions forming several lines.\n     * + Polygon - an array of arrays of positions forming a polygon (possibly with holes).\n     * + MultiPolygon - a multidimensional array of positions forming multiple polygons.\n     * + GeometryCollection - an array of geometry objects.\n     * + Feature - a feature containing one of the above geometry objects.\n     * + FeatureCollection - an array of feature objects.\n     *\n     * The type Sphere is also supported, which is useful for rendering the outline of the globe; a sphere has no coordinates.\n     *\n     * Any additional arguments are passed along to the pointRadius accessor.\n     *\n     * IMPORTANT: If the rendering context of the geoPath generator is null,\n     * then the geoPath is returned as an SVG path data string.\n     *\n     * Separate path elements are typically slower than a single path element. However, distinct path elements are useful for styling and interaction (e.g., click or mouseover).\n     * Canvas rendering (see path.context) is typically faster than SVG, but requires more effort to implement styling and interaction.\n     *\n     * The first generic type of the GeoPath generator used, must correspond to the \"this\" context bound to the function upon invocation.\n     *\n     * @param object An object to be rendered.\n     */\n    (this: This, object: DatumObject, ...args: any[]): string | null;\n    /**\n     * Renders the given object, which may be any GeoJSON feature or geometry object:\n     *\n     * + Point - a single position.\n     * + MultiPoint - an array of positions.\n     * + LineString - an array of positions forming a continuous line.\n     * + MultiLineString - an array of arrays of positions forming several lines.\n     * + Polygon - an array of arrays of positions forming a polygon (possibly with holes).\n     * + MultiPolygon - a multidimensional array of positions forming multiple polygons.\n     * + GeometryCollection - an array of geometry objects.\n     * + Feature - a feature containing one of the above geometry objects.\n     * + FeatureCollection - an array of feature objects.\n     *\n     * The type Sphere is also supported, which is useful for rendering the outline of the globe; a sphere has no coordinates.\n     *\n     * Any additional arguments are passed along to the pointRadius accessor.\n     *\n     * IMPORTANT: If the geoPath generator has been configured with a rendering context,\n     * then the geoPath is rendered to this context as a sequence of path method calls and this function returns void.\n     *\n     * Separate path elements are typically slower than a single path element. However, distinct path elements are useful for styling and interaction (e.g., click or mouseover).\n     * Canvas rendering (see path.context) is typically faster than SVG, but requires more effort to implement styling and interaction.\n     *\n     * The first generic type of the GeoPath generator used, must correspond to the \"this\" context bound to the function upon invocation.\n     *\n     * @param object An object to be rendered.\n     */\n    (this: This, object: DatumObject, ...args: any[]): void;\n\n    /**\n     * Returns the projected planar area (typically in square pixels) for the specified GeoJSON object.\n     * Point, MultiPoint, LineString and MultiLineString geometries have zero area. For Polygon and MultiPolygon geometries,\n     * this method first computes the area of the exterior ring, and then subtracts the area of any interior holes.\n     * This method observes any clipping performed by the projection; see projection.clipAngle and projection.clipExtent. This is the planar equivalent of d3.geoArea.\n     *\n     * @param object An object for which the area is to be calculated.\n     */\n    area(object: DatumObject): number;\n\n    /**\n     * Returns the projected planar bounding box (typically in pixels) for the specified GeoJSON object.\n     * The bounding box is represented by a two-dimensional array: [[x₀, y₀], [x₁, y₁]], where x₀ is the minimum x-coordinate, y₀ is the minimum y-coordinate,\n     * x₁ is maximum x-coordinate, and y₁ is the maximum y-coordinate.\n     *\n     * This is handy for, say, zooming in to a particular feature. (Note that in projected planar coordinates,\n     * the minimum latitude is typically the maximum y-value, and the maximum latitude is typically the minimum y-value.)\n     * This method observes any clipping performed by the projection; see projection.clipAngle and projection.clipExtent. This is the planar equivalent of d3.geoBounds.\n     *\n     * @param object An object for which the bounds are to be calculated.\n     */\n    bounds(object: DatumObject): [[number, number], [number, number]];\n\n    /**\n     * Returns the projected planar centroid (typically in pixels) for the specified GeoJSON object.\n     * This is handy for, say, labeling state or county boundaries, or displaying a symbol map.\n     * For example, a noncontiguous cartogram might scale each state around its centroid.\n     * This method observes any clipping performed by the projection; see projection.clipAngle and projection.clipExtent. This is the planar equivalent of d3.geoCentroid.\n     *\n     * @param object An object for which the centroid is to be calculated.\n     */\n    centroid(object: DatumObject): [number, number];\n\n    /**\n     * Returns the projected planar length (typically in pixels) for the specified GeoJSON object.\n     * Point and MultiPoint geometries have zero length. For Polygon and MultiPolygon geometries, this method computes the summed length of all rings.\n     *\n     * This method observes any clipping performed by the projection; see projection.clipAngle and projection.clipExtent. This is the planar equivalent of d3.geoLength.\n     *\n     * @param object An object for which the measure is to be calculated.\n     */\n    measure(object: DatumObject): number;\n\n    /**\n     * Returns the current render context which defaults to null.\n     *\n     * Use the generic to cast the return type of the rendering context, if it is known for a specific application.\n     */\n    // eslint-disable-next-line @definitelytyped/no-unnecessary-generics\n    context<C extends GeoContext | null>(): C;\n\n    /**\n     * sets the current render context and returns the path generator.\n     * If the context is null, then the path generator will return an SVG path string;\n     * if the context is non-null, the path generator will instead call methods on the specified context to render geometry.\n     */\n    context(context: null | GeoContext): this;\n\n    /**\n     * Get the current projection. The generic parameter can be used to cast the result to the\n     * correct, known type of the projection, e.g. GeoProjection or GeoConicProjection. Otherwise,\n     * the return type defaults to the minimum type requirement for a projection which\n     * can be passed into a GeoPath.\n     *\n     * Use the generic to cast the return type of the projection, if it is known for a specific application.\n     */\n    // eslint-disable-next-line @definitelytyped/no-unnecessary-generics\n    projection<P extends GeoConicProjection | GeoProjection | GeoStreamWrapper | null>(): P;\n\n    /**\n     * Sets the current projection to the specified projection.\n     * The null projection represents the identity transformation: the input geometry is not projected and is instead rendered directly in raw coordinates.\n     * This can be useful for fast rendering of pre-projected geometry, or for fast rendering of the equirectangular projection.\n     */\n    projection(projection: null | GeoProjection | GeoStreamWrapper): this;\n\n    /**\n     * Returns the current radius or radius accessor used to determine the radius for the display of Point and MultiPoint geometries.\n     * The default is a constant radius of 4.5.\n     */\n    pointRadius(): ((this: This, object: DatumObject, ...args: any[]) => number) | number;\n\n    /**\n     * Sets the radius used to display Point and MultiPoint geometries to the specified number.\n     * While the radius is commonly specified as a number constant, it may also be specified as a function which is computed per feature, being passed the any arguments passed to the path generator.\n     * For example, if your GeoJSON data has additional properties, you might access those properties inside the radius function to vary the point size;\n     * alternatively, you could d3.symbol and a projection for greater flexibility.\n     */\n    pointRadius(value: number | ((this: This, object: DatumObject, ...args: any[]) => number)): this;\n\n    /**\n     * Returns the current number of digits, which defaults to 3.\n     */\n    digits(): number;\n    /**\n     * Sets the number of fractional digits for coordinates generated in SVG path strings.\n     * @param digits New amount of digits\n     */\n    digits(digits: number): this;\n}\n\n/**\n * Creates a new geographic path generator.\n *\n * The default projection is the null projection. The null projection represents the identity transformation, i.e.\n * the input geometry is not projected and is instead rendered directly in raw coordinates.\n * This can be useful for fast rendering of pre-projected geometry, or for fast rendering of the equirectangular projection.\n *\n * The default context is null, which implies that the path generator will return an SVG path string.\n *\n * @param projection An (optional) current projection to be used. Typically this is one of D3’s built-in geographic projections;\n * however, any object that exposes a projection.stream function can be used, enabling the use of custom projections.\n * See D3’s transforms for more examples of arbitrary geometric transformations. Setting the projection to \"null\" uses the identity projection. The default  value is \"null\", the identity projection.\n * @param context An (optional) rendering context to be used. If a context is provided, it must at least implement the interface described by GeoContext, a subset of the CanvasRenderingContext2D API.\n * Setting the context to \"null\" means that the path generator will return an SVG path string representing the to be rendered object. The default is \"null\".\n */\nexport function geoPath(projection?: GeoProjection | GeoStreamWrapper | null, context?: GeoContext | null): GeoPath;\n/**\n * Creates a new geographic path generator with the default settings.\n *\n * The default projection is the null projection. The null projection represents the identity transformation:\n * the input geometry is not projected and is instead rendered directly in raw coordinates.\n * This can be useful for fast rendering of pre-projected geometry, or for fast rendering of the equirectangular projection.\n *\n * The default context is null, which implies that the path generator will return an SVG path string.\n *\n * The generic corresponds to the type of the DatumObject which will be passed into the geo path generator for rendering\n *\n * @param projection An (optional) current projection to be used. Typically this is one of D3’s built-in geographic projections;\n * however, any object that exposes a projection.stream function can be used, enabling the use of custom projections.\n * See D3’s transforms for more examples of arbitrary geometric transformations. Setting the projection to \"null\" uses the identity projection. The default  value is \"null\", the identity projection.\n * @param context An (optional) rendering context to be used. If a context is provided, it must at least implement the interface described by GeoContext, a subset of the CanvasRenderingContext2D API.\n * Setting the context to \"null\" means that the path generator will return an SVG path string representing the to be rendered object. The default is \"null\".\n */\n// eslint-disable-next-line @definitelytyped/no-unnecessary-generics\nexport function geoPath<DatumObject extends GeoPermissibleObjects>(\n    projection?: GeoProjection | GeoStreamWrapper | null,\n    context?: GeoContext | null,\n): GeoPath<any, DatumObject>;\n/**\n * Creates a new geographic path generator with the default settings.\n *\n * The default projection is the null projection. The null projection represents the identity transformation:\n * the input geometry is not projected and is instead rendered directly in raw coordinates.\n * This can be useful for fast rendering of pre-projected geometry, or for fast rendering of the equirectangular projection.\n *\n * The default context is null, which implies that the path generator will return an SVG path string.\n *\n * The first generic corresponds to the \"this\"-context within which the geo path generator will be invoked.\n * This could be e.g. the DOMElement bound to \"this\" when using selection.attr(\"d\", ...) with the path generator.\n *\n * The second generic corresponds to the type of the DatumObject which will be passed into the geo path generator for rendering.\n *\n * @param projection An (optional) current projection to be used. Typically this is one of D3’s built-in geographic projections;\n * however, any object that exposes a projection.stream function can be used, enabling the use of custom projections.\n * See D3’s transforms for more examples of arbitrary geometric transformations. Setting the projection to \"null\" uses the identity projection. The default  value is \"null\", the identity projection.\n * @param context An (optional) rendering context to be used. If a context is provided, it must at least implement the interface described by GeoContext, a subset of the CanvasRenderingContext2D API.\n * Setting the context to \"null\" means that the path generator will return an SVG path string representing the to be rendered object. The default is \"null\".\n */\n// eslint-disable-next-line @definitelytyped/no-unnecessary-generics\nexport function geoPath<This, DatumObject extends GeoPermissibleObjects>(\n    projection?: GeoProjection | GeoStreamWrapper | null,\n    context?: GeoContext | null,\n): GeoPath<This, DatumObject>;\n\n// geoProjection ==========================================================\n\n/**\n * Constructs a new projection from the specified raw projection, project.\n * The project function takes the longitude and latitude of a given point in radians,\n * often referred to as lambda (λ) and phi (φ), and returns a two-element array [x, y] representing its unit projection.\n * The project function does not need to scale or translate the point, as these are applied automatically by projection.scale, projection.translate, and projection.center.\n * Likewise, the project function does not need to perform any spherical rotation, as projection.rotate is applied prior to projection.\n *\n * If the project function exposes an invert method, the returned projection will also expose projection.invert.\n */\nexport function geoProjection(project: GeoRawProjection): GeoProjection;\n\n// geoProjectionMutator ====================================================\n\n/**\n * Constructs a new projection from the specified raw projection factory and returns a mutate function to call whenever the raw projection changes.\n * The factory must return a raw projection. The returned mutate function returns the wrapped projection.\n *\n * When creating a mutable projection, the mutate function is typically not exposed.\n */\nexport function geoProjectionMutator(factory: (...args: any[]) => GeoRawProjection): () => GeoProjection;\n\n// Pre-Defined Projections and Raw Projections =============================\n\n// Azimuthal Projections ---------------------------------------------------\n\n/**\n * The azimuthal equal-area projection.\n */\nexport function geoAzimuthalEqualArea(): GeoProjection;\n\n/**\n * The raw azimuthal equal-area projection.\n */\nexport function geoAzimuthalEqualAreaRaw(): GeoRawProjection;\n\n/**\n * The azimuthal equidistant projection.\n */\nexport function geoAzimuthalEquidistant(): GeoProjection;\n/**\n * The raw azimuthal equidistant projection.\n */\nexport function geoAzimuthalEquidistantRaw(): GeoRawProjection;\n\n/**\n * The gnomonic projection.\n */\nexport function geoGnomonic(): GeoProjection;\n\n/**\n * The raw gnomonic projection.\n */\nexport function geoGnomonicRaw(): GeoRawProjection;\n\n/**\n * The orthographic projection.\n */\nexport function geoOrthographic(): GeoProjection;\n\n/**\n * The raw orthographic projection.\n */\nexport function geoOrthographicRaw(): GeoRawProjection;\n\n/**\n * The stereographic projection.\n */\nexport function geoStereographic(): GeoProjection;\n\n/**\n * The raw stereographic projection.\n */\nexport function geoStereographicRaw(): GeoRawProjection;\n\n/**\n * The Equal Eartch projection, by Bojan Šavrič et al., 2018.\n */\nexport function geoEqualEarth(): GeoProjection;\n\n/**\n * The raw Equal Earth projection, by Bojan Šavrič et al., 2018.\n */\nexport function geoEqualEarthRaw(): GeoRawProjection;\n\n// Composite Projections ---------------------------------------------------\n\n/**\n * A U.S.-centric composite projection of three d3.geoConicEqualArea projections: d3.geoAlbers is used for the lower forty-eight states,\n * and separate conic equal-area projections are used for Alaska and Hawaii. Note that the scale for Alaska is diminished: it is projected at 0.35× its true relative area.\n *\n * Composite consist of several projections that are composed into a single display. The constituent projections have fixed clip, center and rotation,\n * and thus composite projections do not support projection.center, projection.rotate, projection.clipAngle, or projection.clipExtent.\n */\nexport function geoAlbersUsa(): GeoProjection;\n\n// Conic Projections -------------------------------------------------------\n\n/**\n * The Albers’ equal area-conic projection. This is a U.S.-centric configuration of d3.geoConicEqualArea.\n */\nexport function geoAlbers(): GeoConicProjection;\n\n/**\n * The conic conformal projection. The parallels default to [30°, 30°] resulting in flat top.\n */\nexport function geoConicConformal(): GeoConicProjection;\n\n/**\n * The raw conic conformal projection.\n */\nexport function geoConicConformalRaw(phi0: number, phi1: number): GeoRawProjection;\n\n/**\n * The Albers’ equal-area conic projection.\n */\nexport function geoConicEqualArea(): GeoConicProjection;\n\n/**\n * The raw Albers’ equal-area conic projection.\n */\nexport function geoConicEqualAreaRaw(phi0: number, phi1: number): GeoRawProjection;\n\n/**\n * The conic equidistant projection.\n */\nexport function geoConicEquidistant(): GeoConicProjection;\n\n/**\n * The raw conic equidistant projection.\n */\nexport function geoConicEquidistantRaw(phi0: number, phi1: number): GeoRawProjection;\n\n// Cylindrical Projections ------------------------------------------------\n\n/**\n * The equirectangular (plate carrée) projection.\n */\nexport function geoEquirectangular(): GeoProjection;\n\n/**\n * The raw equirectangular (plate carrée) projection.\n */\nexport function geoEquirectangularRaw(): GeoRawProjection;\n\n/**\n * The spherical Mercator projection.\n * Defines a default projection.clipExtent such that the world is projected to a square, clipped to approximately ±85° latitude.\n */\nexport function geoMercator(): GeoProjection;\n/**\n * The raw spherical Mercator projection.\n */\nexport function geoMercatorRaw(): GeoRawProjection;\n\n/**\n * The transverse spherical Mercator projection.\n * Defines a default projection.clipExtent such that the world is projected to a square, clipped to approximately ±85° latitude.\n */\nexport function geoTransverseMercator(): GeoProjection;\n\n/**\n * The raw transverse spherical Mercator projection.\n */\nexport function geoTransverseMercatorRaw(): GeoRawProjection;\n\n/**\n * The Natural Earth projection is a pseudocylindrical projection designed by Tom Patterson. It is neither conformal nor equal-area, but appealing to the eye for small-scale maps of the whole world.\n */\nexport function geoNaturalEarth1(): GeoProjection;\n\n/**\n * The raw pseudo-cylindircal Natural Earth projection.\n */\nexport function geoNaturalEarth1Raw(): GeoRawProjection;\n\n// ----------------------------------------------------------------------\n// Projection Transforms\n// ----------------------------------------------------------------------\n\n// geoTransform(...) ====================================================\n\n/**\n * A Prototype interface which serves as a template for the implementation of a geometric transform using geoTransform(...)\n * It serves as a reference for the custom methods which can be passed into geoTransform as argument to crete a generalized\n * transform projection.\n */\nexport interface GeoTransformPrototype {\n    /**\n     * Indicates the end of a line or ring. Within a polygon, indicates the end of a ring.\n     * Unlike GeoJSON, the redundant closing coordinate of a ring is not indicated via point, and instead is implied via lineEnd within a polygon.\n     */\n    lineEnd?(this: this & { stream: GeoStream }): void;\n    /**\n     * Indicates the start of a line or ring. Within a polygon, indicates the start of a ring. The first ring of a polygon is the exterior ring, and is typically clockwise.\n     * Any subsequent rings indicate holes in the polygon, and are typically counterclockwise.\n     */\n    lineStart?(this: this & { stream: GeoStream }): void;\n    /**\n     * Indicates a point with the specified coordinates x and y (and optionally z). The coordinate system is unspecified and implementation-dependent;\n     * for example, projection streams require spherical coordinates in degrees as input. Outside the context of a polygon or line,\n     * a point indicates a point geometry object (Point or MultiPoint). Within a line or polygon ring, the point indicates a control point.\n     *\n     * @param x x-coordinate of point.\n     * @param y y-coordinate of point.\n     * @param z Optional z-coordinate of point.\n     */\n    point?(this: this & { stream: GeoStream }, x: number, y: number, z?: number): void;\n    /**\n     * Indicates the end of a polygon.\n     */\n    polygonEnd?(this: this & { stream: GeoStream }): void;\n    /**\n     * Indicates the start of a polygon. The first line of a polygon indicates the exterior ring, and any subsequent lines indicate interior holes.\n     */\n    polygonStart?(this: this & { stream: GeoStream }): void;\n    /**\n     * Indicates the sphere (the globe; the unit sphere centered at ⟨0,0,0⟩).\n     */\n    sphere?(this: this & { stream: GeoStream }): void;\n}\n\n// TODO: Review whether GeoStreamWrapper should be included into return value union type, i.e. ({ stream: (s: GeoStream) => (T & GeoStream & GeoStreamWrapper)})?\n// It probably should be omitted for purposes of this API. The stream method added to (T & GeoStream) is more of a private member used internally to\n// implement the Transform factory\n\n/**\n * Defines an arbitrary transform using the methods defined on the specified methods object.\n * Any undefined methods will use pass-through methods that propagate inputs to the output stream.\n *\n * @param methods An object with custom method implementations, which are used to create a transform projection.\n */\nexport function geoTransform<T extends GeoTransformPrototype>(methods: T): { stream(s: GeoStream): T & GeoStream };\n\n// geoIdentity() =================================================================\n\n/**\n * @deprecated Misspelled name. Use GeoIdentityTransform.\n */\nexport type GeoIdentityTranform = GeoIdentityTransform;\n\n/**\n * Geo Identity Transform\n */\nexport interface GeoIdentityTransform extends GeoStreamWrapper {\n    /**\n     * Returns a new array [x, y] (typically in pixels) representing the projected point of the given point.\n     * The point must be specified as a two-element array [longitude, latitude] in degrees.\n     * May return null if the specified point has no defined projected position, such as when the point is outside the clipping bounds of the projection.\n     *\n     * @param point A point specified as a two-dimensional array [longitude, latitude] in degrees.\n     */\n    (point: [number, number]): [number, number] | null;\n\n    /**\n     * Returns a new array [longitude, latitude] in degrees representing the unprojected point of the given projected point.\n     * May return null if the specified point has no defined projected position, such as when the point is outside the clipping bounds of the projection.\n     *\n     * @param point The projected point, specified as a two-element array [x, y] (typically in pixels).\n     */\n    invert(point: [number, number]): [number, number] | null;\n\n    /**\n     * Returns the current cartesian clipping function.\n     * Post-clipping occurs on the plane, when a projection is bounded to a certain extent such as a rectangle.\n     */\n    postclip(): (stream: GeoStream) => GeoStream;\n    /**\n     * Sets the projection’s cartesian clipping to the specified function and returns the projection.\n     *\n     * @param postclip A cartesian clipping function. Clipping functions are implemented as transformations of a projection stream.\n     * Post-clipping operates on planar coordinates, in pixels.\n     */\n    postclip(postclip: (stream: GeoStream) => GeoStream): this;\n\n    /**\n     * Returns the current scale factor.\n     *\n     * The scale factor corresponds linearly to the distance between projected points; however, absolute scale factors are not equivalent across projections.\n     */\n    scale(): number;\n    /**\n     * Sets the projection’s scale factor to the specified value and returns the projection.\n     * The scale factor corresponds linearly to the distance between projected points; however, absolute scale factors are not equivalent across projections.\n     *\n     * @param scale Scale factor to be used for the projection.\n     */\n    scale(scale: number): this;\n\n    /**\n     * Returns the current translation offset.\n     * The translation offset determines the pixel coordinates of the projection’s center.\n     */\n    translate(): [number, number];\n    /**\n     * Sets the projection’s translation offset to the specified two-element array [tx, ty] and returns the projection.\n     * The translation offset determines the pixel coordinates of the projection’s center.\n     *\n     * @param point A two-element array [tx, ty] specifying the translation offset.\n     */\n    translate(point: [number, number]): this;\n\n    /**\n     * Returns the projection’s current angle, which defaults to 0°.\n     */\n    angle(): number;\n    /**\n     * Sets the projection’s post-projection planar rotation angle to the specified angle in degrees and returns the projection.\n     * @param angle The new rotation angle of the projection.\n     */\n    angle(angle: number): this;\n\n    /**\n     * Sets the projection’s scale and translate to fit the specified GeoJSON object in the center of the given extent.\n     * The extent is specified as an array [[x₀, y₀], [x₁, y₁]], where x₀ is the left side of the bounding box, y₀ is the top, x₁ is the right and y₁ is the bottom. Returns the projection.\n     */\n    fitExtent(\n        extent: [[number, number], [number, number]],\n        object: ExtendedFeature | ExtendedFeatureCollection | GeoGeometryObjects | ExtendedGeometryCollection,\n    ): this;\n\n    /**\n     * A convenience method for projection.fitExtent where the top-left corner of the extent is [0, 0].\n     */\n    fitSize(\n        size: [number, number],\n        object: ExtendedFeature | ExtendedFeatureCollection | GeoGeometryObjects | ExtendedGeometryCollection,\n    ): this;\n\n    /**\n     * Returns the current viewport clip extent which defaults to null.\n     */\n    clipExtent(): [[number, number], [number, number]] | null;\n    /**\n     * Sets the projection’s viewport clip extent to the specified bounds in pixels and returns the projection.\n     * The extent bounds are specified as an array [[x₀, y₀], [x₁, y₁]], where x₀ is the left-side of the viewport, y₀ is the top, x₁ is the right and y₁ is the bottom.\n     * If extent is null, no viewport clipping is performed.\n     */\n    clipExtent(extent: null | [[number, number], [number, number]]): this;\n\n    /**\n     * Returns true if x-reflection is enabled, which defaults to false.\n     */\n    reflectX(): boolean;\n    /**\n     * Sets whether or not the x-dimension is reflected (negated) in the output.\n     *\n     * @param reflect true = reflect x-dimension, false = do not reflect x-dimension.\n     */\n    reflectX(reflect: boolean): this;\n\n    /**\n     * Returns true if y-reflection is enabled, which defaults to false.\n     */\n    reflectY(): boolean;\n    /**\n     * Sets whether or not the y-dimension is reflected (negated) in the output.\n     *\n     * This is especially useful for transforming from standard spatial reference systems,\n     * which treat positive y as pointing up, to display coordinate systems such as Canvas and SVG,\n     * which treat positive y as pointing down.\n     *\n     * @param reflect true = reflect y-dimension, false = do not reflect y-dimension.\n     */\n    reflectY(reflect: boolean): this;\n}\n\n/**\n * Returns the identity transform which can be used to scale, translate and clip planar geometry.\n */\nexport function geoIdentity(): GeoIdentityTransform;\n\n// ----------------------------------------------------------------------\n// Clipping Functions\n// ----------------------------------------------------------------------\n\n/**\n * A clipping function transforming a stream such that geometries (lines or polygons) that cross the antimeridian line are cut in two, one on each side.\n * Typically used for pre-clipping.\n */\nexport function geoClipAntimeridian(stream: GeoStream): GeoStream;\n\n/**\n * Generates a clipping function transforming a stream such that geometries are bounded by a small circle of radius angle around the projection’s center.\n * Typically used for pre-clipping.\n *\n * @param angle A clipping angle.\n */\nexport function geoClipCircle(angle: number): (stream: GeoStream) => GeoStream;\n\n/**\n * Generates a clipping function transforming a stream such that geometries are bounded by a rectangle of coordinates [[x0, y0], [x1, y1]].\n * Typically used for post-clipping.\n *\n * @param x0 x0 coordinate.\n * @param y0 y0 coordinate.\n * @param x1 x1 coordinate.\n * @param y1 y1 coordinate.\n */\nexport function geoClipRectangle(x0: number, y0: number, x1: number, y1: number): (stream: GeoStream) => GeoStream;\n" },
  { path: "node_modules/d3-shape/package.json", content: "{\"name\":\"d3-shape\",\"types\":\"./index.d.ts\"}" },
  { path: "node_modules/d3-shape/index.d.ts", content: "// Last module patch version validated against: 3.1.0\n\nimport { Path } from \"d3-path\";\n\ndeclare global {\n    interface CanvasRenderingContext2D {} // eslint-disable-line @typescript-eslint/no-empty-interface\n}\n\n// -----------------------------------------------------------------------------------\n// Shared Types and Interfaces\n// -----------------------------------------------------------------------------------\n\n/**\n * @deprecated\n * This interface is used to bridge the gap between two incompatible versions of TypeScript (see [#25944](https://github.com/Microsoft/TypeScript/pull/25944)).\n * Use `CanvasPathMethods` instead with TS <= 3.0 and `CanvasPath` with TS >= 3.1.\n */\nexport interface CanvasPath_D3Shape {\n    arc(x: number, y: number, radius: number, startAngle: number, endAngle: number, anticlockwise?: boolean): void;\n    arcTo(x1: number, y1: number, x2: number, y2: number, radius: number): void;\n    bezierCurveTo(cp1x: number, cp1y: number, cp2x: number, cp2y: number, x: number, y: number): void;\n    closePath(): void;\n    ellipse(\n        x: number,\n        y: number,\n        radiusX: number,\n        radiusY: number,\n        rotation: number,\n        startAngle: number,\n        endAngle: number,\n        anticlockwise?: boolean,\n    ): void;\n    lineTo(x: number, y: number): void;\n    moveTo(x: number, y: number): void;\n    quadraticCurveTo(cpx: number, cpy: number, x: number, y: number): void;\n    rect(x: number, y: number, w: number, h: number): void;\n}\n\n// -----------------------------------------------------------------------------------\n// Arc Generator\n// -----------------------------------------------------------------------------------\n\n/**\n * Interface corresponding to the minimum data type assumed by the accessor functions of the Arc generator.\n */\nexport interface DefaultArcObject {\n    /**\n     * Inner radius of arc.\n     */\n    innerRadius: number;\n    /**\n     * Outer radius of arc.\n     */\n    outerRadius: number;\n    /**\n     * Start angle of arc. The angle is specified in radians, with 0 at -y (12 o’clock) and positive angles proceeding clockwise.\n     */\n    startAngle: number;\n    /**\n     * End angle of arc. The angle is specified in radians, with 0 at -y (12 o’clock) and positive angles proceeding clockwise.\n     */\n    endAngle: number;\n    /**\n     * Optional. Pad angle of arc in radians.\n     */\n    padAngle?: number | undefined;\n}\n\n/**\n * The arc generator produces a circular or annular sector, as in a pie or donut chart.\n *\n * If the difference between the start and end angles (the angular span) is greater than τ, the arc generator will produce a complete circle or annulus.\n * If it is less than τ, arcs may have rounded corners and angular padding. Arcs are always centered at ⟨0,0⟩; use a transform (see: SVG, Canvas) to move the arc to a different position.\n *\n * See also the pie generator, which computes the necessary angles to represent an array of data as a pie or donut chart; these angles can then be passed to an arc generator.\n *\n * The first generic corresponds to the type of the \"this\" context within which the arc generator and its accessor functions will be invoked.\n *\n * The second generic corresponds to the datum type for which the arc is to be generated.\n */\nexport interface Arc<This, Datum> {\n    /**\n     * Generates an arc for the given arguments.\n     *\n     * IMPORTANT: If the rendering context of the arc generator is null,\n     * then the arc is returned as a path data string.\n     *\n     * The \"this\" context within which this function is invoked, will be the context within which the accessor methods of the generator are invoked.\n     * All arguments passed into this function, will be passed to the accessor functions of the generator.\n     *\n     * @param d The datum for which the arc is to be generated.\n     */\n    (this: This, d: Datum, ...args: any[]): string | null;\n    /**\n     * Generates an arc for the given arguments.\n     *\n     * IMPORTANT: If the arc generator has been configured with a rendering context,\n     * then the arc is rendered to this context as a sequence of path method calls and this function returns void.\n     *\n     * The \"this\" context within which this function is invoked, will be the context within which the accessor methods of the generator are invoked.\n     * All arguments passed into this function, will be passed to the accessor functions of the generator.\n     *\n     * @param d The datum for which the arc is to be generated.\n     */\n    (this: This, d: Datum, ...args: any[]): void;\n\n    /**\n     * Computes the midpoint [x, y] of the center line of the arc that would be generated by the given arguments.\n     *\n     * To be consistent with the generated arc, the accessors must be deterministic, i.e., return the same value given the same arguments.\n     * The midpoint is defined as (startAngle + endAngle) / 2 and (innerRadius + outerRadius) / 2.\n     *\n     * Note that this is not the geometric center of the arc, which may be outside the arc;\n     * this method is merely a convenience for positioning labels.\n     *\n     * The method is invoked in the same \"this\" context as the generator was invoked in and\n     * receives the same arguments that are passed into the arc generator.\n     *\n     * @param d The datum for which the arc is to be generated.\n     */\n    centroid(d: Datum, ...args: any[]): [number, number];\n\n    /**\n     * Returns the current inner radius accessor, which defaults to a function returning the innerRadius property\n     * of the first argument passed into it.\n     */\n    innerRadius(): (this: This, d: Datum, ...args: any[]) => number;\n    /**\n     * Sets the inner radius to the specified number and returns this arc generator.\n     *\n     * Specifying the inner radius as a function is useful for constructing a stacked polar bar chart, often in conjunction with a sqrt scale.\n     * More commonly, a constant inner radius is used for a donut or pie chart. If the outer radius is smaller than the inner radius, the inner and outer radii are swapped.\n     * A negative value is treated as zero.\n     *\n     * @param radius Constant radius.\n     */\n    innerRadius(radius: number): this;\n    /**\n     * Sets the inner radius to the specified function and returns this arc generator.\n     *\n     * Specifying the inner radius as a function is useful for constructing a stacked polar bar chart, often in conjunction with a sqrt scale.\n     * More commonly, a constant inner radius is used for a donut or pie chart. If the outer radius is smaller than the inner radius, the inner and outer radii are swapped.\n     * A negative value is treated as zero.\n     *\n     * @param radius An accessor function returning a number to be used as a radius. The accessor function is invoked in the same \"this\" context as the generator was invoked in and\n     * receives the same arguments that were passed into the arc generator.\n     */\n    innerRadius(radius: (this: This, d: Datum, ...args: any[]) => number): this;\n\n    /**\n     * Returns the current outer radius accessor, which defaults to a function returning the outerRadius property\n     * of the first argument passed into it.\n     */\n    outerRadius(): (this: This, d: Datum, ...args: any[]) => number;\n    /**\n     * Sets the outer radius to the specified number and returns this arc generator.\n     *\n     * Specifying the outer radius as a function is useful for constructing a coxcomb or polar bar chart,\n     * often in conjunction with a sqrt scale. More commonly, a constant outer radius is used for a pie or donut chart.\n     * If the outer radius is smaller than the inner radius, the inner and outer radii are swapped.\n     * A negative value is treated as zero.\n     *\n     * @param radius Constant radius.\n     */\n    outerRadius(radius: number): this;\n    /**\n     * Sets the outer radius to the specified function and returns this arc generator.\n     *\n     * Specifying the outer radius as a function is useful for constructing a coxcomb or polar bar chart,\n     * often in conjunction with a sqrt scale. More commonly, a constant outer radius is used for a pie or donut chart.\n     * If the outer radius is smaller than the inner radius, the inner and outer radii are swapped.\n     * A negative value is treated as zero.\n     *\n     * @param radius An accessor function returning a number to be used as a radius. The accessor function is invoked in the same \"this\" context as the generator was invoked in and\n     * receives the same arguments that were passed into the arc generator.\n     */\n    outerRadius(radius: (this: This, d: Datum, ...args: any[]) => number): this;\n\n    /**\n     * Returns the current corner radius accessor, which defaults to a function returning a constant value of zero.\n     */\n    cornerRadius(): (this: This, d: Datum, ...args: any[]) => number;\n    /**\n     * Sets the corner radius to the specified number and returns this arc generator.\n     *\n     * If the corner radius is greater than zero, the corners of the arc are rounded using circles of the given radius.\n     * For a circular sector, the two outer corners are rounded; for an annular sector, all four corners are rounded.\n     *\n     * The corner radius may not be larger than (outerRadius - innerRadius) / 2.\n     * In addition, for arcs whose angular span is less than π, the corner radius may be reduced as two adjacent rounded corners intersect.\n     * This is occurs more often with the inner corners.\n     *\n     * @param radius Constant radius.\n     */\n    cornerRadius(radius: number): this;\n    /**\n     * Sets the corner radius to the specified function and returns this arc generator.\n     *\n     * The corner radius may not be larger than (outerRadius - innerRadius) / 2.\n     * In addition, for arcs whose angular span is less than π, the corner radius may be reduced as two adjacent rounded corners intersect.\n     * This is occurs more often with the inner corners.\n     *\n     * @param radius An accessor function returning a number to be used as a radius. The accessor function is invoked in the same \"this\" context as the generator was invoked in and\n     * receives the same arguments that were passed into the arc generator.\n     */\n    cornerRadius(radius: (this: This, d: Datum, ...args: any[]) => number): this;\n\n    /**\n     * Returns the current start angle accessor, which defaults to a function returning the startAngle property\n     * of the first argument passed into it.\n     */\n    startAngle(): (this: This, d: Datum, ...args: any[]) => number;\n    /**\n     * Sets the start angle to the specified number and returns this arc generator.\n     *\n     * The angle is specified in radians, with 0 at -y (12 o’clock) and positive angles proceeding clockwise.\n     * If |endAngle - startAngle| ≥ τ, a complete circle or annulus is generated rather than a sector.\n     *\n     * @param angle Constant angle in radians.\n     */\n    startAngle(angle: number): this;\n    /**\n     * Sets the start angle to the specified function and returns this arc generator.\n     *\n     * The angle is specified in radians, with 0 at -y (12 o’clock) and positive angles proceeding clockwise.\n     * If |endAngle - startAngle| ≥ τ, a complete circle or annulus is generated rather than a sector.\n     *\n     * @param angle An accessor function returning a number in radians to be used as an angle. The accessor function is invoked in the same \"this\" context as the generator was invoked in and\n     * receives the same arguments that were passed into the arc generator.\n     */\n    startAngle(angle: (this: This, d: Datum, ...args: any[]) => number): this;\n\n    /**\n     * Returns the current end angle accessor, which defaults to a function returning the endAngle property\n     * of the first argument passed into it.\n     */\n    endAngle(): (this: This, d: Datum, ...args: any[]) => number;\n    /**\n     * Sets the end angle to the specified number and returns this arc generator.\n     *\n     * The angle is specified in radians, with 0 at -y (12 o’clock) and positive angles proceeding clockwise.\n     * If |endAngle - startAngle| ≥ τ, a complete circle or annulus is generated rather than a sector.\n     *\n     * @param angle Constant angle in radians.\n     */\n    endAngle(angle: number): this;\n    /**\n     * Sets the end angle to the specified function and returns this arc generator.\n     *\n     * The angle is specified in radians, with 0 at -y (12 o’clock) and positive angles proceeding clockwise.\n     * If |endAngle - startAngle| ≥ τ, a complete circle or annulus is generated rather than a sector.\n     *\n     * @param angle An accessor function returning a number in radians to be used as an angle. The accessor function is invoked in the same \"this\" context as the generator was invoked in and\n     * receives the same arguments that were passed into the arc generator.\n     */\n    endAngle(angle: (this: This, d: Datum, ...args: any[]) => number): this;\n\n    /**\n     * Returns the current pad angle accessor, which defaults to a function returning the padAngle property\n     * of the first argument passed into it, or false if no data are passed in or the property is not defined.\n     */\n    padAngle(): (this: This, d: Datum, ...args: any[]) => number | undefined;\n    /**\n     * Sets the pad angle to the specified number and returns this arc generator.\n     *\n     * The pad angle is converted to a fixed linear distance separating adjacent arcs, defined as padRadius * padAngle. This distance is subtracted equally from the start and end of the arc.\n     * If the arc forms a complete circle or annulus, as when |endAngle - startAngle| ≥ τ, the pad angle is ignored. If the inner radius or angular span is small relative to the pad angle,\n     * it may not be possible to maintain parallel edges between adjacent arcs. In this case, the inner edge of the arc may collapse to a point, similar to a circular sector.\n     * For this reason, padding is typically only applied to annular sectors (i.e., when innerRadius is positive).\n     *\n     * The recommended minimum inner radius when using padding is outerRadius * padAngle / sin(θ), where θ is the angular span of the smallest arc before padding.\n     * For example, if the outer radius is 200 pixels and the pad angle is 0.02 radians, a reasonable θ is 0.04 radians, and a reasonable inner radius is 100 pixels.\n     *\n     * Often, the pad angle is not set directly on the arc generator, but is instead computed by the pie generator so as to ensure that the area of padded arcs is proportional to their value;\n     * see pie.padAngle. See the pie padding animation for illustration.\n     * If you apply a constant pad angle to the arc generator directly, it tends to subtract disproportionately from smaller arcs, introducing distortion.\n     *\n     * @param angle Constant angle in radians.\n     */\n    padAngle(angle: number | undefined): this;\n    /**\n     * Sets the pad angle to the specified function and returns this arc generator.\n     *\n     * The pad angle is converted to a fixed linear distance separating adjacent arcs, defined as padRadius * padAngle. This distance is subtracted equally from the start and end of the arc.\n     * If the arc forms a complete circle or annulus, as when |endAngle - startAngle| ≥ τ, the pad angle is ignored. If the inner radius or angular span is small relative to the pad angle,\n     * it may not be possible to maintain parallel edges between adjacent arcs. In this case, the inner edge of the arc may collapse to a point, similar to a circular sector.\n     * For this reason, padding is typically only applied to annular sectors (i.e., when innerRadius is positive).\n     *\n     * The recommended minimum inner radius when using padding is outerRadius * padAngle / sin(θ), where θ is the angular span of the smallest arc before padding.\n     * For example, if the outer radius is 200 pixels and the pad angle is 0.02 radians, a reasonable θ is 0.04 radians, and a reasonable inner radius is 100 pixels.\n     *\n     * Often, the pad angle is not set directly on the arc generator, but is instead computed by the pie generator so as to ensure that the area of padded arcs is proportional to their value;\n     * see pie.padAngle. See the pie padding animation for illustration.\n     * If you apply a constant pad angle to the arc generator directly, it tends to subtract disproportionately from smaller arcs, introducing distortion.\n     *\n     * @param angle An accessor function returning a number in radians to be used as an angle. The accessor function is invoked in the same \"this\" context as the generator was invoked in and\n     * receives the same arguments that were passed into the arc generator.\n     */\n    padAngle(angle: (this: This, d: Datum, ...args: any[]) => number | undefined): this;\n\n    /**\n     * Returns the current pad radius accessor, which defaults to null, indicating that the pad radius should be automatically computed as sqrt(innerRadius * innerRadius + outerRadius * outerRadius).\n     */\n    padRadius(): ((this: This, d: Datum, ...args: any[]) => number) | null;\n    /**\n     * Sets the pad radius to the specified function or number and returns this arc generator.\n     * The pad radius determines the fixed linear distance separating adjacent arcs, defined as padRadius * padAngle.\n     */\n    padRadius(radius: null | number | ((this: This, d: Datum, ...args: any[]) => number)): this;\n\n    /**\n     * Returns the current rendering context, which defaults to null.\n     */\n    context(): CanvasRenderingContext2D | null;\n    /**\n     * Sets the context and returns this arc generator.\n     * If context is not specified, returns the current context, which defaults to null.\n     */\n    context(context: CanvasRenderingContext2D | null): this;\n}\n\n/**\n * Constructs a new arc generator with the default settings.\n *\n * Ensure that the accessors used with the arc generator correspond to the arguments passed into them,\n * or set them to constants as appropriate.\n */\nexport function arc(): Arc<any, DefaultArcObject>;\n/**\n * Constructs a new arc generator with the default settings.\n *\n * Ensure that the accessors used with the arc generator correspond to the arguments passed into them,\n * or set them to constants as appropriate.\n *\n * The generic corresponds to the datum type representing a arc.\n */\n// eslint-disable-next-line @definitelytyped/no-unnecessary-generics\nexport function arc<Datum>(): Arc<any, Datum>;\n/**\n * Constructs a new arc generator with the default settings.\n *\n * Ensure that the accessors used with the arc generator correspond to the arguments passed into them,\n * or set them to constants as appropriate.\n *\n * The first generic corresponds to the type of the \"this\" context within which the arc generator and its accessor functions will be invoked.\n *\n * The second generic corresponds to the datum type representing a arc.\n */\n// eslint-disable-next-line @definitelytyped/no-unnecessary-generics\nexport function arc<This, Datum>(): Arc<This, Datum>;\n\n// -----------------------------------------------------------------------------------\n// Pie Generator\n// -----------------------------------------------------------------------------------\n\n/**\n * Element of the Arc Datums Array created by invoking the Pie generator.\n *\n * The generic refers to the data type of an element in the input array passed into the Pie generator.\n */\nexport interface PieArcDatum<T> {\n    /**\n     * The input datum; the corresponding element in the input data array of the Pie generator.\n     */\n    data: T;\n    /**\n     * The numeric value of the arc.\n     */\n    value: number;\n    /**\n     * The zero-based sorted index of the arc.\n     */\n    index: number;\n    /**\n     * The start angle of the arc.\n     * If the pie generator was configured to be used for the arc generator,\n     * then the units are in radians with 0 at -y (12 o’clock) and positive angles proceeding clockwise.\n     */\n    startAngle: number;\n    /**\n     * The end angle of the arc.\n     * If the pie generator was configured to be used for the arc generator,\n     * then the units are in radians with 0 at -y (12 o’clock) and positive angles proceeding clockwise.\n     */\n    endAngle: number;\n    /**\n     * The pad angle of the arc. If the pie generator was configured to be used for the arc generator, than the units are in radians.\n     */\n    padAngle: number;\n}\n\n/**\n * The pie generator does not produce a shape directly, but instead computes the necessary angles to represent a tabular dataset as a pie or donut chart;\n * these angles can then be passed to an arc generator.\n *\n * The first generic corresponds to the type of the \"this\" context within which the pie generator and its accessor functions will be invoked.\n *\n * The second generic refers to the data type of an element in the input array passed into the Pie generator.\n */\nexport interface Pie<This, Datum> {\n    /**\n     * Generates a pie for the given array of data, returning an array of objects representing each datum’s arc angles.\n     * Any additional arguments are arbitrary; they are simply propagated to the pie generator’s accessor functions along with the this object.\n     * The length of the returned array is the same as data, and each element i in the returned array corresponds to the element i in the input data.\n     *\n     * This representation is designed to work with the arc generator’s default startAngle, endAngle and padAngle accessors.\n     * The angular units are arbitrary, but if you plan to use the pie generator in conjunction with an arc generator,\n     * you should specify angles in radians, with 0 at -y (12 o’clock) and positive angles proceeding clockwise.\n     *\n     * @param data Array of data elements.\n     */\n    (this: This, data: Datum[], ...args: any[]): Array<PieArcDatum<Datum>>;\n\n    /**\n     * Returns the current value accessor, which defaults to a function returning the first argument passed into it.\n     * The default value accessor assumes that the input data are numbers, or that they are coercible to numbers using valueOf.\n     */\n    value(): (d: Datum, i: number, data: Datum[]) => number;\n    /**\n     * Sets the value accessor to use the specified constant number and returns this pie generator.\n     *\n     * @param value Constant value to be used.\n     */\n    value(value: number): this;\n    /**\n     * Sets the value accessor to use the specified function and returns this pie generator.\n     *\n     * When a pie is generated, the value accessor will be invoked for each element in the input data array.\n     * The default value accessor assumes that the input data are numbers, or that they are coercible to numbers using valueOf.\n     * If your data are not simply numbers, then you should specify an accessor that returns the corresponding numeric value for a given datum.\n     *\n     * @param value A value accessor function, which is invoked for each element in the input data array, being passed the element d, the index i, and the array data as three arguments.\n     * It returns a numeric value.\n     */\n    value(value: (d: Datum, i: number, data: Datum[]) => number): this;\n\n    /**\n     * Returns the current data comparator, which defaults to null.\n     */\n    sort(): ((a: Datum, b: Datum) => number) | null;\n    /**\n     * Sets the data comparator to the specified function and returns this pie generator.\n     *\n     * If both the data comparator and the value comparator are null, then arcs are positioned in the original input order.\n     * Otherwise, the data is sorted according to the data comparator, and the resulting order is used. Setting the data comparator implicitly sets the value comparator to null.\n     *\n     * Sorting does not affect the order of the generated arc array which is always in the same order as the input data array; it merely affects the computed angles of each arc.\n     * The first arc starts at the start angle and the last arc ends at the end angle.\n     *\n     * @param comparator A compare function takes two arguments a and b, each elements from the input data array.\n     * If the arc for a should be before the arc for b, then the comparator must return a number less than zero;\n     * if the arc for a should be after the arc for b, then the comparator must return a number greater than zero;\n     * returning zero means that the relative order of a and b is unspecified.\n     */\n    sort(comparator: (a: Datum, b: Datum) => number): this;\n    /**\n     * Sets the data comparator to null and returns this pie generator.\n     *\n     * If both the data comparator and the value comparator are null, then arcs are positioned in the original input order.\n     *\n     * @param comparator null, to set the pie generator to use the original input order or use the sortValues comparator, if any.\n     */\n    sort(comparator: null): this;\n\n    /**\n     * Returns the current value comparator, which defaults to descending value.\n     */\n    sortValues(): ((a: number, b: number) => number) | null;\n    /**\n     * Sets the value comparator to the specified function and returns this pie generator.\n     *\n     * If both the data comparator and the value comparator are null, then arcs are positioned in the original input order.\n     * Otherwise, the data is sorted according to the data comparator, and the resulting order is used.\n     * Setting the value comparator implicitly sets the data comparator to null.\n     *\n     * The value comparator is similar to the data comparator, except the two arguments a and b are values derived from the input data array using the value accessor, not the data elements.\n     * If the arc for a should be before the arc for b, then the comparator must return a number less than zero;\n     * if the arc for a should be after the arc for b, then the comparator must return a number greater than zero;\n     * returning zero means that the relative order of a and b is unspecified.\n     */\n    sortValues(comparator: ((a: number, b: number) => number) | null): this;\n\n    /**\n     * Returns the current start angle accessor, which defaults to a function returning a constant zero.\n     */\n    startAngle(): (this: This, data: Datum[], ...args: any[]) => number;\n    /**\n     * Sets the overall start angle of the pie to the specified number and returns this pie generator.\n     *\n     * The default start angle is zero.\n     *\n     * The start angle here means the overall start angle of the pie, i.e., the start angle of the first arc.\n     * The start angle accessor is invoked once, being passed the same arguments and this context as the pie generator.\n     * The units of angle are arbitrary, but if you plan to use the pie generator in conjunction with an arc generator,\n     * you should specify an angle in radians, with 0 at -y (12 o’clock) and positive angles proceeding clockwise.\n     *\n     * @param angle A constant angle.\n     */\n    startAngle(angle: number): this;\n    /**\n     * Sets the overall start angle of the pie to the specified function and returns this pie generator.\n     *\n     * The default start angle is zero.\n     *\n     * The start angle here means the overall start angle of the pie, i.e., the start angle of the first arc.\n     * The start angle accessor is invoked once, being passed the same arguments and this context as the pie generator.\n     * The units of angle are arbitrary, but if you plan to use the pie generator in conjunction with an arc generator,\n     * you should specify an angle in radians, with 0 at -y (12 o’clock) and positive angles proceeding clockwise.\n     *\n     * @param angle An angle accessor function, which is invoked once, being passed the same arguments and this context as the pie generator.\n     */\n    startAngle(angle: (this: This, data: Datum[], ...args: any[]) => number): this;\n\n    /**\n     * Returns the current end angle accessor, which defaults to a function returning a constant 2*pi.\n     */\n    endAngle(): (this: This, data: Datum[], ...args: any[]) => number;\n    /**\n     * Sets the overall end angle of the pie to the specified number and returns this pie generator.\n     *\n     * The default end angle is 2*pi.\n     *\n     * The end angle here means the overall end angle of the pie, i.e., the end angle of the last arc.\n     * The units of angle are arbitrary, but if you plan to use the pie generator in conjunction with an arc generator,\n     * you should specify an angle in radians, with 0 at -y (12 o’clock) and positive angles proceeding clockwise.\n     *\n     * The value of the end angle is constrained to startAngle ± τ, such that |endAngle - startAngle| ≤ τ.\n     *\n     * @param angle A constant angle.\n     */\n    endAngle(angle: number): this;\n    /**\n     * Sets the overall end angle of the pie to the specified function and returns this pie generator.\n     *\n     * The default end angle is 2*pi.\n     *\n     * The end angle here means the overall end angle of the pie, i.e., the end angle of the last arc.\n     * The end angle accessor is invoked once, being passed the same arguments and this context as the pie generator.\n     * The units of angle are arbitrary, but if you plan to use the pie generator in conjunction with an arc generator,\n     * you should specify an angle in radians, with 0 at -y (12 o’clock) and positive angles proceeding clockwise.\n     *\n     * The value of the end angle is constrained to startAngle ± τ, such that |endAngle - startAngle| ≤ τ.\n     *\n     * @param angle An angle accessor function, which is invoked once, being passed the same arguments and this context as the pie generator.\n     */\n    endAngle(angle: (this: This, data: Datum[], ...args: any[]) => number): this;\n\n    /**\n     * Returns the current pad angle accessor, which defaults to a function returning a constant zero.\n     */\n    padAngle(): (this: This, data: Datum[], ...args: any[]) => number;\n    /**\n     * Sets the pad angle to the specified number and returns this pie generator.\n     *\n     * The pad angle here means the angular separation between each adjacent arc.\n     * The total amount of padding reserved is the specified angle times the number of elements in the input data array, and at most |endAngle - startAngle|;\n     * the remaining space is then divided proportionally by value such that the relative area of each arc is preserved.\n     * The units of angle are arbitrary, but if you plan to use the pie generator in conjunction with an arc generator, you should specify an angle in radians.\n     *\n     * @param angle A constant angle.\n     */\n    padAngle(angle: number): this;\n    /**\n     * Sets the pad angle to the specified function and returns this pie generator.\n     *\n     * The pad angle here means the angular separation between each adjacent arc.\n     * The total amount of padding reserved is the specified angle times the number of elements in the input data array, and at most |endAngle - startAngle|;\n     * the remaining space is then divided proportionally by value such that the relative area of each arc is preserved.\n     * The pad angle accessor is invoked once, being passed the same arguments and this context as the pie generator.\n     * The units of angle are arbitrary, but if you plan to use the pie generator in conjunction with an arc generator, you should specify an angle in radians.\n     *\n     * @param angle An angle accessor function, which is invoked once, being passed the same arguments and this context as the pie generator.\n     */\n    padAngle(angle: (this: This, data: Datum[], ...args: any[]) => number): this;\n}\n\n/**\n * Constructs a new pie generator with the default settings.\n *\n * Ensure that the accessors used with the pie generator correspond to the arguments passed into them,\n * or set them to constants as appropriate.\n */\nexport function pie(): Pie<any, number | { valueOf(): number }>;\n/**\n * Constructs a new pie generator with the default settings.\n *\n * Ensure that the accessors used with the pie generator correspond to the arguments passed into them,\n * or set them to constants as appropriate.\n *\n * The generic refers to the data type of an element in the input array passed into the Pie generator.\n */\n// eslint-disable-next-line @definitelytyped/no-unnecessary-generics\nexport function pie<Datum>(): Pie<any, Datum>;\n/**\n * Constructs a new pie generator with the default settings.\n *\n * Ensure that the accessors used with the pie generator correspond to the arguments passed into them,\n * or set them to constants as appropriate.\n *\n * The first generic corresponds to the type of the \"this\" context within which the pie generator and its accessor functions will be invoked.\n *\n * The second generic refers to the data type of an element in the input array passed into the Pie generator.\n */\n// eslint-disable-next-line @definitelytyped/no-unnecessary-generics\nexport function pie<This, Datum>(): Pie<This, Datum>;\n\n// -----------------------------------------------------------------------------------\n// Line Generators\n// -----------------------------------------------------------------------------------\n\n/**\n * The line generator produces a spline or polyline, as in a line chart.\n * Lines also appear in many other visualization types, such as the links in hierarchical edge bundling.\n *\n * The generic refers to the data type of an element in the input array passed into the line generator.\n */\nexport interface Line<Datum> {\n    /**\n     * Generates a line for the given array of data. Depending on this line generator’s associated curve,\n     * the given input data may need to be sorted by x-value before being passed to the line generator.\n     *\n     * IMPORTANT: If the rendering context of the line generator is null,\n     * then the line is returned as a path data string.\n     *\n     * @param data Array of data elements.\n     */\n    (data: Iterable<Datum> | Datum[]): string | null;\n    /**\n     * Generates a line for the given array of data. Depending on this line generator’s associated curve,\n     * the given input data may need to be sorted by x-value before being passed to the line generator.\n     *\n     * IMPORTANT: If the line generator has been configured with a rendering context,\n     * then the line is rendered to this context as a sequence of path method calls and this function returns void.\n     *\n     * @param data Array of data elements.\n     */\n    (data: Iterable<Datum> | Datum[]): void;\n\n    /**\n     * Returns the current x-coordinate accessor function, which defaults to a function returning first element of a two-element array of numbers.\n     */\n    x(): (d: Datum, index: number, data: Datum[]) => number;\n    /**\n     * Sets the x accessor to the specified number and returns this line generator.\n     *\n     * @param x A constant x-coordinate value.\n     */\n    x(x: number): this;\n    /**\n     * Sets the x accessor to the specified function and returns this line generator.\n     *\n     * When a line is generated, the x accessor will be invoked for each defined element in the input data array.\n     *\n     * The default x accessor assumes that the input data are two-element arrays of numbers. If your data are in a different format, or if you wish to transform the data before rendering,\n     * then you should specify a custom accessor.\n     *\n     * @param x A coordinate accessor function which returns the x-coordinate value. The x accessor will be invoked for each defined element in the input data array,\n     * being passed the element d, the index i, and the array data as three arguments.\n     */\n    x(x: (d: Datum, index: number, data: Datum[]) => number): this;\n\n    /**\n     * Returns the current y-coordinate accessor function, which defaults to a function returning second element of a two-element array of numbers.\n     */\n    y(): (d: Datum, index: number, data: Datum[]) => number;\n    /**\n     * Sets the y accessor to the specified number and returns this line generator.\n     *\n     * @param y A constant y-coordinate value.\n     */\n    y(y: number): this;\n    /**\n     * Sets the y accessor to the specified function and returns this line generator.\n     *\n     * When a line is generated, the y accessor will be invoked for each defined element in the input data array.\n     *\n     * The default y accessor assumes that the input data are two-element arrays of numbers. If your data are in a different format, or if you wish to transform the data before rendering,\n     * then you should specify a custom accessor.\n     *\n     * @param y A coordinate accessor function which returns the y-coordinate value. The y accessor will be invoked for each defined element in the input data array,\n     * being passed the element d, the index i, and the array data as three arguments.\n     */\n    y(y: (d: Datum, index: number, data: Datum[]) => number): this;\n\n    /**\n     * Returns the current defined accessor, which defaults to a function returning a constant boolean value of true.\n     */\n    defined(): (d: Datum, index: number, data: Datum[]) => boolean;\n    /**\n     * Sets the defined accessor to the specified boolean and returns this line generator.\n     *\n     * The default accessor for defined returns a constant boolean value of true, thus assumes that the input data is always defined.\n     *\n     * When a line is generated, the defined accessor will be invoked for each element in the input data array,\n     * being passed the element d, the index i, and the array data as three arguments.\n     * If the given element is defined (i.e., if the defined accessor returns a truthy value for this element),\n     * the x and y accessors will subsequently be evaluated and the point will be added to the current line segment.\n     * Otherwise, the element will be skipped, the current line segment will be ended, and a new line segment will be generated for the next defined point.\n     * As a result, the generated line may have several discrete segments.\n     *\n     * Note that if a line segment consists of only a single point, it may appear invisible unless rendered with rounded or square line caps.\n     * In addition, some curves such as curveCardinalOpen only render a visible segment if it contains multiple points.\n     *\n     * @param defined A boolean constant.\n     */\n    defined(defined: boolean): this;\n    /**\n     * Sets the defined accessor to the specified function and returns this line generator.\n     *\n     * The default accessor for defined returns a constant boolean value of true, thus assumes that the input data is always defined.\n     *\n     * When a line is generated, the defined accessor will be invoked for each element in the input data array,\n     * being passed the element d, the index i, and the array data as three arguments.\n     * If the given element is defined (i.e., if the defined accessor returns a truthy value for this element),\n     * the x and y accessors will subsequently be evaluated and the point will be added to the current line segment.\n     * Otherwise, the element will be skipped, the current line segment will be ended, and a new line segment will be generated for the next defined point.\n     * As a result, the generated line may have several discrete segments.\n     *\n     * Note that if a line segment consists of only a single point, it may appear invisible unless rendered with rounded or square line caps.\n     * In addition, some curves such as curveCardinalOpen only render a visible segment if it contains multiple points.\n     *\n     * @param defined An accessor function which returns a boolean value. The accessor will be invoked for each defined element in the input data array,\n     * being passed the element d, the index i, and the array data as three arguments.\n     */\n    defined(defined: (d: Datum, index: number, data: Datum[]) => boolean): this;\n\n    /**\n     * Returns the current curve factory, which defaults to curveLinear.\n     */\n    curve(): CurveFactory | CurveFactoryLineOnly;\n    /**\n     * Returns the current curve factory, which defaults to curveLinear.\n     *\n     * The generic allows to cast the curve factory to a specific type, if known.\n     */\n    // eslint-disable-next-line @definitelytyped/no-unnecessary-generics\n    curve<C extends CurveFactory | CurveFactoryLineOnly>(): C;\n    /**\n     * Sets the curve factory and returns this line generator.\n     *\n     * @param curve A valid curve factory.\n     */\n    curve(curve: CurveFactory | CurveFactoryLineOnly): this;\n\n    /**\n     * Returns the current rendering context, which defaults to null.\n     */\n    context(): CanvasRenderingContext2D | null;\n    /**\n     * Sets the context and returns this line generator.\n     */\n    context(context: CanvasRenderingContext2D | null): this;\n}\n\n/**\n * Constructs a new line generator with the default settings.\n *\n * If x or y are specified, sets the corresponding accessors to the specified function or number and returns this line generator.\n *\n * The generic refers to the data type of an element in the input array passed into the line generator.\n *\n * @param x Sets the x accessor\n * @param y Sets the y accessor\n */\nexport function line<Datum = [number, number]>(\n    x?: number | ((d: Datum, index: number, data: Datum[]) => number),\n    y?: number | ((d: Datum, index: number, data: Datum[]) => number),\n): Line<Datum>;\n\n/**\n * The radial line generator produces a spline or polyline, as in a line chart.\n *\n * A radial line generator is equivalent to the standard Cartesian line generator,\n * except the x and y accessors are replaced with angle and radius accessors.\n * Radial lines are always positioned relative to ⟨0,0⟩; use a transform (see: SVG, Canvas) to change the origin.\n *\n * The generic refers to the data type of an element in the input array passed into the line generator.\n */\nexport interface LineRadial<Datum> {\n    /**\n     * Generates a radial line for the given array of data. Depending on this radial line generator’s associated curve,\n     * the given input data may need to be sorted by x-value before being passed to the line generator.\n     *\n     * IMPORTANT: If the rendering context of the radial line generator is null,\n     * then the radial line is returned as a path data string.\n     *\n     * @param data Array of data elements.\n     */\n    (data: Iterable<Datum> | Datum[]): string | null;\n    /**\n     * Generates a radial line for the given array of data. Depending on this radial line generator’s associated curve,\n     * the given input data may need to be sorted by x-value before being passed to the radial line generator.\n     *\n     * IMPORTANT: If the radial line generator has been configured with a rendering context,\n     * then the radial line is rendered to this context as a sequence of path method calls and this function returns void.\n     *\n     * @param data Array of data elements.\n     */\n    (data: Iterable<Datum> | Datum[]): void;\n\n    /**\n     * Returns the current angle accessor function, which defaults to a function returning first element of a two-element array of numbers.\n     */\n    angle(): (d: Datum, index: number, data: Datum[]) => number;\n    /**\n     * Sets the angle accessor to the specified number and returns this radial line generator.\n     *\n     * @param angle A constant angle value in radians, with 0 at -y (12 o’clock).\n     */\n    angle(angle: number): this;\n    /**\n     * Sets the angle accessor to the specified function and returns this radial line generator.\n     *\n     * When a radial line is generated, the angle accessor will be invoked for each defined element in the input data array.\n     *\n     * The default angle accessor assumes that the input data are two-element arrays of numbers. If your data are in a different format, or if you wish to transform the data before rendering,\n     * then you should specify a custom accessor.\n     *\n     * @param angle An angle accessor function which returns the angle value in radians, with 0 at -y (12 o’clock). The angle accessor will be invoked for each defined element in the input data array,\n     * being passed the element d, the index i, and the array data as three arguments.\n     */\n    angle(angle: (d: Datum, index: number, data: Datum[]) => number): this;\n\n    /**\n     * Returns the current radius accessor function, which defaults to a function returning second element of a two-element array of numbers.\n     */\n    radius(): (d: Datum, index: number, data: Datum[]) => number;\n    /**\n     * Sets the radius accessor to the specified number and returns this radial line generator.\n     *\n     * @param radius A constant radius value.\n     */\n    radius(radius: number): this;\n    /**\n     * Sets the radius accessor to the specified function and returns this radial line generator.\n     *\n     * When a radial line is generated, the radius accessor will be invoked for each defined element in the input data array.\n     *\n     * The default radius accessor assumes that the input data are two-element arrays of numbers. If your data are in a different format, or if you wish to transform the data before rendering,\n     * then you should specify a custom accessor.\n     *\n     * @param radius A radius accessor function which returns the radius value. The radius accessor will be invoked for each defined element in the input data array,\n     * being passed the element d, the index i, and the array data as three arguments.\n     */\n    radius(radius: (d: Datum, index: number, data: Datum[]) => number): this;\n\n    /**\n     * Returns the current defined accessor, which defaults to a function returning a constant boolean value of true.\n     */\n    defined(): (d: Datum, index: number, data: Datum[]) => boolean;\n    /**\n     * Sets the defined accessor to the specified boolean and returns this radial line generator.\n     *\n     * The default accessor for defined returns a constant boolean value of true, thus assumes that the input data is always defined.\n     *\n     * When a radial line is generated, the defined accessor will be invoked for each element in the input data array,\n     * being passed the element d, the index i, and the array data as three arguments.\n     * If the given element is defined (i.e., if the defined accessor returns a truthy value for this element),\n     * the angle and radius accessors will subsequently be evaluated and the point will be added to the current radial line segment.\n     * Otherwise, the element will be skipped, the current radial line segment will be ended, and a new radial line segment will be generated for the next defined point.\n     * As a result, the generated radial line may have several discrete segments.\n     *\n     * Note that if a radial line segment consists of only a single point, it may appear invisible unless rendered with rounded or square line caps.\n     * In addition, some curves such as curveCardinalOpen only render a visible segment if it contains multiple points.\n     *\n     * @param defined A boolean constant.\n     */\n    defined(defined: boolean): this;\n    /**\n     * Sets the defined accessor to the specified function and returns this radial line generator.\n     *\n     * The default accessor for defined returns a constant boolean value of true, thus assumes that the input data is always defined.\n     *\n     * When a radial line is generated, the defined accessor will be invoked for each element in the input data array,\n     * being passed the element d, the index i, and the array data as three arguments.\n     * If the given element is defined (i.e., if the defined accessor returns a truthy value for this element),\n     * the angle and radius accessors will subsequently be evaluated and the point will be added to the current radial line segment.\n     * Otherwise, the element will be skipped, the current radial line segment will be ended, and a new radial line segment will be generated for the next defined point.\n     * As a result, the generated radial line may have several discrete segments.\n     *\n     * Note that if a radial line segment consists of only a single point, it may appear invisible unless rendered with rounded or square line caps.\n     * In addition, some curves such as curveCardinalOpen only render a visible segment if it contains multiple points.\n     *\n     * @param defined An accessor function which returns a boolean value. The accessor will be invoked for each defined element in the input data array,\n     * being passed the element d, the index i, and the array data as three arguments.\n     */\n    defined(defined: (d: Datum, index: number, data: Datum[]) => boolean): this;\n\n    /**\n     * Returns the current curve factory, which defaults to curveLinear.\n     */\n    curve(): CurveFactory | CurveFactoryLineOnly;\n    /**\n     * Returns the current curve factory, which defaults to curveLinear.\n     *\n     * The generic allows to cast the curve factory to a specific type, if known.\n     */\n    // eslint-disable-next-line @definitelytyped/no-unnecessary-generics\n    curve<C extends CurveFactory | CurveFactoryLineOnly>(): C;\n    /**\n     * Sets the curve factory and returns this radial line generator.\n     *\n     * Note that curveMonotoneX or curveMonotoneY are not recommended for radial lines because they assume that the data is monotonic in x or y,\n     * which is typically untrue of radial lines.\n     *\n     * @param curve A valid curve factory.\n     */\n    curve(curve: CurveFactory | CurveFactoryLineOnly): this;\n\n    /**\n     * Returns the current rendering context, which defaults to null.\n     */\n    context(): CanvasRenderingContext2D | null;\n    /**\n     * Equivalent to line.context.\n     */\n    context(context: CanvasRenderingContext2D | null): this;\n}\n\n/**\n * Constructs a new radial line generator with the default settings.\n *\n * Ensure that the accessors used with the radial line generator correspond to the arguments passed into them,\n * or set them to constants as appropriate.\n */\nexport function lineRadial(): LineRadial<[number, number]>;\n/**\n * Constructs a new radial line generator with the default settings.\n *\n * Ensure that the accessors used with the radial line generator correspond to the arguments passed into them,\n * or set them to constants as appropriate.\n *\n * The generic refers to the data type of an element in the input array passed into the radial line generator.\n */\n// eslint-disable-next-line @definitelytyped/no-unnecessary-generics\nexport function lineRadial<Datum>(): LineRadial<Datum>;\n\n/**\n * @deprecated Use LineRadial<Datum>\n */\nexport type RadialLine<Datum> = LineRadial<Datum>;\n\n/**\n * @deprecated Use lineRadial()\n */\nexport function radialLine(): RadialLine<[number, number]>;\n/**\n * @deprecated Use lineRadial<Datum>()\n */\n// eslint-disable-next-line @definitelytyped/no-unnecessary-generics\nexport function radialLine<Datum>(): RadialLine<Datum>;\n\n// -----------------------------------------------------------------------------------\n// Area Generators\n// -----------------------------------------------------------------------------------\n\n/**\n * The area generator produces an area, as in an area chart. An area is defined by two bounding lines, either splines or polylines.\n * Typically, the two lines share the same x-values (x0 = x1), differing only in y-value (y0 and y1); most commonly, y0 is defined as a constant representing zero.\n * The first line (the topline) is defined by x1 and y1 and is rendered first; the second line (the baseline) is defined by x0 and y0 and is rendered second, with the points in reverse order.\n * With a curveLinear curve, this produces a clockwise polygon.\n *\n * The generic refers to the data type of an element in the input array passed into the area generator.\n */\nexport interface Area<Datum> {\n    /**\n     * Generates an area for the given array of data. Depending on this area generator’s associated curve,\n     * the given input data may need to be sorted by x-value before being passed to the area generator.\n     *\n     * IMPORTANT: If the rendering context of the area generator is null,\n     * then the area is returned as a path data string.\n     *\n     * @param data Array of data elements.\n     */\n    (data: Iterable<Datum> | Datum[]): string | null;\n    /**\n     * Generates an area for the given array of data. Depending on this area generator’s associated curve,\n     * the given input data may need to be sorted by x-value before being passed to the area generator.\n     *\n     * IMPORTANT: If the area generator has been configured with a rendering context,\n     * then the area is rendered to this context as a sequence of path method calls and this function returns void.\n     *\n     * @param data Array of data elements.\n     */\n    (data: Iterable<Datum> | Datum[]): void;\n\n    /**\n     * Returns the current x0 accessor. The default x0 accessor is a function returning the first element of a\n     * two-element array of numbers.\n     */\n    x(): (d: Datum, index: number, data: Datum[]) => number;\n    /**\n     * Sets x0 to a constant number x and x1 to null and returns this area generator.\n     *\n     * Setting x1 to null indicates that the previously-computed x0 value should be reused for the x1 value.\n     *\n     * @param x A constant value to be used for x0.\n     */\n    x(x: number): this;\n    /**\n     * Sets x0 to the specified function x and x1 to null and returns this area generator.\n     *\n     * The default x0 accessor assumes that the input data are two-element arrays of numbers and returns the first element.\n     * If your data are in a different format, or if you wish to transform the data before rendering, then you should specify a custom accessor.\n     *\n     * @param x An accessor function returning a value to be used for x0. The accessor will be invoked for each defined element in the input data array,\n     * being passed the element d, the index i, and the array data as three arguments.\n     */\n    x(x: (d: Datum, index: number, data: Datum[]) => number): this;\n\n    /**\n     * Returns the current x0 accessor. The default x0 accessor is a function returning the first element of a\n     * two-element array of numbers.\n     */\n    x0(): (d: Datum, index: number, data: Datum[]) => number;\n    /**\n     * Sets x0 to a constant number and returns this area generator.\n     *\n     * @param x A constant value.\n     */\n    x0(x: number): this;\n    /**\n     * Sets x0 to the specified function and returns this area generator.\n     *\n     * The default x0 accessor assumes that the input data are two-element arrays of numbers and returns the first element.\n     * If your data are in a different format, or if you wish to transform the data before rendering, then you should specify a custom accessor.\n     *\n     * @param x An accessor function returning a value to be used for x0. The accessor will be invoked for each defined element in the input data array,\n     * being passed the element d, the index i, and the array data as three arguments.\n     */\n    x0(x: (d: Datum, index: number, data: Datum[]) => number): this;\n\n    /**\n     * Returns the current x1 accessor, which defaults to null, indicating that the previously-computed x0 value should be reused for the x1 value.\n     */\n    x1(): ((d: Datum, index: number, data: Datum[]) => number) | null;\n    /**\n     * Sets the x1 accessor to the specified number and returns this area generator.\n     */\n    x1(x: null | number): this;\n    /**\n     * Sets x1 to the specified function and returns this area generator.\n     *\n     * The default x1 accessor is null, indicating that the previously-computed x0 value should be reused for the x1 value.\n     * If your data are in a different format, or if you wish to transform the data before rendering, then you should specify a custom accessor.\n     *\n     * @param x An accessor function returning a value to be used for x1. The accessor will be invoked for each defined element in the input data array,\n     * being passed the element d, the index i, and the array data as three arguments.\n     */\n    x1(x: (d: Datum, index: number, data: Datum[]) => number): this;\n\n    /**\n     * Returns the current y0 accessor. The default y0 accessor is a function returning a constant value of zero.\n     */\n    y(): (d: Datum, index: number, data: Datum[]) => number;\n    /**\n     * Sets y0 to a constant number y and y1 to null and returns this area generator.\n     *\n     * Setting y1 to null indicates that the previously-computed y0 value should be reused for the y1 value.\n     *\n     * @param y A constant value to be used for y0.\n     */\n    y(y: number): this;\n    /**\n     * Sets y0 to the accessor function y and y1 to null and returns this area generator.\n     *\n     * The default y0 accessor returns a constant value of zero.\n     * If your data are in a different format, or if you wish to transform the data before rendering, then you should specify a custom accessor.\n     *\n     * @param y An accessor function returning a value to be used for y0. The accessor will be invoked for each defined element in the input data array,\n     * being passed the element d, the index i, and the array data as three arguments.\n     */\n    y(y: (d: Datum, index: number, data: Datum[]) => number): this;\n\n    /**\n     * Returns the current y0 accessor. The default y0 accessor is a function a constant value of zero.\n     */\n    y0(): (d: Datum, index: number, data: Datum[]) => number;\n    /**\n     * Sets y0 to a constant number and returns this area generator.\n     *\n     * @param y A constant value.\n     */\n    y0(y: number): this;\n    /**\n     * Sets y0 to the specified function and returns this area generator.\n     *\n     * The default y0 accessor is a function which returns a constant value of zero.\n     * If your data are in a different format, or if you wish to transform the data before rendering, then you should specify a custom accessor.\n     *\n     * @param y An accessor function returning a value to be used for y0. The accessor will be invoked for each defined element in the input data array,\n     * being passed the element d, the index i, and the array data as three arguments.\n     */\n    y0(y: (d: Datum, index: number, data: Datum[]) => number): this;\n\n    /**\n     * Returns the current y1 accessor or null. The default y1 accessor is a function returning the second element of a\n     * two-element array of numbers.\n     *\n     * If the y1 accessor is null, the previously-computed y0 value is reused for the y1 value.\n     */\n    y1(): ((d: Datum, index: number, data: Datum[]) => number) | null;\n    /**\n     * sets the y1 accessor to the specified number and returns this area generator.\n     */\n    y1(y: null | number): this;\n    /**\n     * Sets y1 to the specified function and returns this area generator.\n     *\n     * The default y1 accessor assumes that the input data are two-element arrays of numbers and returns the second element.\n     * If your data are in a different format, or if you wish to transform the data before rendering, then you should specify a custom accessor.\n     *\n     * @param y An accessor function returning a value to be used for y1. The accessor will be invoked for each defined element in the input data array,\n     * being passed the element d, the index i, and the array data as three arguments.\n     */\n    y1(y: (d: Datum, index: number, data: Datum[]) => number): this;\n\n    /**\n     * Returns the current defined accessor, which defaults to a function returning a constant boolean value of true.\n     */\n    defined(): (d: Datum, index: number, data: Datum[]) => boolean;\n    /**\n     * Sets the defined accessor to the specified boolean and returns this area generator.\n     *\n     * The default accessor for defined returns a constant boolean value of true, thus assumes that the input data is always defined.\n     * When an area is generated, the defined accessor will be invoked for each element in the input data array, being passed the element d, the index i, and the array data as three arguments.\n     * If the given element is defined (i.e., if the defined accessor returns a truthy value for this element),\n     * the x0, x1, y0 and y1 accessors will subsequently be evaluated and the point will be added to the current area segment.\n     * Otherwise, the element will be skipped, the current area segment will be ended, and a new area segment will be generated for the next defined point.\n     * As a result, the generated area may have several discrete segments.\n     *\n     * Note that if an area segment consists of only a single point, it may appear invisible unless rendered with rounded or square line caps.\n     * In addition, some curves such as curveCardinalOpen only render a visible segment if it contains multiple points.\n     *\n     * @param defined A boolean constant.\n     */\n    defined(defined: boolean): this;\n    /**\n     * Sets the defined accessor to the specified function and returns this area generator.\n     *\n     * The default accessor for defined returns a constant boolean value of true, thus assumes that the input data is always defined.\n     *\n     * The default accessor for defined returns a constant boolean value of true, thus assumes that the input data is always defined.\n     * When an area is generated, the defined accessor will be invoked for each element in the input data array,\n     * being passed the element d, the index i, and the array data as three arguments.\n     * If the given element is defined (i.e., if the defined accessor returns a truthy value for this element),\n     * the x0, x1, y0 and y1 accessors will subsequently be evaluated and the point will be added to the current area segment.\n     * Otherwise, the element will be skipped, the current area segment will be ended, and a new area segment will be generated for the next defined point.\n     * As a result, the generated area may have several discrete segments.\n     *\n     * Note that if an area segment consists of only a single point, it may appear invisible unless rendered with rounded or square line caps.\n     * In addition, some curves such as curveCardinalOpen only render a visible segment if it contains multiple points.\n     *\n     * @param defined An accessor function which returns a boolean value. The accessor will be invoked for each defined element in the input data array,\n     * being passed the element d, the index i, and the array data as three arguments.\n     */\n    defined(defined: (d: Datum, index: number, data: Datum[]) => boolean): this;\n\n    /**\n     * Returns the current curve factory, which defaults to curveLinear.\n     */\n    curve(): CurveFactory;\n    /**\n     * Returns the current curve factory, which defaults to curveLinear.\n     *\n     * The generic allows to cast the curve factory to a specific type, if known.\n     */\n    // eslint-disable-next-line @definitelytyped/no-unnecessary-generics\n    curve<C extends CurveFactory>(): C;\n    /**\n     * Sets the curve factory and returns this area generator.\n     *\n     * @param curve A valid curve factory.\n     */\n    curve(curve: CurveFactory): this;\n\n    /**\n     * Returns the current rendering context, which defaults to null.\n     */\n    context(): CanvasRenderingContext2D | null;\n    /**\n     * Sets the context and returns this area generator.\n     */\n    context(context: CanvasRenderingContext2D | null): this;\n\n    /**\n     * Returns a new line generator that has this area generator’s current defined accessor, curve and context.\n     * The line’s x-accessor is this area’s x0-accessor, and the line’s y-accessor is this area’s y0-accessor.\n     */\n    lineX0(): Line<Datum>;\n    /**\n     * Returns a new line generator that has this area generator’s current defined accessor, curve and context.\n     * The line’s x-accessor is this area’s x0-accessor, and the line’s y-accessor is this area’s y0-accessor.\n     */\n    lineY0(): Line<Datum>;\n\n    /**\n     * Returns a new line generator that has this area generator’s current defined accessor, curve and context.\n     * The line’s x-accessor is this area’s x1-accessor, and the line’s y-accessor is this area’s y0-accessor.\n     */\n    lineX1(): Line<Datum>;\n    /**\n     * Returns a new line generator that has this area generator’s current defined accessor, curve and context.\n     * The line’s x-accessor is this area’s x0-accessor, and the line’s y-accessor is this area’s y1-accessor.\n     */\n    lineY1(): Line<Datum>;\n}\n\n/**\n * Constructs a new area generator with the default settings.\n *\n * If x, y0 or y1 are specified, sets the corresponding accessors to the specified function or number and returns this area generator.\n *\n * The generic refers to the data type of an element in the input array passed into the area generator.\n *\n * @param x Sets the x accessor.\n * @param y0 Sets the y0 accessor.\n * @param y1 Sets the y1 accessor.\n */\nexport function area<Datum = [number, number]>(\n    x?: number | ((d: Datum, index: number, data: Datum[]) => number),\n    y0?: number | ((d: Datum, index: number, data: Datum[]) => number),\n    y1?: number | ((d: Datum, index: number, data: Datum[]) => number),\n): Area<Datum>;\n\n/**\n * A radial area generator.\n *\n * A radial area generator is equivalent to the standard Cartesian area generator,\n * except the x and y accessors are replaced with angle and radius accessors.\n * Radial areas are always positioned relative to ⟨0,0⟩; use a transform (see: SVG, Canvas) to change the origin.\n *\n * The generic refers to the data type of an element in the input array passed into the area generator.\n */\nexport interface AreaRadial<Datum> {\n    /**\n     * Generates a radial area for the given array of data.\n     *\n     * IMPORTANT: If the rendering context of the radial area generator is null,\n     * then the radial area is returned as a path data string.\n     *\n     * @param data Array of data elements.\n     */\n    (data: Iterable<Datum> | Datum[]): string | null;\n    /**\n     * Generates a radial area for the given array of data.\n     *\n     * IMPORTANT: If the radial area generator has been configured with a rendering context,\n     * then the radial area is rendered to this context as a sequence of path method calls and this function returns void.\n     *\n     * @param data Array of data elements.\n     */\n    (data: Iterable<Datum> | Datum[]): void;\n\n    /**\n     * Returns the current startAngle accessor. The default startAngle accessor is a function returning the first element of a\n     * two-element array of numbers.\n     */\n    angle(): (d: Datum, index: number, data: Datum[]) => number;\n    /**\n     * Sets startAngle to a constant number angle and endAngle to null and returns this radial area generator.\n     *\n     * Setting endAngle to null indicates that the previously-computed startAngle value should be reused for the endAngle value.\n     *\n     * @param angle A constant value in radians with 0 at -y (12 o’clock).\n     */\n    angle(angle: number): this;\n    /**\n     * Sets startAngle to the specified function angle and endAngle to null and returns this radial area generator.\n     *\n     * The default startAngle accessor assumes that the input data are two-element arrays of numbers and returns the first element.\n     * If your data are in a different format, or if you wish to transform the data before rendering, then you should specify a custom accessor.\n     *\n     * @param angle An accessor function returning a value to be used for startAngle in radians with 0 at -y (12 o’clock).\n     * The accessor will be invoked for each defined element in the input data array,\n     * being passed the element d, the index i, and the array data as three arguments.\n     */\n    angle(angle: (d: Datum, index: number, data: Datum[]) => number): this;\n\n    /**\n     * Returns the current startAngle accessor. The default startAngle accessor is a function returning the first element of a\n     * two-element array of numbers.\n     */\n    startAngle(): (d: Datum, index: number, data: Datum[]) => number;\n    /**\n     * Sets startAngle to a constant number and returns this radial area generator.\n     *\n     * @param angle A constant value in radians with 0 at -y (12 o’clock).\n     */\n    startAngle(angle: number): this;\n    /**\n     * Sets startAngle to the specified function and returns this radial area generator.\n     *\n     * The default startAngle accessor assumes that the input data are two-element arrays of numbers and returns the first element.\n     * If your data are in a different format, or if you wish to transform the data before rendering, then you should specify a custom accessor.\n     *\n     * @param angle An accessor function returning a value to be used for startAngle in radians with 0 at -y (12 o’clock).\n     * The accessor will be invoked for each defined element in the input data array,\n     * being passed the element d, the index i, and the array data as three arguments.\n     */\n    startAngle(angle: (d: Datum, index: number, data: Datum[]) => number): this;\n\n    /**\n     * Returns the current endAngle accessor, which defaults to null, indicating that the previously-computed startAngle value should be reused for the endAngle value.\n     */\n    endAngle(): ((d: Datum, index: number, data: Datum[]) => number) | null;\n    /**\n     * Equivalent to area.x1, except the accessor returns the angle in radians, with 0 at -y (12 o’clock).\n     * Note: typically angle is used instead of setting separate start and end angles.\n     */\n    endAngle(angle: null | number): this;\n    /**\n     * Sets endAngle to the specified function and returns this radial area generator.\n     *\n     * The default endAngle accessor is null, indicating that the previously-computed startAngle value should be reused for the endAngle value.\n     * If your data are in a different format, or if you wish to transform the data before rendering, then you should specify a custom accessor.\n     *\n     * @param angle An accessor function returning a value to be used for endAngle in radians with 0 at -y (12 o’clock).\n     * The accessor will be invoked for each defined element in the input data array,\n     * being passed the element d, the index i, and the array data as three arguments.\n     */\n    endAngle(angle: (d: Datum, index: number, data: Datum[]) => number): this;\n\n    /**\n     * Returns the current innerRadius accessor. The default innerRadius accessor is a function returning a constant value of zero.\n     */\n    radius(): (d: Datum, index: number, data: Datum[]) => number;\n    /**\n     * Sets innerRadius to a constant number radius and outerRadius to null and returns this radial area generator.\n     *\n     * Setting outerRadius to null indicates that the previously-computed innerRadius value should be reused for the outerRadius value.\n     *\n     * @param radius A constant value to be used for innerRadius.\n     */\n    radius(radius: number): this;\n    /**\n     * Sets innerRadius to the accessor function radius and outerRadius to null and returns this radial area generator.\n     *\n     * The default innerRadius accessor returns a constant value of zero.\n     * If your data are in a different format, or if you wish to transform the data before rendering, then you should specify a custom accessor.\n     *\n     * @param radius An accessor function returning a value to be used for innerRadius. The accessor will be invoked for each defined element in the input data array,\n     * being passed the element d, the index i, and the array data as three arguments.\n     */\n    radius(radius: (d: Datum, index: number, data: Datum[]) => number): this;\n\n    /**\n     * Returns the current innerRadius accessor. The default innerRadius accessor is a function a constant value of zero.\n     */\n    innerRadius(): (d: Datum, index: number, data: Datum[]) => number;\n    /**\n     * Sets innerRadius to a constant number and returns this radial area generator.\n     *\n     * @param radius A constant value.\n     */\n    innerRadius(radius: number): this;\n    /**\n     * Sets innerRadius to the specified function and returns this radial area generator.\n     *\n     * The default innerRadius accessor is a function which returns a constant value of zero.\n     * If your data are in a different format, or if you wish to transform the data before rendering, then you should specify a custom accessor.\n     *\n     * @param radius An accessor function returning a value to be used for innerRadius. The accessor will be invoked for each defined element in the input data array,\n     * being passed the element d, the index i, and the array data as three arguments.\n     */\n    innerRadius(radius: (d: Datum, index: number, data: Datum[]) => number): this;\n\n    /**\n     * Returns the current outerRadius accessor or null. The default outerRadius accessor is a function returning the second element of a\n     * two-element array of numbers.\n     *\n     * If the outerRadius accessor is null, the previously-computed innerRadius value is reused for the outerRadius value.\n     */\n    outerRadius(): ((d: Datum, index: number, data: Datum[]) => number) | null;\n    /**\n     * Equivalent to area.y1, except the accessor returns the radius: the distance from the origin ⟨0,0⟩.\n     */\n    outerRadius(radius: null | number): this;\n    /**\n     * Sets outerRadius to the specified function and returns this radial area generator.\n     *\n     * The default outerRadius accessor assumes that the input data are two-element arrays of numbers and returns the second element.\n     * If your data are in a different format, or if you wish to transform the data before rendering, then you should specify a custom accessor.\n     *\n     * @param radius An accessor function returning a value to be used for outerRadius. The accessor will be invoked for each defined element in the input data array,\n     * being passed the element d, the index i, and the array data as three arguments.\n     */\n    outerRadius(radius: (d: Datum, index: number, data: Datum[]) => number): this;\n\n    /**\n     * Returns the current defined accessor, which defaults to a function returning a constant boolean value of true.\n     */\n    defined(): (d: Datum, index: number, data: Datum[]) => boolean;\n    /**\n     * Sets the defined accessor to the specified boolean and returns this radial area generator.\n     *\n     * The default accessor for defined returns a constant boolean value of true, thus assumes that the input data is always defined.\n     *\n     * When a radial area is generated, the defined accessor will be invoked for each element in the input data array, being passed the element d, the index i, and the array data as three arguments.\n     * If the given element is defined (i.e., if the defined accessor returns a truthy value for this element),\n     * the startAngle, endAngle, innerRadius and outerRadius accessors will subsequently be evaluated and the point will be added to the current area segment.\n     *\n     * Otherwise, the element will be skipped, the current area segment will be ended, and a new area segment will be generated for the next defined point.\n     * As a result, the generated area may have several discrete segments.\n     *\n     * Note that if an area segment consists of only a single point, it may appear invisible unless rendered with rounded or square line caps.\n     * In addition, some curves such as curveCardinalOpen only render a visible segment if it contains multiple points.\n     *\n     * @param defined A boolean constant.\n     */\n    defined(defined: boolean): this;\n    /**\n     * Sets the defined accessor to the specified function and returns this radial area generator.\n     *\n     * The default accessor for defined returns a constant boolean value of true, thus assumes that the input data is always defined.\n     *\n     * When a radial area is generated, the defined accessor will be invoked for each element in the input data array, being passed the element d, the index i, and the array data as three arguments.\n     * If the given element is defined (i.e., if the defined accessor returns a truthy value for this element),\n     * the startAngle, endAngle, innerRadius and outerRadius accessors will subsequently be evaluated and the point will be added to the current area segment.\n     *\n     * Otherwise, the element will be skipped, the current area segment will be ended, and a new area segment will be generated for the next defined point.\n     * As a result, the generated area may have several discrete segments.\n     *\n     * Note that if an area segment consists of only a single point, it may appear invisible unless rendered with rounded or square line caps.\n     * In addition, some curves such as curveCardinalOpen only render a visible segment if it contains multiple points.\n     *\n     * @param defined An accessor function which returns a boolean value. The accessor will be invoked for each defined element in the input data array,\n     * being passed the element d, the index i, and the array data as three arguments.\n     */\n    defined(defined: (d: Datum, index: number, data: Datum[]) => boolean): this;\n\n    /**\n     * Returns the current curve factory, which defaults to curveLinear.\n     */\n    curve(): CurveFactory;\n    /**\n     * Returns the current curve factory, which defaults to curveLinear.\n     *\n     * The generic allows to cast the curve factory to a specific type, if known.\n     */\n    // eslint-disable-next-line @definitelytyped/no-unnecessary-generics\n    curve<C extends CurveFactory>(): C;\n    /**\n     * Sets the curve factory and returns this radial area generator.\n     *\n     * Note that curveMonotoneX or curveMonotoneY are not recommended for radial areas because they assume that the data is monotonic in x or y, which is typically untrue of radial areas.\n     *\n     * @param curve A valid curve factory.\n     */\n    curve(curve: CurveFactory): this;\n\n    /**\n     * Returns the current rendering context, which defaults to null.\n     */\n    context(): CanvasRenderingContext2D | null;\n    /**\n     * Equivalent to line.context.\n     */\n    context(context: CanvasRenderingContext2D | null): this;\n\n    /**\n     * Returns a new radial line generator that has this radial area generator’s current defined accessor, curve and context.\n     * The line’s angle accessor is this area’s start angle accessor, and the line’s radius accessor is this area’s inner radius accessor.\n     */\n    lineStartAngle(): LineRadial<Datum>;\n\n    /**\n     * Returns a new radial line generator that has this radial area generator’s current defined accessor, curve and context.\n     * The line’s angle accessor is this area’s start angle accessor, and the line’s radius accessor is this area’s inner radius accessor.\n     */\n    lineInnerRadius(): LineRadial<Datum>;\n\n    /**\n     * Returns a new radial line generator that has this radial area generator’s current defined accessor, curve and context.\n     * The line’s angle accessor is this area’s end angle accessor, and the line’s radius accessor is this area’s inner radius accessor.\n     */\n    lineEndAngle(): LineRadial<Datum>;\n\n    /**\n     * Returns a new radial line generator that has this radial area generator’s current defined accessor, curve and context.\n     * The line’s angle accessor is this area’s start angle accessor, and the line’s radius accessor is this area’s outer radius accessor.\n     */\n    lineOuterRadius(): LineRadial<Datum>;\n}\n\n/**\n * Constructs a new radial area generator with the default settings.\n *\n * Ensure that the accessors used with the area generator correspond to the arguments passed into them,\n * or set them to constants as appropriate.\n */\nexport function areaRadial(): AreaRadial<[number, number]>;\n/**\n * Constructs a new radial area generator with the default settings.\n *\n * Ensure that the accessors used with the area generator correspond to the arguments passed into them,\n * or set them to constants as appropriate.\n *\n * The generic refers to the data type of an element in the input array passed into the radial area generator.\n */\n// eslint-disable-next-line @definitelytyped/no-unnecessary-generics\nexport function areaRadial<Datum>(): AreaRadial<Datum>;\n\n/**\n * @deprecated Use AreaRadial interface\n */\nexport type RadialArea<Datum> = AreaRadial<Datum>;\n\n/**\n * @deprecated Use areaRadial()\n */\nexport function radialArea(): RadialArea<[number, number]>;\n/**\n * @deprecated Use areaRadial<Datum>()\n */\n// eslint-disable-next-line @definitelytyped/no-unnecessary-generics\nexport function radialArea<Datum>(): RadialArea<Datum>;\n\n// -----------------------------------------------------------------------------------\n// Curve Factories\n// -----------------------------------------------------------------------------------\n\n/**\n * A minimal interface for a curve generator which supports only the rendering of lines.\n * Methods for related to the rendering of areas are not implemented in this minimal interface.\n *\n * While lines are defined as a sequence of two-dimensional [x, y] points,\n * there remains the task of transforming this discrete representation into a continuous shape: i.e., how to interpolate between the points.\n * A curve generator serves this purpose.\n *\n * Curves are typically not constructed or used directly, instead being passed to line.curve.\n */\nexport interface CurveGeneratorLineOnly {\n    /**\n     * Indicates the start of a new line segment. Zero or more points will follow.\n     */\n    lineStart(): void;\n    /**\n     * Indicates the end of the current line segment.\n     */\n    lineEnd(): void;\n    /**\n     * Indicates a new point in the current line segment with the given x- and y-values.\n     */\n    point(x: number, y: number): void;\n}\n\n/**\n * A factory for curve generators addressing only lines, but not areas.\n */\nexport type CurveFactoryLineOnly =\n    /**\n     * Returns a \"lines only\" curve generator which renders to the specified context.\n     *\n     * @param context A rendering context.\n     */\n    (context: CanvasRenderingContext2D | Path) => CurveGeneratorLineOnly;\n\n/**\n * A minimal interface for a curve generator which supports the rendering of lines and areas.\n *\n * While lines are defined as a sequence of two-dimensional [x, y] points,\n * and areas are similarly defined by a topline and a baseline,\n * there remains the task of transforming this discrete representation into a continuous shape: i.e., how to interpolate between the points.\n * A curve generator serves this purpose.\n *\n * Curves are typically not constructed or used directly, instead being passed to line.curve and area.curve.\n */\nexport interface CurveGenerator extends CurveGeneratorLineOnly {\n    /**\n     * Indicates the start of a new area segment.\n     * Each area segment consists of exactly two line segments: the topline, followed by the baseline, with the baseline points in reverse order.\n     */\n    areaStart(): void;\n    /**\n     * Indicates the end of the current area segment.\n     */\n    areaEnd(): void;\n}\n\n/**\n * A factory for curve generators addressing both lines and areas.\n */\nexport type CurveFactory =\n    /**\n     * Returns a curve generator which renders to the specified context.\n     *\n     * @param context A rendering context.\n     */\n    (context: CanvasRenderingContext2D | Path) => CurveGenerator;\n\n/**\n * A curve factory for cubic basis spline generators.\n *\n * The curve generators produce a cubic basis spline using the specified control points.\n * The first and last points are triplicated such that the spline starts at the first point and ends at the last point,\n * and is tangent to the line between the first and second points, and to the line between the penultimate and last points.\n */\nexport const curveBasis: CurveFactory;\n\n/**\n * A curve factory for closed cubic basis spline generators.\n *\n * The curve generators produce a closed cubic basis spline using the specified control points.\n * When a line segment ends, the first three control points are repeated, producing a closed loop with C2 continuity.\n */\nexport const curveBasisClosed: CurveFactory;\n\n/**\n * A curve factory for open cubic basis spline generators.\n *\n * The curve generators produce a cubic basis spline using the specified control points.\n * Unlike basis, the first and last points are not repeated, and thus the curve typically does not intersect these points.\n */\nexport const curveBasisOpen: CurveFactory;\n\n/**\n * Produces a Bézier curve between each pair of points, with horizontal tangents at each point.\n */\nexport const curveBumpX: CurveFactory;\n\n/**\n * Produces a Bézier curve between each pair of points, with vertical tangents at each point.\n */\nexport const curveBumpY: CurveFactory;\n\n/**\n * A curve factory for straightened cubic basis spline generators.\n *\n * The curve generators produce a straightened cubic basis spline using the specified control points,\n * with the spline straightened according to the curve’s beta, which defaults to 0.85.\n * This curve is typically used in hierarchical edge bundling to disambiguate connections,\n * as proposed by Danny Holten in Hierarchical Edge Bundles: Visualization of Adjacency Relations in Hierarchical Data.\n *\n * This curve does not implement curve.areaStart and curve.areaEnd; it is intended to work with d3.line, not d3.area.\n */\nexport interface CurveBundleFactory extends CurveFactoryLineOnly {\n    /**\n     * Returns a bundle curve factory with the specified beta in the range [0, 1], representing the bundle strength.\n     * If beta equals zero, a straight line between the first and last point is produced; if beta equals one,\n     * a standard basis spline is produced.\n     *\n     * @param beta A constant value in the [0, 1] interval.\n     */\n    beta(beta: number): this;\n}\n\n/**\n * A curve factory for straightened cubic basis spline generators.\n *\n * The curve generators produce a straightened cubic basis spline using the specified control points,\n * with the spline straightened according to the curve’s beta, which defaults to 0.85.\n * This curve is typically used in hierarchical edge bundling to disambiguate connections,\n * as proposed by Danny Holten in Hierarchical Edge Bundles: Visualization of Adjacency Relations in Hierarchical Data.\n *\n * This curve does not implement curve.areaStart and curve.areaEnd; it is intended to work with d3.line, not d3.area.\n */\nexport const curveBundle: CurveBundleFactory;\n\n/**\n * A curve factory for cubic cardinal spline generators.\n */\nexport interface CurveCardinalFactory extends CurveFactory {\n    /**\n     * Returns a cardinal curve factory with the specified tension in the range [0, 1].\n     * The tension determines the length of the tangents: a tension of one yields all zero tangents, equivalent to curveLinear; a tension of zero produces a uniform Catmull–Rom spline.\n     *\n     * @param tension A constant in the [0, 1] interval.\n     */\n    tension(tension: number): this;\n}\n\n/**\n * A curve factory for cubic cardinal spline generators.\n *\n * The curve generators produce a cubic cardinal spline using the specified control points, with one-sided differences used for the first and last piece.\n * The default tension is 0.\n */\nexport const curveCardinal: CurveCardinalFactory;\n\n/**\n * A curve factory for closed cubic cardinal spline generators.\n *\n * The curve generators produce closed cubic cardinal spline using the specified control points.\n * When a line segment ends, the first three control points are repeated, producing a closed loop.\n * The default tension is 0.\n */\nexport const curveCardinalClosed: CurveCardinalFactory;\n\n/**\n * A curve factory for open cubic cardinal spline generators.\n *\n * The curve generators produce a cubic cardinal spline using the specified control points.\n * Unlike curveCardinal, one-sided differences are not used for the first and last piece,\n * and thus the curve starts at the second point and ends at the penultimate point.\n * The default tension is 0.\n */\nexport const curveCardinalOpen: CurveCardinalFactory;\n\n/**\n * A curve factory for cubic Catmull–Rom spline generators.\n */\nexport interface CurveCatmullRomFactory extends CurveFactory {\n    /**\n     * Returns a cubic Catmull–Rom curve factory with the specified alpha in the range [0, 1].\n     * If alpha is zero, produces a uniform spline, equivalent to curveCardinal with a tension of zero;\n     * if alpha is one, produces a chordal spline; if alpha is 0.5, produces a centripetal spline.\n     * Centripetal splines are recommended to avoid self-intersections and overshoot.\n     *\n     * @param alpha A constant in the [0, 1] interval.\n     */\n    alpha(alpha: number): this;\n}\n\n/**\n * A curve factory for cubic Catmull–Rom spline generators.\n *\n * The curve generators produce a cubic Catmull–Rom spline using the specified control points and the parameter alpha,\n * which defaults to 0.5, as proposed by Yuksel et al. in On the Parameterization of Catmull–Rom Curves,\n * with one-sided differences used for the first and last piece.\n */\nexport const curveCatmullRom: CurveCatmullRomFactory;\n\n/**\n * A curve factory for cubic Catmull–Rom spline generators.\n *\n * The curve generators produce a closed cubic Catmull–Rom spline using the specified control points and the parameter alpha,\n * which defaults to 0.5, as proposed by Yuksel et al. When a line segment ends,\n * the first three control points are repeated, producing a closed loop.\n */\nexport const curveCatmullRomClosed: CurveCatmullRomFactory;\n\n/**\n * A curve factory for cubic Catmull–Rom spline generators.\n *\n * The curve generators produce a cubic Catmull–Rom spline using the specified control points and the parameter alpha,\n * which defaults to 0.5, as proposed by Yuksel et al. Unlike curveCatmullRom, one-sided differences are not used for the first and last piece,\n * and thus the curve starts at the second point and ends at the penultimate point.\n */\nexport const curveCatmullRomOpen: CurveCatmullRomFactory;\n\n/**\n * A curve factory for polyline generators.\n *\n * The curve generators produce a polyline through the specified points.\n */\nexport const curveLinear: CurveFactory;\n\n/**\n * A curve factory for closed polyline generators.\n *\n * The curve generators produce a closed polyline through the specified points by repeating the first point when the line segment ends.\n */\nexport const curveLinearClosed: CurveFactory;\n\n/**\n * A curve factory for cubic spline generators preserving monotonicity in y.\n *\n * The curve generators produce a cubic spline that preserves monotonicity in y, assuming monotonicity in x, as proposed by Steffen in A simple method for monotonic interpolation in one dimension:\n * “a smooth curve with continuous first-order derivatives that passes through any given set of data points without spurious oscillations.\n * Local extrema can occur only at grid points where they are given by the data, but not in between two adjacent grid points.”\n */\nexport const curveMonotoneX: CurveFactory;\n\n/**\n * A curve factory for cubic spline generators preserving monotonicity in x.\n *\n * The curve generators produce a cubic spline that preserves monotonicity in x, assuming monotonicity in y, as proposed by Steffen in A simple method for monotonic interpolation in one dimension:\n * “a smooth curve with continuous first-order derivatives that passes through any given set of data points without spurious oscillations.\n * Local extrema can occur only at grid points where they are given by the data, but not in between two adjacent grid points.”\n */\nexport const curveMonotoneY: CurveFactory;\n\n/**\n * A curve factory for natural cubic spline generators.\n *\n * The curve generators produce a natural cubic spline with the second derivative of the spline set to zero at the endpoints.\n */\nexport const curveNatural: CurveFactory;\n\n/**\n * A curve factory for step function (midpoint) generators.\n *\n * The curve generators produce a piecewise constant function (a step function) consisting of alternating horizontal and vertical lines.\n * The y-value changes at the midpoint of each pair of adjacent x-values.\n */\nexport const curveStep: CurveFactory;\n\n/**\n * A curve factory for step function (after) generators.\n *\n * The curve generators produce a piecewise constant function (a step function) consisting of alternating horizontal and vertical lines.\n * The y-value changes after the x-value.\n */\nexport const curveStepAfter: CurveFactory;\n\n/**\n * A curve factory for step function (before) generators.\n *\n * The curve generators produce a piecewise constant function (a step function) consisting of alternating horizontal and vertical lines.\n * The y-value changes before the x-value.\n */\nexport const curveStepBefore: CurveFactory;\n\n// -----------------------------------------------------------------------------------\n// LINKS\n// -----------------------------------------------------------------------------------\n\n/**\n * An interface describing the default Link Data structure expected\n * by the Link and LinkRadial generators.\n */\nexport interface DefaultLinkObject {\n    /**\n     * Source node of the link.\n     *\n     * For a link in a Cartesian coordinate system, the two element array contains\n     * the coordinates [x, y].\n     *\n     * For a radial link, the two element array contains\n     * the coordinates [angle, radius]. The angle is stated in radians, with 0 at -y (12 o’clock).\n     * The radius measures the distance from the origin ⟨0,0⟩.\n     */\n    source: [number, number];\n    /**\n     * Target node of the link.\n     *\n     * For a link in a Cartesian coordinate system, the two element array contains\n     * the coordinates [x, y].\n     *\n     * For a radial link, the two element array contains\n     * the coordinates [angle, radius]. The angle is stated in radians, with 0 at -y (12 o’clock).\n     * The radius measures the distance from the origin ⟨0,0⟩.\n     */\n    target: [number, number];\n}\n\n/**\n * A link generator for a Cartesian coordinate system. The link shape generates a smooth cubic Bézier curve from a\n * source point to a target point. The tangents of the curve at the start and end are either vertical, horizontal.\n *\n * The first generic corresponds to the type of the \"this\" context within which the link generator and its accessor functions will be invoked.\n *\n * The second generic corresponds to the datum type of the link object for which the link is to be generated.\n *\n * The third generic corresponds to the datum type of the source/target node contained in the link object.\n */\nexport interface Link<This, LinkDatum, NodeDatum> {\n    /**\n     * Generates a link for the given arguments.\n     *\n     * IMPORTANT: If the rendering context of the link generator is null,\n     * then the link is returned as a path data string.\n     *\n     * The \"this\" context within which this function is invoked, will be the context within which the accessor methods of the generator are invoked.\n     * All arguments passed into this function, will be passed to the accessor functions of the generator.\n     *\n     * @param d The datum for which the link is to be generated.\n     */\n    (this: This, d: LinkDatum, ...args: any[]): string | null;\n    /**\n     * Generates an link for the given arguments.\n     *\n     * IMPORTANT: If the link generator has been configured with a rendering context,\n     * then the link is rendered to this context as a sequence of path method calls and this function returns void.\n     *\n     * The \"this\" context within which this function is invoked, will be the context within which the accessor methods of the generator are invoked.\n     * All arguments passed into this function, will be passed to the accessor functions of the generator.\n     *\n     * @param d The datum for which the link is to be generated.\n     */\n    (this: This, d: LinkDatum, ...args: any[]): void;\n\n    /**\n     * Returns the current source node accessor function.\n     * The default source accessor function returns a two element array [x, y].\n     */\n    source(): (this: This, d: LinkDatum, ...args: any[]) => NodeDatum;\n    /**\n     * Sets the source accessor to the specified function and returns this link generator.\n     *\n     * @param source Source node accessor function. The accessor function is invoked in the same \"this\" context as the generator was invoked in and\n     * receives the same arguments that were passed into the link generator. The default target accessor function returns a two element array [x, y].\n     */\n    source(source: (this: This, d: LinkDatum, ...args: any[]) => NodeDatum): this;\n\n    /**\n     * Returns the current target node accessor function.\n     * The default target accessor function returns a two element array [x, y].\n     */\n    target(): (this: This, d: LinkDatum, ...args: any[]) => NodeDatum;\n    /**\n     * Sets the target accessor to the specified function and returns this link generator.\n     *\n     * @param target Target node accessor function. The accessor function is invoked in the same \"this\" context as the generator was invoked in and\n     * receives the same arguments that were passed into the link generator. The default target accessor function returns a two element array [x, y].\n     */\n    target(target: (this: This, d: LinkDatum, ...args: any[]) => NodeDatum): this;\n\n    /**\n     * Returns the current x-accessor, which defaults to a function accepting an number array\n     * as its argument an returning the first element of the array.\n     */\n    x(): (this: This, node: NodeDatum, ...args: any[]) => number;\n    /**\n     * Sets the x-accessor to the specified function and returns this link generator.\n     *\n     * @param x x-coordinate accessor function. The accessor function is invoked in the same \"this\" context as the generator was invoked in and\n     * receives as its first argument a node object followed by all additional arguments that were passed into the link generator.\n     */\n    x(x: (this: This, node: NodeDatum, ...args: any[]) => number): this;\n\n    /**\n     * Returns the current y-accessor, which defaults to a function accepting an number array\n     * as its argument an returning the second element of the array.\n     */\n    y(): (this: This, node: NodeDatum, ...args: any[]) => number;\n    /**\n     * Sets the y-accessor to the specified function and returns this link generator.\n     *\n     * @param y y-coordinate accessor function. The accessor function is invoked in the same \"this\" context as the generator was invoked in and\n     * receives as its first argument a node object followed by all additional arguments that were passed into the link generator.\n     */\n    y(y: (this: This, node: NodeDatum, ...args: any[]) => number): this;\n\n    /**\n     * Returns the current rendering context, which defaults to null.\n     */\n    context(): CanvasRenderingContext2D | null;\n    /**\n     * Sets the context and returns this link generator.\n     */\n    context(context: CanvasRenderingContext2D | null): this;\n}\n\n/**\n * Returns a new link generator using the specified curve. For example, to visualize links in a tree diagram rooted on the top edge of the display\n *\n * With the default settings the link generator accepts a link object conforming to the DefaultLinkObject interface.\n */\nexport function link(curve: CurveFactory): Link<any, DefaultLinkObject, [number, number]>;\n/**\n * Returns a new link generator using the specified curve. For example, to visualize links in a tree diagram rooted on the top edge of the display\n *\n * Important: Ensure that the accessor functions are configured to work with the link and node datum types\n * specified in the generics.\n *\n * The first generic corresponds to the datum type of the link object for which the link is to be generated.\n *\n * The second generic corresponds to the datum type of the source/target node contained in the link object.\n */\n// eslint-disable-next-line @definitelytyped/no-unnecessary-generics\nexport function link<LinkDatum, NodeDatum>(curve: CurveFactory): Link<any, LinkDatum, NodeDatum>;\n/**\n * Returns a new link generator using the specified curve. For example, to visualize links in a tree diagram rooted on the top edge of the display\n *\n * Important: Ensure that the accessor functions are configured to work with the link and node datum types\n * specified in the generics.\n *\n * The first generic corresponds to the type of the \"this\" context within which the link generator and its accessor functions will be invoked.\n *\n * The second generic corresponds to the datum type of the link object for which the link is to be generated.\n *\n * The third generic corresponds to the datum type of the source/target node contained in the link object.\n */\n// eslint-disable-next-line @definitelytyped/no-unnecessary-generics\nexport function link<This, LinkDatum, NodeDatum>(curve: CurveFactory): Link<This, LinkDatum, NodeDatum>;\n\n/**\n * Shorthand for d3.link with d3.curveBumpX; suitable for visualizing links in a tree diagram rooted on the left edge of the display.\n *\n * With the default settings the link generator accepts a link object conforming to the DefaultLinkObject interface.\n */\nexport function linkHorizontal(): Link<any, DefaultLinkObject, [number, number]>;\n/**\n * Shorthand for d3.link with d3.curveBumpX; suitable for visualizing links in a tree diagram rooted on the left edge of the display.\n *\n * Important: Ensure that the accessor functions are configured to work with the link and node datum types\n * specified in the generics.\n *\n * The first generic corresponds to the datum type of the link object for which the link is to be generated.\n *\n * The second generic corresponds to the datum type of the source/target node contained in the link object.\n */\n// eslint-disable-next-line @definitelytyped/no-unnecessary-generics\nexport function linkHorizontal<LinkDatum, NodeDatum>(): Link<any, LinkDatum, NodeDatum>;\n/**\n * Shorthand for d3.link with d3.curveBumpX; suitable for visualizing links in a tree diagram rooted on the left edge of the display.\n *\n * Important: Ensure that the accessor functions are configured to work with the link and node datum types\n * specified in the generics.\n *\n * The first generic corresponds to the type of the \"this\" context within which the link generator and its accessor functions will be invoked.\n *\n * The second generic corresponds to the datum type of the link object for which the link is to be generated.\n *\n * The third generic corresponds to the datum type of the source/target node contained in the link object.\n */\n// eslint-disable-next-line @definitelytyped/no-unnecessary-generics\nexport function linkHorizontal<This, LinkDatum, NodeDatum>(): Link<This, LinkDatum, NodeDatum>;\n\n/**\n * Shorthand for d3.link with d3.curveBumpX; suitable for visualizing links in a tree diagram rooted on the left edge of the display.\n *\n * With the default settings the link generator accepts a link object conforming to the DefaultLinkObject interface.\n */\nexport function linkVertical(): Link<any, DefaultLinkObject, [number, number]>;\n/**\n * Shorthand for d3.link with d3.curveBumpY; suitable for visualizing links in a tree diagram rooted on the top edge of the display.\n *\n * Important: Ensure that the accessor functions are configured to work with the link and node datum types\n * specified in the generics.\n *\n * The first generic corresponds to the datum type of the link object for which the link is to be generated.\n *\n * The second generic corresponds to the datum type of the source/target node contained in the link object.\n */\n// eslint-disable-next-line @definitelytyped/no-unnecessary-generics\nexport function linkVertical<LinkDatum, NodeDatum>(): Link<any, LinkDatum, NodeDatum>;\n/**\n * Shorthand for d3.link with d3.curveBumpY; suitable for visualizing links in a tree diagram rooted on the top edge of the display.\n *\n * Important: Ensure that the accessor functions are configured to work with the link and node datum types\n * specified in the generics.\n *\n * The first generic corresponds to the type of the \"this\" context within which the link generator and its accessor functions will be invoked.\n *\n * The second generic corresponds to the datum type of the link object for which the link is to be generated.\n *\n * The third generic corresponds to the datum type of the source/target node contained in the link object.\n */\n// eslint-disable-next-line @definitelytyped/no-unnecessary-generics\nexport function linkVertical<This, LinkDatum, NodeDatum>(): Link<This, LinkDatum, NodeDatum>;\n\n/**\n * Shorthand for d3.link with d3.curveBumpY; suitable for visualizing links in a tree diagram rooted on the top edge of the display.\n *\n * The first generic corresponds to the type of the \"this\" context within which the radial link generator and its accessor functions will be invoked.\n *\n * The second generic corresponds to the datum type of the link object for which the link is to be generated.\n *\n * The third generic corresponds to the datum type of the source/target node contained in the link object.\n */\nexport interface LinkRadial<This, LinkDatum, NodeDatum> {\n    /**\n     * Generates a radial link for the given arguments.\n     *\n     * IMPORTANT: If the rendering context of the radial link generator is null,\n     * then the link is returned as a path data string.\n     *\n     * The \"this\" context within which this function is invoked, will be the context within which the accessor methods of the generator are invoked.\n     * All arguments passed into this function, will be passed to the accessor functions of the generator.\n     *\n     * @param d The datum for which the link is to be generated.\n     */\n    (this: This, d: LinkDatum, ...args: any[]): string | null;\n    /**\n     * Generates an link for the given arguments.\n     *\n     * IMPORTANT: If the radial link generator has been configured with a rendering context,\n     * then the link is rendered to this context as a sequence of path method calls and this function returns void.\n     *\n     * The \"this\" context within which this function is invoked, will be the context within which the accessor methods of the generator are invoked.\n     * All arguments passed into this function, will be passed to the accessor functions of the generator.\n     *\n     * @param d The datum for which the link is to be generated.\n     */\n    (this: This, d: LinkDatum, ...args: any[]): void;\n\n    /**\n     * Returns the current source node accessor function.\n     * The default source accessor function returns a two element array [x, y].\n     */\n    source(): (this: This, d: LinkDatum, ...args: any[]) => NodeDatum;\n    /**\n     * Sets the source accessor to the specified function and returns this radial link generator.\n     *\n     * @param source Source node accessor function. The accessor function is invoked in the same \"this\" context as the generator was invoked in and\n     * receives the same arguments that were passed into the radial link generator. The default target accessor function returns a two element array [x, y].\n     */\n    source(source: (this: This, d: LinkDatum, ...args: any[]) => NodeDatum): this;\n\n    /**\n     * Returns the current target node accessor function.\n     * The default target accessor function returns a two element array [x, y].\n     */\n    target(): (this: This, d: LinkDatum, ...args: any[]) => NodeDatum;\n    /**\n     * Sets the target accessor to the specified function and returns this radial link generator.\n     *\n     * @param target Target node accessor function. The accessor function is invoked in the same \"this\" context as the generator was invoked in and\n     * receives the same arguments that were passed into the radial link generator. The default target accessor function returns a two element array [x, y].\n     */\n    target(target: (this: This, d: LinkDatum, ...args: any[]) => NodeDatum): this;\n\n    /**\n     * Returns the current angle accessor, which defaults to a function accepting an number array\n     * as its argument an returning the first element of the array.\n     */\n    angle(): (this: This, node: NodeDatum, ...args: any[]) => number;\n    /**\n     * Sets the angle accessor to the specified function and returns this radial link generator.\n     * The angle is stated in radians, with 0 at -y (12 o’clock).\n     *\n     * @param angle Angle accessor function. The accessor function is invoked in the same \"this\" context as the generator was invoked in and\n     * receives as its first argument a node object followed by all additional arguments that were passed into the radial link generator.\n     */\n    angle(angle: (this: This, node: NodeDatum, ...args: any[]) => number): this;\n\n    /**\n     * Returns the current radius accessor, which defaults to a function accepting an number array\n     * as its argument an returning the second element of the array.\n     */\n    radius(): (this: This, node: NodeDatum, ...args: any[]) => number;\n    /**\n     * Sets the radius accessor to the specified function and returns this radial link generator.\n     * The radius is measured as the distance from the origin ⟨0,0⟩.\n     *\n     * @param radius Radius accessor function. The accessor function is invoked in the same \"this\" context as the generator was invoked in and\n     * receives as its first argument a node object followed by all additional arguments that were passed into the radial link generator.\n     */\n    radius(radius: (this: This, node: NodeDatum, ...args: any[]) => number): this;\n\n    /**\n     * Returns the current rendering context, which defaults to null.\n     */\n    context(): CanvasRenderingContext2D | null;\n    /**\n     * Sets the context and returns this link generator.\n     */\n    context(context: CanvasRenderingContext2D | null): this;\n}\n\n/**\n * @deprecated Use LinkRadial interface\n */\nexport type RadialLink<This, LinkDatum, NodeDatum> = LinkRadial<This, LinkDatum, NodeDatum>;\n\n/**\n * Constructs a new default link generator with radial tangents, for example, to visualize links in a tree diagram\n * rooted in the center of the display.\n *\n * With the default settings the link generator accepts a link object conforming to the DefaultLinkObject interface.\n */\nexport function linkRadial(): LinkRadial<any, DefaultLinkObject, [number, number]>;\n/**\n * Constructs a new link generator with radial tangents, for example, to visualize links in a tree diagram\n * rooted in the center of the display.\n *\n * Important: Ensure that the accessor functions are configured to work with the link and node datum types\n * specified in the generics.\n *\n * The first generic corresponds to the datum type of the link object for which the link is to be generated.\n *\n * The second generic corresponds to the datum type of the source/target node contained in the link object.\n */\n// eslint-disable-next-line @definitelytyped/no-unnecessary-generics\nexport function linkRadial<LinkDatum, NodeDatum>(): LinkRadial<any, LinkDatum, NodeDatum>;\n/**\n * Constructs a new link generator with radial tangents, for example, to visualize links in a tree diagram\n * rooted in the center of the display.\n *\n * Important: Ensure that the accessor functions are configured to work with the link and node datum types\n * specified in the generics.\n *\n * The first generic corresponds to the type of the \"this\" context within which the link generator and its accessor functions will be invoked.\n *\n * The second generic corresponds to the datum type of the link object for which the link is to be generated.\n *\n * The third generic corresponds to the datum type of the source/target node contained in the link object.\n */\n// eslint-disable-next-line @definitelytyped/no-unnecessary-generics\nexport function linkRadial<This, LinkDatum, NodeDatum>(): LinkRadial<This, LinkDatum, NodeDatum>;\n\n// -----------------------------------------------------------------------------------\n// SYMBOLS\n// -----------------------------------------------------------------------------------\n\n/**\n * A Symbol Type.\n *\n * Symbol types are typically not used directly, instead being passed to symbol.type.\n * However, you can define your own symbol type implementation should none of the built-in types satisfy your needs using the following interface.\n * You can also use this low-level interface with a built-in symbol type as an alternative to the symbol generator.\n */\nexport interface SymbolType {\n    /**\n     * Renders this symbol type to the specified context with the specified size in square pixels. The context implements the CanvasPath interface.\n     * (Note that this is a subset of the CanvasRenderingContext2D interface!)\n     *\n     * @param context A rendering context implementing CanvasPath.\n     * @param size Size of the symbol to draw.\n     */\n    draw(context: CanvasPath_D3Shape, size: number): void;\n}\n\n/**\n * A symbol generator.\n *\n * Symbols provide a categorical shape encoding as is commonly used in scatterplots. Symbols are always centered at ⟨0,0⟩;\n * use a transform (see: SVG, Canvas) to move the arc to a different position.\n *\n * The first generic corresponds to the \"this\" context within which the symbol generator is invoked.\n * The second generic corresponds to the data type of the datum underlying the symbol.\n */\nexport interface Symbol<This, Datum> {\n    /**\n     * Generates a symbol for the given arguments.\n     *\n     * IMPORTANT: If the rendering context of the symbol generator is null,\n     * then the symbol is returned as a path data string.\n     *\n     * The \"this\" context within which this function is invoked, will be the context within which the accessor methods of the generator are invoked.\n     * All arguments passed into this function, will be passed to the accessor functions of the generator.\n     *\n     * For example, with the default settings, no arguments are needed to produce a circle with area 64 square pixels.\n     *\n     * @param d The datum for which the symbol is to be generated.\n     */\n    (this: This, d?: Datum, ...args: any[]): string | null;\n    /**\n     * Generates an symbol for the given arguments.\n     *\n     * IMPORTANT: If the symbol generator has been configured with a rendering context,\n     * then the symbol is rendered to this context as a sequence of path method calls and this function returns void.\n     *\n     * The \"this\" context within which this function is invoked, will be the context within which the accessor methods of the generator are invoked.\n     * All arguments passed into this function, will be passed to the accessor functions of the generator.\n     *\n     * For example, with the default settings, no arguments are needed to produce a circle with area 64 square pixels.\n     *\n     * @param d The datum for which the symbol is to be generated.\n     */\n    (this: This, d?: Datum, ...args: any[]): void;\n    /**\n     * Returns the current size accessor, which defaults to a function returning a constant value of 64.\n     */\n    size(): (this: This, d: Datum, ...args: any[]) => number;\n    /**\n     * Sets the size to the specified number and returns this symbol generator.\n     *\n     * @param size A fixed size (area in square pixels).\n     */\n    size(size: number): this;\n    /**\n     * Sets the size to the specified function and returns this symbol generator.\n     *\n     * Specifying the size as a function is useful for constructing a scatterplot with a size encoding.\n     * If you wish to scale the symbol to fit a given bounding box, rather than by area, try SVG’s getBBox.\n     *\n     * @param size An accessor function returning a number to be used as a symbol size. The accessor function is invoked in the same \"this\" context as the generator was invoked in and\n     * receives the same arguments that were passed into the symbol generator.\n     */\n    size(size: (this: This, d: Datum, ...args: any[]) => number): this;\n\n    /**\n     * Returns the current symbol type accessor, which defaults to a function returning the circle symbol type.\n     */\n    type(): (this: This, d: Datum, ...args: any[]) => SymbolType;\n    /**\n     * Sets the symbol type to the specified symbol type and returns this symbol generator.\n     *\n     * @param type A constant symbol type.\n     */\n    type(type: SymbolType): this;\n    /**\n     * Sets the symbol type to the specified function and returns this symbol generator.\n     *\n     * @param type An accessor function returning a symbol type. The accessor function is invoked in the same \"this\" context as the generator was invoked in and\n     * receives the same arguments that were passed into the symbol generator. See symbols for the set of built-in symbol types.\n     * To implement a custom symbol type, return an object that implements symbolType.draw.\n     */\n    type(type: (this: This, d: Datum, ...args: any[]) => SymbolType): this;\n\n    /**\n     * Returns the current rendering context, which defaults to null.\n     */\n    context(): CanvasRenderingContext2D | null;\n    /**\n     * Sets the context and returns this symbol generator.\n     */\n    context(context: CanvasRenderingContext2D | null): this;\n}\n\n/**\n * Constructs a new symbol generator of the specified type and size.\n * If not specified, type defaults to a circle, and size defaults to 64.\n *\n * The first generic corresponds to the \"this\" context within which the symbol generator is invoked.\n * The second generic corresponds to the data type of the datum underlying the symbol.\n *\n * @param type The specified type.\n * @param size The specified size.\n */\nexport function symbol<Datum = any>(\n    type?: SymbolType | ((this: any, d: Datum, ...args: any[]) => SymbolType),\n    size?: number | ((this: any, d: Datum, ...args: any[]) => number),\n): Symbol<any, Datum>;\n\n/**\n * Constructs a new symbol generator of the specified type and size.\n * If not specified, type defaults to a circle, and size defaults to 64.\n *\n * The first generic corresponds to the \"this\" context within which the symbol generator is invoked.\n * The second generic corresponds to the data type of the datum underlying the symbol.\n *\n * @param type The specified type.\n * @param size The specified size.\n */\nexport function symbol<This, Datum>(\n    type?: SymbolType | ((this: This, d: Datum, ...args: any[]) => SymbolType),\n    size?: number | ((this: This, d: Datum, ...args: any[]) => number),\n): Symbol<This, Datum>;\n\n/**\n * An array containing a set of symbol types designed for filling: circle, cross, diamond, square, star, triangle, and wye.\n * Useful for constructing the range of an ordinal scale should you wish to use a shape encoding for categorical data.\n */\nexport const symbolsFill: SymbolType[];\n\n/**\n * An array containing a set of symbol types designed for stroking: circle, plus, x, triangle2, asterisk, square2, and diamond2.\n * Useful for constructing the range of an ordinal scale should you wish to use a shape encoding for categorical data.\n */\nexport const symbolsStroke: SymbolType[];\n\n/**\n * @deprecated Use symbolsFill\n */\nexport const symbols: SymbolType[];\n\n/**\n * The asterisk symbol type; intended for stroking.\n */\nexport const symbolAsterisk: SymbolType;\n\n/**\n * The circle symbol type; intended for either filling or stroking.\n */\nexport const symbolCircle: SymbolType;\n\n/**\n * The Greek cross symbol type, with arms of equal length; intended for filling.\n */\nexport const symbolCross: SymbolType;\n\n/**\n * The rhombus symbol type; intended for filling.\n */\nexport const symbolDiamond: SymbolType;\n\n/**\n * The rotated square symbol type; intended for stroking.\n */\nexport const symbolDiamond2: SymbolType;\n\n/**\n * The plus symbol type; intended for stroking.\n */\nexport const symbolPlus: SymbolType;\n\n/**\n * The square symbol type; intended for filling.\n */\nexport const symbolSquare: SymbolType;\n\n/**\n * The square2 symbol type; intended for stroking.\n */\nexport const symbolSquare2: SymbolType;\n\n/**\n * The pentagonal star (pentagram) symbol type; intended for filling.\n */\nexport const symbolStar: SymbolType;\n\n/**\n * The up-pointing triangle symbol type; intended for filling.\n */\nexport const symbolTriangle: SymbolType;\n\n/**\n * The up-pointing triangle symbol type; intended for stroking.\n */\nexport const symbolTriangle2: SymbolType;\n\n/**\n * The Y-shape symbol type; intended for filling.\n */\nexport const symbolWye: SymbolType;\n\n/**\n * The X-shape symbol type; intended for stroking.\n */\nexport const symbolX: SymbolType;\n\n/**\n * The X-shape symbol type; intended for stroking.\n */\nexport const symbolTimes: SymbolType;\n\n// -----------------------------------------------------------------------------------\n// pointRadial\n// -----------------------------------------------------------------------------------\n\n/**\n * Returns the point [x, y] for the given angle and the given radius.\n * @param angle Angle in radians, with 0 at -y (12 o’clock) and positive angles proceeding clockwise.\n * @param radius Radius.\n */\nexport function pointRadial(angle: number, radius: number): [number, number];\n\n// -----------------------------------------------------------------------------------\n// STACKS\n// -----------------------------------------------------------------------------------\n\n/**\n * Each series point j in a stack chart corresponds to the jth element in the input data.\n * Each point is represented as an array [y0, y1] where y0 is the lower value (baseline) and y1 is the upper value (topline);\n * the difference between y0 and y1 corresponds to the computed value for this point.\n *\n * SeriesPoint is a [number, number] two-element Array with added data and index properties\n * related to the data element which formed the basis for theSeriesPoint.\n */\nexport interface SeriesPoint<Datum> extends Array<number> {\n    /**\n     * Corresponds to y0, the lower value (baseline).\n     */\n    0: number;\n    /**\n     * Corresponds to y1, the upper value (topline).\n     */\n    1: number;\n    /**\n     * The data element underlying the series point.\n     */\n    data: Datum;\n}\n\n/**\n * The series are determined by the keys accessor; each series i in the returned array corresponds to the ith key.\n * Each series is an array of points, where each point j corresponds to the jth element in the input data.\n *\n * The key for each series is available as series.key, and the index as series.index.\n */\nexport interface Series<Datum, Key> extends Array<SeriesPoint<Datum>> {\n    /**\n     * Key of the series.\n     */\n    key: Key;\n    /**\n     * Index of the series in the series array returned by stack generator.\n     */\n    index: number;\n}\n\n/**\n * A stack generator.\n *\n * Some shape types can be stacked, placing one shape adjacent to another.\n * For example, a bar chart of monthly sales might be broken down into a multi-series bar chart by product category, stacking bars vertically.\n * This is equivalent to subdividing a bar chart by an ordinal dimension (such as product category) and applying a color encoding.\n *\n * Stacked charts can show overall value and per-category value simultaneously; however, it is typically harder to compare across categories, as only the bottom layer of the stack is aligned.\n * So, chose the stack order carefully, and consider a streamgraph. (See also grouped charts.)\n *\n * Like the pie generator, the stack generator does not produce a shape directly. Instead it computes positions which you can then pass to an area generator or use directly, say to position bars.\n *\n * The first generic corresponds to the \"this\" context in which the stack generator and its accessor functions are invoked.\n *\n * The second generic corresponds to the data type of an element in the data array passed into the stack generator.\n *\n * The third generic corresponds to the data type of key used to identify a series.\n */\nexport interface Stack<This, Datum, Key> {\n    /**\n     * Generates a stack for the given array of data, returning an array representing each series.\n     * The resulting array has one element per series. Each series in then typically passed to an area generator to render an area chart,\n     * or used to construct rectangles for a bar chart.\n     *\n     * Any additional arguments are arbitrary; they are simply propagated to the generator’s accessor functions along with the this object.\n     *\n     * @param data Array of data elements.\n     */\n    (data: Iterable<Datum>, ...args: any[]): Array<Series<Datum, Key>>;\n\n    /**\n     * Returns the current keys accessor, which defaults to the empty array.\n     */\n    keys(): (this: This, data: Datum[], ...args: any[]) => Key[];\n    /**\n     * Sets the keys accessor to the specified function or array and returns this stack generator.\n     * A series (layer) is generated for each key.\n     * Keys are typically strings, but they may be arbitrary values.\n     * The series’ key is passed to the value accessor, along with each data point, to compute the point’s value.\n     */\n    keys(keys: Iterable<Key> | ((this: This, data: Datum[], ...args: any[]) => Key[])): this;\n\n    /**\n     * Returns the current value accessor, which defaults to a function return the property corresponding to the relevant key from the data element.\n     *\n     * Thus, by default the stack generator assumes that the input data is an array of objects, with each object exposing named properties with numeric values; see stack for an example.\n     */\n    value(): (d: Datum, key: Key, i: number, data: Datum[]) => number;\n    /**\n     * Sets the value accessor to the specified number and returns this stack generator.\n     *\n     * @param value A constant value.\n     */\n    value(value: number): this;\n    /**\n     * Sets the value accessor to the specified function and returns this stack generator.\n     *\n     * @param value A value accessor function which returns the numeric value for a given data element and key combination. The accessor function is invoked for each data element and key being passed\n     * the datum, the key, index of the data element in the input data array, and the complete data array.\n     */\n    value(value: (d: Datum, key: Key, i: number, data: Datum[]) => number): this;\n\n    /**\n     * Returns the current order accessor, which defaults to stackOrderNone; this uses the order given by the key accessor.\n     */\n    order(): (series: Series<Datum, Key>) => Iterable<number>;\n    /**\n     * Sets the order accessor to the specified array and returns this stack generator.\n     */\n    order(order: null | Iterable<number>): this;\n    /**\n     * Sets the order accessor to the specified function and returns this stack generator.\n     *\n     * The stack order is computed prior to the offset; thus, the lower value for all points is zero at the time the order is computed.\n     * The index attribute for each series is also not set until after the order is computed.\n     *\n     * See stack orders for the built-in orders.\n     *\n     * @param order A function returning a sort order array. It is passed the generated series array and must return an array of numeric indexes representing the stack order.\n     */\n    order(order: (series: Series<Datum, Key>) => Iterable<number>): this;\n\n    /**\n     * Returns the current offset accessor, which defaults to stackOffsetNone; this uses a zero baseline.\n     */\n    offset(): (series: Series<Datum, Key>[], order: number[]) => void;\n    /**\n     * Reset the offset to use stackOffsetNone; this uses a zero baseline.\n     *\n     * @param offset null to set to the default stackOffsetNone.\n     */\n    offset(offset: null): this;\n    /**\n     * Sets the offset accessor to the specified function and returns this stack generator.\n     *\n     * @param offset A function which is passed the generated series array and the order index array;\n     *               it is then responsible for updating the lower and upper values in the series array.\n     */\n    offset(offset: (series: Series<Datum, Key>[], order: number[]) => void): this;\n}\n\n/**\n * Constructs a new stack generator with the default settings.\n *\n * Ensure that the accessors used with the stack generator correspond to the arguments passed into them.\n */\nexport function stack(): Stack<any, { [key: string]: number }, string>;\n/**\n * Constructs a new stack generator with the default settings.\n *\n * Ensure that the accessors used with the stack generator correspond to the arguments passed into them.\n *\n * The generic corresponds to the data type of an element in the data array passed into the stack generator.\n */\n// eslint-disable-next-line @definitelytyped/no-unnecessary-generics\nexport function stack<Datum>(): Stack<any, Datum, string>;\n/**\n * Constructs a new stack generator with the default settings.\n *\n * Ensure that the accessors used with the stack generator correspond to the arguments passed into them.\n *\n * The first generic corresponds to the data type of an element in the data array passed into the stack generator.\n *\n * The second generic corresponds to the data type of key used to identify a series.\n */\n// eslint-disable-next-line @definitelytyped/no-unnecessary-generics\nexport function stack<Datum, Key>(): Stack<any, Datum, Key>;\n/**\n * Constructs a new stack generator with the default settings.\n *\n * Ensure that the accessors used with the stack generator correspond to the arguments passed into them.\n *\n * The first generic corresponds to the \"this\" context in which the stack generator and its accessor functions are invoked.\n *\n * The second generic corresponds to the data type of an element in the data array passed into the stack generator.\n *\n * The third generic corresponds to the data type of key used to identify a series.\n */\n// eslint-disable-next-line @definitelytyped/no-unnecessary-generics\nexport function stack<This, Datum, Key>(): Stack<This, Datum, Key>;\n\n/**\n * Returns a series order such that the earliest series (according to the maximum value) is at the bottom.\n *\n * @param series A series generated by a stack generator.\n */\nexport function stackOrderAppearance(series: Series<any, any>): number[];\n\n/**\n * Returns a series order such that the smallest series (according to the sum of values) is at the bottom.\n *\n * @param series A series generated by a stack generator.\n */\nexport function stackOrderAscending(series: Series<any, any>): number[];\n\n/**\n * Returns a series order such that the largest series (according to the sum of values) is at the bottom.\n *\n * @param series A series generated by a stack generator.\n */\nexport function stackOrderDescending(series: Series<any, any>): number[];\n\n/**\n * Returns a series order such that the larger series (according to the sum of values) are on the inside and the smaller series are on the outside.\n * This order is recommended for streamgraphs in conjunction with the wiggle offset. See Stacked Graphs—Geometry & Aesthetics by Byron & Wattenberg for more information.\n *\n * @param series A series generated by a stack generator.\n */\nexport function stackOrderInsideOut(series: Series<any, any>): number[];\n\n/**\n * Returns the given series order [0, 1, … n - 1] where n is the number of elements in series. Thus, the stack order is given by the key accessor.\n *\n * @param series A series generated by a stack generator.\n */\nexport function stackOrderNone(series: Series<any, any>): number[];\n\n/**\n * Returns the reverse of the given series order [n - 1, n - 2, … 0] where n is the number of elements in series. Thus, the stack order is given by the reverse of the key accessor.\n *\n * @param series A series generated by a stack generator.\n */\nexport function stackOrderReverse(series: Series<any, any>): number[];\n\n/**\n * Applies a zero baseline and normalizes the values for each point such that the topline is always one.\n *\n * @param series A series array generated by a stack generator.\n * @param order An array of numeric indexes representing the stack order.\n */\nexport function stackOffsetExpand(series: Series<any, any>[], order: Iterable<number>): void;\n\n/**\n * Positive values are stacked above zero, while negative values are stacked below zero.\n *\n * @param series A series array generated by a stack generator.\n * @param order An array of numeric indexes representing the stack order.\n */\nexport function stackOffsetDiverging(series: Series<any, any>[], order: Iterable<number>): void;\n\n/**\n * Applies a zero baseline.\n *\n * @param series A series array generated by a stack generator.\n * @param order An array of numeric indexes representing the stack order.\n */\nexport function stackOffsetNone(series: Series<any, any>[], order: Iterable<number>): void;\n\n/**\n * Shifts the baseline down such that the center of the streamgraph is always at zero.\n *\n * @param series A series array generated by a stack generator.\n * @param order An array of numeric indexes representing the stack order.\n */\nexport function stackOffsetSilhouette(series: Series<any, any>[], order: Iterable<number>): void;\n\n/**\n * Shifts the baseline so as to minimize the weighted wiggle of layers. This offset is recommended for streamgraphs in conjunction with the inside-out order.\n * See Stacked Graphs—Geometry & Aesthetics by Bryon & Wattenberg for more information.\n *\n * @param series A series array generated by a stack generator.\n * @param order An array of numeric indexes representing the stack order.\n */\nexport function stackOffsetWiggle(series: Series<any, any>[], order: Iterable<number>): void;\n" },
  { path: "node_modules/d3-scale/package.json", content: "{\"name\":\"d3-scale\",\"types\":\"./index.d.ts\"}" },
  { path: "node_modules/d3-scale/index.d.ts", content: "// Last module patch version validated against: 4.0.2\n\nimport { CountableTimeInterval, TimeInterval } from \"d3-time\";\n\n// -------------------------------------------------------------------------------\n// Shared Types and Interfaces\n// -------------------------------------------------------------------------------\n\n/**\n * An Interpolator factory returns an interpolator function.\n *\n * The first generic corresponds to the data type of the interpolation boundaries.\n * The second generic corresponds to the data type of the return type of the interpolator.\n */\nexport interface InterpolatorFactory<T, U> {\n    /**\n     * Construct a new interpolator function, based on the provided interpolation boundaries.\n     *\n     * @param a Start boundary of the interpolation interval.\n     * @param b End boundary of the interpolation interval.\n     */\n    (a: T, b: T): (t: number) => U;\n}\n\nexport type NumberValue = number | { valueOf(): number };\n\nexport type UnknownReturnType<Unknown, DefaultUnknown> = [Unknown] extends [never] ? DefaultUnknown : Unknown;\n\n/**\n * A helper interface for a continuous scale defined over a numeric domain.\n */\nexport interface ScaleContinuousNumeric<Range, Output, Unknown = never> {\n    /**\n     * Given a value from the domain, returns the corresponding value from the range, subject to interpolation, if any.\n     *\n     * If the given value is outside the domain, and clamping is not enabled, the mapping may be extrapolated such that the returned value is outside the range.\n     *\n     * Note: The interpolation function applied by the scale may change the output type from the range type as part of the interpolation.\n     *\n     * @param value A numeric value from the domain.\n     */\n    (value: NumberValue): Output | Unknown;\n\n    /**\n     * Given a value from the range, returns the corresponding value from the domain. Inversion is useful for interaction,\n     * say to determine the data value corresponding to the position of the mouse.\n     *\n     * If the given value is outside the range, and clamping is not enabled, the mapping may be extrapolated such that the returned value is outside the domain.\n     *\n     * IMPORTANT: This method is only supported if the range is numeric. If the range is not numeric, returns NaN.\n     *\n     * For a valid value y in the range, continuous(continuous.invert(y)) approximately equals y;\n     * similarly, for a valid value x in the domain, continuous.invert(continuous(x)) approximately equals x.\n     * The scale and its inverse may not be exact due to the limitations of floating point precision.\n     *\n     * @param value A numeric value from the range.\n     */\n    invert(value: NumberValue): number;\n\n    /**\n     * Returns a copy of the scale’s current domain.\n     */\n    domain(): number[];\n    /**\n     * Sets the scale’s domain to the specified array of numbers. The array must contain two or more elements.\n     * If the elements in the given array are not numbers, they will be coerced to numbers\n     *\n     * Although continuous scales typically have two values each in their domain and range, specifying more than two values produces a piecewise scale.\n     *\n     * Internally, a piecewise scale performs a binary search for the range interpolator corresponding to the given domain value.\n     * Thus, the domain must be in ascending or descending order. If the domain and range have different lengths N and M, only the first min(N,M) elements in each are observed.\n     *\n     * @param domain Array of numeric domain values.\n     */\n    domain(domain: Iterable<NumberValue>): this;\n\n    /**\n     * Returns a copy of the scale’s current range.\n     */\n    range(): Range[];\n    /**\n     * Sets the scale’s range to the specified array of values.\n     *\n     * The array must contain two or more elements. Unlike the domain, elements in the given array need not be numbers;\n     * any value that is supported by the underlying interpolator will work, though note that numeric ranges are required for invert.\n     *\n     * @param range Array of range values.\n     */\n    range(range: Iterable<Range>): this;\n\n    /**\n     * Sets the scale’s range to the specified array of values while also setting the scale’s interpolator to interpolateRound.\n     *\n     * The rounding interpolator is sometimes useful for avoiding antialiasing artifacts,\n     * though also consider the shape-rendering “crispEdges” styles. Note that this interpolator can only be used with numeric ranges.\n     *\n     * The array must contain two or more elements. Unlike the domain, elements in the given array need not be numbers;\n     * any value that is supported by the underlying interpolator will work, though note that numeric ranges are required for invert.\n     *\n     * @param range Array of range values.\n     */\n    rangeRound(range: Iterable<NumberValue>): this;\n\n    /**\n     * Returns whether or not the scale currently clamps values to within the range.\n     */\n    clamp(): boolean;\n    /**\n     * Enables or disables clamping, respectively. If clamping is disabled and the scale is passed a value outside the domain,\n     * the scale may return a value outside the range through extrapolation.\n     *\n     * If clamping is enabled, the return value of the scale is always within the scale’s range. Clamping similarly applies to the \"invert\" method.\n     *\n     * @param clamp A flag to enable (true) or disable (false) clamping.\n     */\n    clamp(clamp: boolean): this;\n\n    /**\n     * Returns approximately count representative values from the scale’s domain.\n     *\n     * If count is not specified, it defaults to 10.\n     *\n     * The returned tick values are uniformly spaced, have human-readable values (such as multiples of powers of 10),\n     * and are guaranteed to be within the extent of the domain. Ticks are often used to display reference lines, or tick marks, in conjunction with the visualized data.\n     * The specified count is only a hint; the scale may return more or fewer values depending on the domain. See also d3-array’s ticks.\n     *\n     * @param count Optional approximate number of ticks to be returned. If count is not specified, it defaults to 10.\n     */\n    ticks(count?: number): number[];\n\n    /**\n     * Returns a number format function suitable for displaying a tick value, automatically computing the appropriate precision based on the fixed interval between tick values.\n     * The specified count should have the same value as the count that is used to generate the tick values.\n     *\n     * @param count Approximate number of ticks to be used when calculating precision for the number format function.\n     * @param specifier An optional valid format specifier string which allows a custom format where the precision of the format is automatically set by the scale as appropriate for the tick interval.\n     * If specifier uses the format type \"s\", the scale will return a SI-prefix format based on the largest value in the domain.\n     * If the specifier already specifies a precision, this method is equivalent to locale.format.\n     */\n    tickFormat(count?: number, specifier?: string): (d: NumberValue) => string;\n\n    /**\n     * Extends the domain so that it starts and ends on nice round values.\n     * This method typically modifies the scale’s domain, and may only extend the bounds to the nearest round value.\n     * An optional tick count argument allows greater control over the step size used to extend the bounds,\n     * guaranteeing that the returned ticks will exactly cover the domain.\n     * Nicing is useful if the domain is computed from data, say using extent, and may be irregular.\n     * For example, for a domain of [0.201479…, 0.996679…], a nice domain might be [0.2, 1.0].\n     * If the domain has more than two values, nicing the domain only affects the first and last value.\n     *\n     * Nicing a scale only modifies the current domain; it does not automatically nice domains that are subsequently set using continuous.domain.\n     * You must re-nice the scale after setting the new domain, if desired.\n     *\n     * @param count An optional number of ticks expected to be used.\n     */\n    nice(count?: number): this;\n\n    /**\n     * Returns an exact copy of this scale. Changes to this scale will not affect the returned scale, and vice versa.\n     */\n    copy(): this;\n}\n\n/**\n * Returns a number format function suitable for displaying a tick value,\n * automatically computing the appropriate precision based on the fixed interval between tick values, as determined by d3.tickStep.\n *\n * @param start Start\n * @param stop Stop\n * @param count Approximate number of ticks to be used when calculating precision for the number format function.\n * @param specifier An optional specifier allows a custom format where the precision of the format is automatically set by the scale as appropriate for the tick interval.\n * If specifier uses the format type s, the scale will return a SI-prefix format based on the larger absolute value of start and stop.\n * If the specifier already specifies a precision, this method is equivalent to locale.format.\n */\nexport function tickFormat(start: number, stop: number, count: number, specifier?: string): (d: NumberValue) => string;\n\n// -------------------------------------------------------------------------------\n// Linear Scale Factory\n// -------------------------------------------------------------------------------\n\n/**\n * A linear continuous scale defined over a numeric domain.\n *\n * Continuous scales map a continuous, quantitative input domain to a continuous output range.\n * Each range value y can be expressed as a function of the domain value x: y = mx + b.\n *\n * If the range is also numeric, the mapping may be inverted.\n *\n * Note that the data types of the range and output of the scale must be compatible with the interpolator applied by the scale.\n *\n * The first generic corresponds to the data type of the range elements.\n *\n * The second generic corresponds to the data type of the output elements generated by the scale.\n *\n * The third generic corresponds to the data type of the unknown value.\n *\n * If range element and output element type differ, the interpolator factory used with the scale must match this behavior and\n * convert the interpolated range element to a corresponding output element.\n */\nexport interface ScaleLinear<Range, Output, Unknown = never> extends ScaleContinuousNumeric<Range, Output, Unknown> {\n    /**\n     * Returns the scale’s current interpolator factory, which defaults to interpolate.\n     */\n    interpolate(): InterpolatorFactory<any, any>;\n\n    /**\n     * Sets the scale’s range interpolator factory. This interpolator factory is used to create interpolators for each adjacent pair of values from the range;\n     * these interpolators then map a normalized domain parameter t in [0, 1] to the corresponding value in the range.\n     *\n     * Note: the default interpolator may reuse return values. For example, if the range values are objects, then the value interpolator always returns the same object, modifying it in-place.\n     * If the scale is used to set an attribute or style, this is typically acceptable (and desirable for performance);\n     * however, if you need to store the scale’s return value, you must specify your own interpolator or make a copy as appropriate.\n     *\n     * As part of the interpolation process the interpolated value from the range may be converted to a corresponding output value.\n     *\n     * @param interpolate An interpolation factory. The generics for Range and Output of the scale must correspond to the interpolation factory applied to the scale.\n     */\n    interpolate(interpolate: InterpolatorFactory<Range, Output>): this;\n    /**\n     * Sets the scale’s range interpolator factory. This interpolator factory is used to create interpolators for each adjacent pair of values from the range;\n     * these interpolators then map a normalized domain parameter t in [0, 1] to the corresponding value in the range.\n     *\n     * Note: the default interpolator may reuse return values. For example, if the range values are objects, then the value interpolator always returns the same object, modifying it in-place.\n     * If the scale is used to set an attribute or style, this is typically acceptable (and desirable for performance);\n     * however, if you need to store the scale’s return value, you must specify your own interpolator or make a copy as appropriate.\n     *\n     * As part of the interpolation process the interpolated value from the range may be converted to a corresponding output value.\n     *\n     * The generic \"NewOutput\" can be used to change the scale to have a different output element type corresponding to the new interpolation factory.\n     *\n     * @param interpolate An interpolation factory. The generics for Range and Output of the scale must correspond to the interpolation factory applied to the scale.\n     */\n    interpolate<NewOutput>(interpolate: InterpolatorFactory<Range, NewOutput>): ScaleLinear<Range, NewOutput, Unknown>;\n\n    /**\n     * Returns the current unknown value, which defaults to undefined.\n     */\n    unknown(): UnknownReturnType<Unknown, undefined>;\n    /**\n     * Sets the output value of the scale for undefined (or NaN) input values and returns this scale.\n     *\n     * @param value The output value of the scale for undefined (or NaN) input values.\n     */\n    unknown<NewUnknown>(value: NewUnknown): ScaleLinear<Range, Output, NewUnknown>;\n}\n\n/**\n * Constructs a new continuous scale with the specified range, the default interpolator and clamping disabled.\n * The domain defaults to [0, 1].\n * If range is not specified, it defaults to [0, 1].\n *\n * The first generic corresponds to the data type of the range elements.\n * The second generic corresponds to the data type of the output elements generated by the scale.\n * The third generic corresponds to the data type of the unknown value.\n *\n * If range element and output element type differ, the interpolator factory used with the scale must match this behavior and\n * convert the interpolated range element to a corresponding output element.\n *\n * The range must be set in accordance with the range element type.\n *\n * The interpolator factory may be set using the interpolate(...) method of the scale.\n *\n * @param range Array of range values.\n */\n// eslint-disable-next-line @definitelytyped/no-unnecessary-generics\nexport function scaleLinear<Range = number, Output = Range, Unknown = never>(\n    range?: Iterable<Range>,\n): ScaleLinear<Range, Output, Unknown>;\n/**\n * Constructs a new continuous scale with the specified domain and range, the default interpolator and clamping disabled.\n *\n * The first generic corresponds to the data type of the range elements.\n * The second generic corresponds to the data type of the output elements generated by the scale.\n * The third generic corresponds to the data type of the unknown value.\n *\n * If range element and output element type differ, the interpolator factory used with the scale must match this behavior and\n * convert the interpolated range element to a corresponding output element.\n *\n * The range must be set in accordance with the range element type.\n *\n * The interpolator factory may be set using the interpolate(...) method of the scale.\n *\n * @param domain Array of numeric domain values.\n * @param range Array of range values.\n */\n// eslint-disable-next-line @definitelytyped/no-unnecessary-generics\nexport function scaleLinear<Range, Output = Range, Unknown = never>(\n    domain: Iterable<NumberValue>,\n    range: Iterable<Range>,\n): ScaleLinear<Range, Output, Unknown>;\n\n// -------------------------------------------------------------------------------\n// Power Scale Factories\n// -------------------------------------------------------------------------------\n\n/**\n * A continuous power scale defined over a numeric domain.\n *\n * Continuous scales map a continuous, quantitative input domain to a continuous output range.\n *\n * Each range value y can be expressed as a function of the domain value x: y = mx^k + b, where k is the exponent value.\n * Power scales also support negative domain values, in which case the input value and the resulting output value are multiplied by -1.\n *\n * If the range is also numeric, the mapping may be inverted.\n *\n * Note that the data types of the range and output of the scale must be compatible with the interpolator applied by the scale.\n *\n * The first generic corresponds to the data type of the range elements.\n *\n * The second generic corresponds to the data type of the output elements generated by the scale.\n *\n * The third generic corresponds to the data type of the unknown value.\n *\n * If range element and output element type differ, the interpolator factory used with the scale must match this behavior and\n * convert the interpolated range element to a corresponding output element.\n */\nexport interface ScalePower<Range, Output, Unknown = never> extends ScaleContinuousNumeric<Range, Output, Unknown> {\n    /**\n     * Returns the scale’s current interpolator factory, which defaults to interpolate.\n     */\n    interpolate(): InterpolatorFactory<any, any>;\n\n    /**\n     * Sets the scale’s range interpolator factory. This interpolator factory is used to create interpolators for each adjacent pair of values from the range;\n     * these interpolators then map a normalized domain parameter t in [0, 1] to the corresponding value in the range.\n     *\n     * Note: the default interpolator may reuse return values. For example, if the range values are objects, then the value interpolator always returns the same object, modifying it in-place.\n     * If the scale is used to set an attribute or style, this is typically acceptable (and desirable for performance);\n     * however, if you need to store the scale’s return value, you must specify your own interpolator or make a copy as appropriate.\n     *\n     * As part of the interpolation process the interpolated value from the range may be converted to a corresponding output value.\n     *\n     * @param interpolate An interpolation factory. The generics for Range and Output of the scale must correspond to the interpolation factory applied to the scale.\n     */\n    interpolate(interpolate: InterpolatorFactory<Range, Output>): this;\n    /**\n     * Sets the scale’s range interpolator factory. This interpolator factory is used to create interpolators for each adjacent pair of values from the range;\n     * these interpolators then map a normalized domain parameter t in [0, 1] to the corresponding value in the range.\n     *\n     * Note: the default interpolator may reuse return values. For example, if the range values are objects, then the value interpolator always returns the same object, modifying it in-place.\n     * If the scale is used to set an attribute or style, this is typically acceptable (and desirable for performance);\n     * however, if you need to store the scale’s return value, you must specify your own interpolator or make a copy as appropriate.\n     *\n     * As part of the interpolation process the interpolated value from the range may be converted to a corresponding output value.\n     *\n     * The generic \"NewOutput\" can be used to change the scale to have a different output element type corresponding to the new interpolation factory.\n     *\n     * @param interpolate An interpolation factory. The generics for Range and Output of the scale must correspond to the interpolation factory applied to the scale.\n     */\n    interpolate<NewOutput>(interpolate: InterpolatorFactory<Range, NewOutput>): ScalePower<Range, NewOutput, Unknown>;\n\n    /**\n     * If exponent is not specified, returns the current exponent, which defaults to 1.\n     * (Note that this is effectively a linear scale until you set a different exponent.)\n     */\n    exponent(): number;\n    /**\n     * Sets the current exponent to the given numeric value.\n     * (Note that this is effectively a linear scale until you set a different exponent.)\n     */\n    exponent(exponent: number): this;\n\n    /**\n     * Returns the current unknown value, which defaults to undefined.\n     */\n    unknown(): UnknownReturnType<Unknown, undefined>;\n    /**\n     * Sets the output value of the scale for undefined (or NaN) input values and returns this scale.\n     *\n     * @param value The output value of the scale for undefined (or NaN) input values.\n     */\n    unknown<NewUnknown>(value: NewUnknown): ScalePower<Range, Output, NewUnknown>;\n}\n\n/**\n * Constructs a new continuous scale with the specified range, the exponent 1, the default interpolator and clamping disabled.\n * The domain defaults to [0, 1].\n * If range is not specified, it defaults to [0, 1].\n * (Note that this is effectively a linear scale until you set a different exponent.)\n *\n * The first generic corresponds to the data type of the range elements.\n * The second generic corresponds to the data type of the output elements generated by the scale.\n * The third generic corresponds to the data type of the unknown value.\n *\n * If range element and output element type differ, the interpolator factory used with the scale must match this behavior and\n * convert the interpolated range element to a corresponding output element.\n *\n * The range must be set in accordance with the range element type.\n *\n * The interpolator factory may be set using the interpolate(...) method of the scale.\n *\n * @param range Array of range values.\n */\n// eslint-disable-next-line @definitelytyped/no-unnecessary-generics\nexport function scalePow<Range = number, Output = Range, Unknown = never>(\n    range?: Iterable<Range>,\n): ScalePower<Range, Output, Unknown>;\n/**\n * Constructs a new continuous scale with the specified domain and range, the exponent 1, the default interpolator and clamping disabled.\n * (Note that this is effectively a linear scale until you set a different exponent.)\n *\n * The first generic corresponds to the data type of the range elements.\n * The second generic corresponds to the data type of the output elements generated by the scale.\n * The third generic corresponds to the data type of the unknown value.\n *\n * If range element and output element type differ, the interpolator factory used with the scale must match this behavior and\n * convert the interpolated range element to a corresponding output element.\n *\n * The range must be set in accordance with the range element type.\n *\n * The interpolator factory may be set using the interpolate(...) method of the scale.\n *\n * @param domain Array of numeric domain values.\n * @param range Array of range values.\n */\n// eslint-disable-next-line @definitelytyped/no-unnecessary-generics\nexport function scalePow<Range, Output = Range, Unknown = never>(\n    domain: Iterable<NumberValue>,\n    range: Iterable<Range>,\n): ScalePower<Range, Output, Unknown>;\n\n/**\n * Constructs a new continuous power scale with the specified range, the exponent 0.5, the default interpolator and clamping disabled.\n * The domain defaults to [0, 1].\n * If range is not specified, it defaults to [0, 1].\n * This is a convenience method equivalent to d3.scalePow().exponent(0.5).\n *\n * The first generic corresponds to the data type of the range elements.\n * The second generic corresponds to the data type of the output elements generated by the scale.\n * The third generic corresponds to the data type of the unknown value.\n *\n * If range element and output element type differ, the interpolator factory used with the scale must match this behavior and\n * convert the interpolated range element to a corresponding output element.\n *\n * The range must be set in accordance with the range element type.\n *\n * The interpolator factory may be set using the interpolate(...) method of the scale.\n *\n * @param range Array of range values.\n */\n// eslint-disable-next-line @definitelytyped/no-unnecessary-generics\nexport function scaleSqrt<Range = number, Output = Range, Unknown = never>(\n    range?: Iterable<Range>,\n): ScalePower<Range, Output, Unknown>;\n/**\n * Constructs a new continuous power scale with the specified domain and range, the exponent 0.5, the default interpolator and clamping disabled.\n * This is a convenience method equivalent to d3.scalePow().exponent(0.5).\n *\n * The first generic corresponds to the data type of the range elements.\n * The second generic corresponds to the data type of the output elements generated by the scale.\n * The third generic corresponds to the data type of the unknown value.\n *\n * If range element and output element type differ, the interpolator factory used with the scale must match this behavior and\n * convert the interpolated range element to a corresponding output element.\n *\n * The range must be set in accordance with the range element type.\n *\n * The interpolator factory may be set using the interpolate(...) method of the scale.\n *\n * @param domain Array of numeric domain values.\n * @param range Array of range values.\n */\n// eslint-disable-next-line @definitelytyped/no-unnecessary-generics\nexport function scaleSqrt<Range, Output = Range, Unknown = never>(\n    domain: Iterable<NumberValue>,\n    range: Iterable<Range>,\n): ScalePower<Range, Output, Unknown>;\n\n// -------------------------------------------------------------------------------\n// Logarithmic Scale Factory\n// -------------------------------------------------------------------------------\n\n/**\n * A continuous logarithmic scale defined over a numeric domain.\n *\n * Continuous scales map a continuous, quantitative input domain to a continuous output range.\n *\n * The mapping to the range value y can be expressed as a function of the domain value x: y = m log(x) + b.\n *\n * As log(0) = -∞, a log scale domain must be strictly-positive or strictly-negative; the domain must not include or cross zero.\n * A log scale with a positive domain has a well-defined behavior for positive values, and a log scale with a negative domain has a well-defined behavior for negative values.\n * (For a negative domain, input and output values are implicitly multiplied by -1.)\n * The behavior of the scale is undefined if you pass a negative value to a log scale with a positive domain or vice versa.\n *\n * If the range is also numeric, the mapping may be inverted.\n *\n * Note that the data types of the range and output of the scale must be compatible with the interpolator applied by the scale.\n *\n * The first generic corresponds to the data type of the range elements.\n *\n * The second generic corresponds to the data type of the output elements generated by the scale.\n *\n * The third generic corresponds to the data type of the unknown value.\n *\n * If range element and output element type differ, the interpolator factory used with the scale must match this behavior and\n * convert the interpolated range element to a corresponding output element.\n */\nexport interface ScaleLogarithmic<Range, Output, Unknown = never>\n    extends ScaleContinuousNumeric<Range, Output, Unknown>\n{\n    /**\n     * Returns a copy of the scale’s current domain.\n     */\n    domain(): number[];\n    /**\n     * Sets the scale’s domain to the specified array of numbers. The array must contain two or more elements.\n     * If the elements in the given array are not numbers, they will be coerced to numbers\n     *\n     * As log(0) = -∞, a log scale domain must be strictly-positive or strictly-negative; the domain must not include or cross zero.\n     * A log scale with a positive domain has a well-defined behavior for positive values, and a log scale with a negative domain has a well-defined behavior for negative values.\n     * (For a negative domain, input and output values are implicitly multiplied by -1.)\n     * The behavior of the scale is undefined if you pass a negative value to a log scale with a positive domain or vice versa.\n     *\n     * Although continuous scales typically have two values each in their domain and range, specifying more than two values produces a piecewise scale.\n     *\n     * Internally, a piecewise scale performs a binary search for the range interpolator corresponding to the given domain value.\n     * Thus, the domain must be in ascending or descending order. If the domain and range have different lengths N and M, only the first min(N,M) elements in each are observed.\n     *\n     * @param domain Array of numeric domain values.\n     */\n    domain(domain: Iterable<NumberValue>): this;\n\n    /**\n     * Returns the scale’s current interpolator factory, which defaults to interpolate.\n     */\n    interpolate(): InterpolatorFactory<any, any>;\n\n    /**\n     * Sets the scale’s range interpolator factory. This interpolator factory is used to create interpolators for each adjacent pair of values from the range;\n     * these interpolators then map a normalized domain parameter t in [0, 1] to the corresponding value in the range.\n     *\n     * Note: the default interpolator may reuse return values. For example, if the range values are objects, then the value interpolator always returns the same object, modifying it in-place.\n     * If the scale is used to set an attribute or style, this is typically acceptable (and desirable for performance);\n     * however, if you need to store the scale’s return value, you must specify your own interpolator or make a copy as appropriate.\n     *\n     * As part of the interpolation process the interpolated value from the range may be converted to a corresponding output value.\n     *\n     * @param interpolate An interpolation factory. The generics for Range and Output of the scale must correspond to the interpolation factory applied to the scale.\n     */\n    interpolate(interpolate: InterpolatorFactory<Range, Output>): this;\n    /**\n     * Sets the scale’s range interpolator factory. This interpolator factory is used to create interpolators for each adjacent pair of values from the range;\n     * these interpolators then map a normalized domain parameter t in [0, 1] to the corresponding value in the range.\n     *\n     * Note: the default interpolator may reuse return values. For example, if the range values are objects, then the value interpolator always returns the same object, modifying it in-place.\n     * If the scale is used to set an attribute or style, this is typically acceptable (and desirable for performance);\n     * however, if you need to store the scale’s return value, you must specify your own interpolator or make a copy as appropriate.\n     *\n     * As part of the interpolation process the interpolated value from the range may be converted to a corresponding output value.\n     *\n     * The generic \"NewOutput\" can be used to change the scale to have a different output element type corresponding to the new interpolation factory.\n     *\n     * @param interpolate An interpolation factory. The generics for Range and Output of the scale must correspond to the interpolation factory applied to the scale.\n     */\n    interpolate<NewOutput>(\n        interpolate: InterpolatorFactory<Range, NewOutput>,\n    ): ScaleLogarithmic<Range, NewOutput, Unknown>;\n\n    /**\n     * Returns approximately count representative values from the scale’s domain.\n     *\n     * If count is not specified, it defaults to 10.\n     *\n     * If the base is an integer, the returned ticks are uniformly spaced within each integer power of base; otherwise, one tick per power of base is returned.\n     * The returned ticks are guaranteed to be within the extent of the domain. If the orders of magnitude in the domain is greater than count, then at most one tick per power is returned.\n     * Otherwise, the tick values are unfiltered, but note that you can use log.tickFormat to filter the display of tick labels.\n     *\n     * @param count Optional approximate number of ticks to be returned. If count is not specified, it defaults to 10.\n     */\n    ticks(count?: number): number[];\n\n    /**\n     * Returns a number format function suitable for displaying a tick value, automatically computing the appropriate precision based on the fixed interval between tick values.\n     *\n     * The specified count typically has the same value as the count that is used to generate the tick values.\n     * If there are too many ticks, the formatter may return the empty string for some of the tick labels;\n     * however, note that the ticks are still shown.\n     * To disable filtering, specify a count of Infinity. When specifying a count, you may also provide a format specifier or format function.\n     * For example, to get a tick formatter that will display 20 ticks of a currency, say log.tickFormat(20, \"$,f\").\n     * If the specifier does not have a defined precision, the precision will be set automatically by the scale, returning the appropriate format.\n     * This provides a convenient way of specifying a format whose precision will be automatically set by the scale.\n     *\n     * @param count Approximate number of ticks to be used when calculating precision for the number format function.\n     * @param specifier An optional valid format specifier string which allows a custom format where the precision of the format is automatically set by the scale as appropriate for the tick interval.\n     * For example, to get a tick formatter that will display 20 ticks of a currency, say log.tickFormat(20, \"$,f\").\n     * If the specifier does not have a defined precision, the precision will be set automatically by the scale, returning the appropriate format.\n     * This provides a convenient way of specifying a format whose precision will be automatically set by the scale.\n     */\n    tickFormat(count?: number, specifier?: string): (d: NumberValue) => string;\n\n    /**\n     * Extends the domain to integer powers of base. For example, for a domain of [0.201479…, 0.996679…], and base 10, the nice domain is [0.1, 1].\n     * If the domain has more than two values, nicing the domain only affects the first and last value.\n     *\n     * Nicing a scale only modifies the current domain; it does not automatically nice domains that are subsequently set using continuous.domain.\n     * You must re-nice the scale after setting the new domain, if desired.\n     */\n    nice(): this;\n\n    /**\n     * Returns the current base, which defaults to 10.\n     */\n    base(): number;\n    /**\n     * Sets the base for this logarithmic scale to the specified value.\n     */\n    base(base: number): this;\n\n    /**\n     * Returns the current unknown value, which defaults to undefined.\n     */\n    unknown(): UnknownReturnType<Unknown, undefined>;\n    /**\n     * Sets the output value of the scale for undefined (or NaN) input values and returns this scale.\n     *\n     * @param value The output value of the scale for undefined (or NaN) input values.\n     */\n    unknown<NewUnknown>(value: NewUnknown): ScaleLogarithmic<Range, Output, NewUnknown>;\n}\n\n/**\n * Constructs a new continuous scale with the specified range, the base 10, the default interpolator and clamping disabled.\n * The domain defaults to [1, 10].\n * If range is not specified, it defaults to [0, 1].\n *\n * The first generic corresponds to the data type of the range elements.\n * The second generic corresponds to the data type of the output elements generated by the scale.\n * The third generic corresponds to the data type of the unknown value.\n *\n * If range element and output element type differ, the interpolator factory used with the scale must match this behavior and\n * convert the interpolated range element to a corresponding output element.\n *\n * The range must be set in accordance with the range element type.\n *\n * The interpolator factory may be set using the interpolate(...) method of the scale.\n *\n * @param range Array of range values.\n */\n// eslint-disable-next-line @definitelytyped/no-unnecessary-generics\nexport function scaleLog<Range = number, Output = Range, Unknown = never>(\n    range?: Iterable<Range>,\n): ScaleLogarithmic<Range, Output, Unknown>;\n/**\n * Constructs a new continuous scale with the specified domain and range, the base 10, the default interpolator and clamping disabled.\n *\n * The first generic corresponds to the data type of the range elements.\n * The second generic corresponds to the data type of the output elements generated by the scale.\n * The third generic corresponds to the data type of the unknown value.\n *\n * If range element and output element type differ, the interpolator factory used with the scale must match this behavior and\n * convert the interpolated range element to a corresponding output element.\n *\n * The range must be set in accordance with the range element type.\n *\n * The interpolator factory may be set using the interpolate(...) method of the scale.\n *\n * @param domain Array of numeric domain values.\n * @param range Array of range values.\n */\n// eslint-disable-next-line @definitelytyped/no-unnecessary-generics\nexport function scaleLog<Range, Output = Range, Unknown = never>(\n    domain: Iterable<NumberValue>,\n    range: Iterable<Range>,\n): ScaleLogarithmic<Range, Output, Unknown>;\n\n// -------------------------------------------------------------------------------\n// Symlog Scale Factory\n// -------------------------------------------------------------------------------\n\n/**\n * A bi-symmetric log transformation for wide-range data by Webber scale defined over a numeric domain.\n *\n * Continuous scales map a continuous, quantitative input domain to a continuous output range.\n *\n * See “A bi-symmetric log transformation for wide-range data” by Webber for more\n *\n * If the range is also numeric, the mapping may be inverted.\n *\n * Note that the data types of the range and output of the scale must be compatible with the interpolator applied by the scale.\n *\n * The first generic corresponds to the data type of the range elements.\n *\n * The second generic corresponds to the data type of the output elements generated by the scale.\n *\n * The third generic corresponds to the data type of the unknown value.\n *\n * If range element and output element type differ, the interpolator factory used with the scale must match this behavior and\n * convert the interpolated range element to a corresponding output element.\n */\nexport interface ScaleSymLog<Range, Output, Unknown = never> extends ScaleContinuousNumeric<Range, Output, Unknown> {\n    /**\n     * Returns a number format function suitable for displaying a tick value, automatically computing the appropriate precision based on the fixed interval between tick values.\n     *\n     * The specified count typically has the same value as the count that is used to generate the tick values.\n     * If there are too many ticks, the formatter may return the empty string for some of the tick labels;\n     * however, note that the ticks are still shown.\n     * To disable filtering, specify a count of Infinity. When specifying a count, you may also provide a format specifier or format function.\n     * For example, to get a tick formatter that will display 20 ticks of a currency, say log.tickFormat(20, \"$,f\").\n     * If the specifier does not have a defined precision, the precision will be set automatically by the scale, returning the appropriate format.\n     * This provides a convenient way of specifying a format whose precision will be automatically set by the scale.\n     *\n     * @param count Approximate number of ticks to be used when calculating precision for the number format function.\n     * @param specifier An optional valid format specifier string which allows a custom format where the precision of the format is automatically set by the scale as appropriate for the tick interval.\n     * For example, to get a tick formatter that will display 20 ticks of a currency, say log.tickFormat(20, \"$,f\").\n     * If the specifier does not have a defined precision, the precision will be set automatically by the scale, returning the appropriate format.\n     * This provides a convenient way of specifying a format whose precision will be automatically set by the scale.\n     */\n    tickFormat(count?: number, specifier?: string): (d: NumberValue) => string;\n    /**\n     * Returns the current constant, which defaults to 1.\n     */\n    constant(): number;\n    /**\n     * Sets the symlog constant to the specified number and returns this scale;\n     * otherwise returns the current value of the symlog constant, which defaults to 1. See “A bi-symmetric log transformation for wide-range data” by Webber for more.\n     */\n    constant(constant: number): this;\n\n    /**\n     * Returns the current unknown value, which defaults to undefined.\n     */\n    unknown(): UnknownReturnType<Unknown, undefined>;\n    /**\n     * Sets the output value of the scale for undefined (or NaN) input values and returns this scale.\n     *\n     * @param value The output value of the scale for undefined (or NaN) input values.\n     */\n    unknown<NewUnknown>(value: NewUnknown): ScaleSymLog<Range, Output, NewUnknown>;\n}\n\n/**\n * Constructs a new continuous scale with the specified range, the constant 1, the default interpolator and clamping disabled.\n * The domain defaults to [0, 1].\n * If range is not specified, it defaults to [0, 1].\n *\n * The first generic corresponds to the data type of the range elements.\n * The second generic corresponds to the data type of the output elements generated by the scale.\n * The third generic corresponds to the data type of the unknown value.\n *\n * If range element and output element type differ, the interpolator factory used with the scale must match this behavior and\n * convert the interpolated range element to a corresponding output element.\n *\n * The range must be set in accordance with the range element type.\n *\n * The interpolator factory may be set using the interpolate(...) method of the scale.\n *\n * @param range Array of range values.\n */\n// eslint-disable-next-line @definitelytyped/no-unnecessary-generics\nexport function scaleSymlog<Range = number, Output = Range, Unknown = never>(\n    range?: Iterable<Range>,\n): ScaleSymLog<Range, Output, Unknown>;\n/**\n * Constructs a new continuous scale with the specified domain and range, the constant 1, the default interpolator and clamping disabled.\n *\n * The first generic corresponds to the data type of the range elements.\n * The second generic corresponds to the data type of the output elements generated by the scale.\n * The third generic corresponds to the data type of the unknown value.\n *\n * If range element and output element type differ, the interpolator factory used with the scale must match this behavior and\n * convert the interpolated range element to a corresponding output element.\n *\n * The range must be set in accordance with the range element type.\n *\n * The interpolator factory may be set using the interpolate(...) method of the scale.\n *\n * @param domain Array of numeric domain values.\n * @param range Array of range values.\n */\n// eslint-disable-next-line @definitelytyped/no-unnecessary-generics\nexport function scaleSymlog<Range, Output = Range, Unknown = never>(\n    domain: Iterable<NumberValue>,\n    range: Iterable<Range>,\n): ScaleSymLog<Range, Output, Unknown>;\n\n// -------------------------------------------------------------------------------\n// Identity Scale Factory\n// -------------------------------------------------------------------------------\n\n/**\n * Identity scales are a special case of linear scales where the domain and range are identical; the scale and its invert method are thus the identity function.\n * These scales are occasionally useful when working with pixel coordinates, say in conjunction with an axis.\n *\n * The generic corresponds to the data type of the unknown value.\n */\nexport interface ScaleIdentity<Unknown = never> {\n    /**\n     * Given a value from the domain, returns the corresponding value from the range, subject to interpolation, if any.\n     *\n     * If the given value is outside the domain, and clamping is not enabled, the mapping may be extrapolated such that the returned value is outside the range.\n     *\n     * Note: The interpolation function applied by the scale may change the output type from the range type as part of the interpolation.\n     *\n     * @param value A numeric value from the domain.\n     */\n    (value: NumberValue): number | Unknown;\n\n    /**\n     * Given a value from the range, returns the corresponding value from the domain. Inversion is useful for interaction,\n     * say to determine the data value corresponding to the position of the mouse.\n     *\n     * If the given value is outside the range, and clamping is not enabled, the mapping may be extrapolated such that the returned value is outside the domain.\n     *\n     * IMPORTANT: This method is only supported if the range is numeric. If the range is not numeric, returns NaN.\n     *\n     * For a valid value y in the range, continuous(continuous.invert(y)) approximately equals y;\n     * similarly, for a valid value x in the domain, continuous.invert(continuous(x)) approximately equals x.\n     * The scale and its inverse may not be exact due to the limitations of floating point precision.\n     *\n     * @param value A numeric value from the range.\n     */\n    invert(value: NumberValue): number;\n\n    /**\n     * Returns a copy of the scale’s current domain.\n     */\n    domain(): number[];\n    /**\n     * Sets the scale’s domain to the specified array of numbers. The array must contain two or more elements.\n     * If the elements in the given array are not numbers, they will be coerced to numbers\n     *\n     * Although continuous scales typically have two values each in their domain and range, specifying more than two values produces a piecewise scale.\n     *\n     * Internally, a piecewise scale performs a binary search for the range interpolator corresponding to the given domain value.\n     * Thus, the domain must be in ascending or descending order. If the domain and range have different lengths N and M, only the first min(N,M) elements in each are observed.\n     *\n     * @param domain Array of numeric domain values.\n     */\n    domain(domain: Iterable<NumberValue>): this;\n\n    /**\n     * Returns a copy of the scale’s current range.\n     */\n    range(): number[];\n    /**\n     * Sets the scale’s range to the specified array of values.\n     *\n     * The array must contain two or more elements. Unlike the domain, elements in the given array need not be numbers;\n     * any value that is supported by the underlying interpolator will work, though note that numeric ranges are required for invert.\n     *\n     * @param range Array of range values.\n     */\n    range(range: Iterable<NumberValue>): this;\n\n    /**\n     * Returns approximately count representative values from the scale’s domain.\n     *\n     * If count is not specified, it defaults to 10.\n     *\n     * The returned tick values are uniformly spaced, have human-readable values (such as multiples of powers of 10),\n     * and are guaranteed to be within the extent of the domain. Ticks are often used to display reference lines, or tick marks, in conjunction with the visualized data.\n     * The specified count is only a hint; the scale may return more or fewer values depending on the domain. See also d3-array’s ticks.\n     *\n     * @param count Optional approximate number of ticks to be returned. If count is not specified, it defaults to 10.\n     */\n    ticks(count?: number): number[];\n\n    /**\n     * Returns a number format function suitable for displaying a tick value, automatically computing the appropriate precision based on the fixed interval between tick values.\n     * The specified count should have the same value as the count that is used to generate the tick values.\n     *\n     * @param count Approximate number of ticks to be used when calculating precision for the number format function.\n     * @param specifier An optional valid format specifier string which allows a custom format where the precision of the format is automatically set by the scale as appropriate for the tick interval.\n     * If specifier uses the format type \"s\", the scale will return a SI-prefix format based on the largest value in the domain.\n     * If the specifier already specifies a precision, this method is equivalent to locale.format.\n     */\n    tickFormat(count?: number, specifier?: string): (d: NumberValue) => string;\n\n    /**\n     * Extends the domain so that it starts and ends on nice round values.\n     * This method typically modifies the scale’s domain, and may only extend the bounds to the nearest round value.\n     * An optional tick count argument allows greater control over the step size used to extend the bounds,\n     * guaranteeing that the returned ticks will exactly cover the domain.\n     * Nicing is useful if the domain is computed from data, say using extent, and may be irregular.\n     * For example, for a domain of [0.201479…, 0.996679…], a nice domain might be [0.2, 1.0].\n     * If the domain has more than two values, nicing the domain only affects the first and last value.\n     *\n     * Nicing a scale only modifies the current domain; it does not automatically nice domains that are subsequently set using continuous.domain.\n     * You must re-nice the scale after setting the new domain, if desired.\n     *\n     * @param count An optional number of ticks expected to be used.\n     */\n    nice(count?: number): this;\n\n    /**\n     * Returns an exact copy of this scale. Changes to this scale will not affect the returned scale, and vice versa.\n     */\n    copy(): this;\n\n    /**\n     * Returns the current unknown value, which defaults to undefined.\n     */\n    unknown(): UnknownReturnType<Unknown, undefined>;\n    /**\n     * Sets the output value of the scale for undefined (or NaN) input values and returns this scale.\n     *\n     * @param value The output value of the scale for undefined (or NaN) input values.\n     */\n    unknown<NewUnknown>(value: NewUnknown): ScaleIdentity<NewUnknown>;\n}\n\n/**\n * Constructs a new identity scale with the specified domain and range.\n * If range is not specified, it defaults to [0, 1].\n *\n * The generic corresponds to the data type of the unknown value.\n *\n * @param range Array of range values.\n */\n// eslint-disable-next-line @definitelytyped/no-unnecessary-generics\nexport function scaleIdentity<Unknown = never>(range?: Iterable<NumberValue>): ScaleIdentity<Unknown>;\n\n// -------------------------------------------------------------------------------\n// Radial Scale Factory\n// -------------------------------------------------------------------------------\n\nexport interface ScaleRadial<Range, Output, Unknown = never> extends ScaleContinuousNumeric<Range, Output, Unknown> {\n    /**\n     * Returns the current unknown value, which defaults to undefined.\n     */\n    unknown(): UnknownReturnType<Unknown, undefined>;\n    /**\n     * Sets the output value of the scale for undefined (or NaN) input values and returns this scale.\n     *\n     * @param value The output value of the scale for undefined (or NaN) input values.\n     */\n    unknown<NewUnknown>(value: NewUnknown): ScaleRadial<Range, Output, NewUnknown>;\n}\n\n/**\n * Constructs a new radial scale with the specified range.\n * The domain defaults to [0, 1].\n *\n * The first generic corresponds to the data type of the range elements.\n * The second generic corresponds to the data type of the unknown value.\n *\n * The range must be set in accordance with the range element type.\n *\n * @param range Iterable of range values.\n */\n// eslint-disable-next-line @definitelytyped/no-unnecessary-generics\nexport function scaleRadial<Range = number, Unknown = never>(\n    range?: Iterable<Range>,\n): ScaleRadial<Range, Range, Unknown>;\n/**\n * Constructs a new radial scale with the specified domain and range.\n *\n * The first generic corresponds to the data type of the range elements.\n * The second generic corresponds to the data type of the unknown value.\n *\n * The range must be set in accordance with the range element type.\n *\n * @param domain Iterable of numeric domain values.\n * @param range Iterable of range values.\n */\n// eslint-disable-next-line @definitelytyped/no-unnecessary-generics\nexport function scaleRadial<Range, Unknown = never>(\n    domain: Iterable<NumberValue>,\n    range: Iterable<Range>,\n): ScaleRadial<Range, Range, Unknown>;\n\n// -------------------------------------------------------------------------------\n// Time Scale Factories\n// -------------------------------------------------------------------------------\n\n/**\n * A linear scale defined over a temporal domain.\n *\n * Time scales implement ticks based on calendar intervals, taking the pain out of generating axes for temporal domains.\n *\n * If the range is numeric, the mapping may be inverted to return a date.\n *\n * Note that the data types of the range and output of the scale must be compatible with the interpolator applied by the scale.\n *\n * The first generic corresponds to the data type of the range elements.\n *\n * The second generic corresponds to the data type of the output elements generated by the scale.\n *\n * The third generic corresponds to the data type of the unknown value.\n *\n * If range element and output element type differ, the interpolator factory used with the scale must match this behavior and\n * convert the interpolated range element to a corresponding output element.\n */\nexport interface ScaleTime<Range, Output, Unknown = never> {\n    /**\n     * Given a value from the domain, returns the corresponding value from the range, subject to interpolation, if any.\n     *\n     * If the given value is outside the domain, and clamping is not enabled, the mapping may be extrapolated such that the returned value is outside the range.\n     *\n     * Note: The interpolation function applied by the scale may change the output type from the range type as part of the interpolation.\n     *\n     * @param value A temporal value from the domain. If the value is not a Date, it will be coerced to Date.\n     */\n    (value: Date | NumberValue): Output | Unknown;\n\n    /**\n     * Given a value from the range, returns the corresponding value from the domain. Inversion is useful for interaction,\n     * say to determine the data value corresponding to the position of the mouse.\n     *\n     * If the given value is outside the range, and clamping is not enabled, the mapping may be extrapolated such that the returned value is outside the domain.\n     *\n     * IMPORTANT: This method is only supported if the range is numeric. If the range is not numeric, returns Invalid Date.\n     *\n     * For a valid value y in the range, time(time.invert(y)) equals y; similarly, for a valid value x in the domain, time.invert(time(x)) equals x.\n     * The invert method is useful for interaction, say to determine the value in the domain that corresponds to the pixel location under the mouse.\n     *\n     * @param value A numeric value from the range.\n     */\n    invert(value: NumberValue): Date;\n\n    /**\n     * Returns a copy of the scale’s current domain.\n     */\n    domain(): Date[];\n\n    /**\n     * Sets the scale’s domain to the specified array of temporal domain values. The array must contain two or more elements.\n     * If the elements in the given array are not dates, they will be coerced to dates.\n     *\n     * Although continuous scales typically have two values each in their domain and range, specifying more than two values produces a piecewise scale.\n     *\n     * Internally, a piecewise scale performs a binary search for the range interpolator corresponding to the given domain value.\n     * Thus, the domain must be in ascending or descending order. If the domain and range have different lengths N and M, only the first min(N,M) elements in each are observed.\n     *\n     * @param domain Array of temporal domain values. Numeric values will be coerced to dates.\n     */\n    domain(domain: Iterable<Date | NumberValue>): this;\n\n    /**\n     * Returns a copy of the scale’s current range.\n     */\n    range(): Range[];\n    /**\n     * Sets the scale’s range to the specified array of values.\n     *\n     * The array must contain two or more elements. Unlike the domain, elements in the given array need not be temporal domain values;\n     * any value that is supported by the underlying interpolator will work, though note that numeric ranges are required for invert.\n     *\n     * @param range Array of range values.\n     */\n    range(range: Iterable<Range>): this;\n\n    /**\n     * Sets the scale’s range to the specified array of values while also setting the scale’s interpolator to interpolateRound.\n     *\n     * The rounding interpolator is sometimes useful for avoiding antialiasing artifacts,\n     * though also consider the shape-rendering “crispEdges” styles. Note that this interpolator can only be used with numeric ranges.\n     *\n     * The array must contain two or more elements. Unlike the domain, elements in the given array need not be temporal domain values;\n     * any value that is supported by the underlying interpolator will work, though note that numeric ranges are required for invert.\n     *\n     * @param range Array of range values.\n     */\n    rangeRound(range: Iterable<NumberValue>): this;\n\n    /**\n     * Returns whether or not the scale currently clamps values to within the range.\n     */\n    clamp(): boolean;\n    /**\n     * Enables or disables clamping, respectively. If clamping is disabled and the scale is passed a value outside the domain,\n     * the scale may return a value outside the range through extrapolation.\n     *\n     * If clamping is enabled, the return value of the scale is always within the scale’s range. Clamping similarly applies to the \"invert\" method.\n     *\n     * @param clamp A flag to enable (true) or disable (false) clamping.\n     */\n    clamp(clamp: boolean): this;\n\n    /**\n     * Returns the scale’s current interpolator factory, which defaults to interpolate.\n     */\n    interpolate(): InterpolatorFactory<any, any>;\n\n    /**\n     * Sets the scale’s range interpolator factory. This interpolator factory is used to create interpolators for each adjacent pair of values from the range;\n     * these interpolators then map a normalized domain parameter t in [0, 1] to the corresponding value in the range.\n     *\n     * Note: the default interpolator may reuse return values. For example, if the range values are objects, then the value interpolator always returns the same object, modifying it in-place.\n     * If the scale is used to set an attribute or style, this is typically acceptable (and desirable for performance);\n     * however, if you need to store the scale’s return value, you must specify your own interpolator or make a copy as appropriate.\n     *\n     * As part of the interpolation process the interpolated value from the range may be converted to a corresponding output value.\n     *\n     * @param interpolate An interpolation factory. The generics for Range and Output of the scale must correspond to the interpolation factory applied to the scale.\n     */\n    interpolate(interpolate: InterpolatorFactory<Range, Output>): this;\n    /**\n     * Sets the scale’s range interpolator factory. This interpolator factory is used to create interpolators for each adjacent pair of values from the range;\n     * these interpolators then map a normalized domain parameter t in [0, 1] to the corresponding value in the range.\n     *\n     * Note: the default interpolator may reuse return values. For example, if the range values are objects, then the value interpolator always returns the same object, modifying it in-place.\n     * If the scale is used to set an attribute or style, this is typically acceptable (and desirable for performance);\n     * however, if you need to store the scale’s return value, you must specify your own interpolator or make a copy as appropriate.\n     *\n     * As part of the interpolation process the interpolated value from the range may be converted to a corresponding output value.\n     *\n     * The generic \"NewOutput\" can be used to change the scale to have a different output element type corresponding to the new interpolation factory.\n     *\n     * @param interpolate An interpolation factory. The generics for Range and Output of the scale must correspond to the interpolation factory applied to the scale.\n     */\n    interpolate<NewOutput>(interpolate: InterpolatorFactory<Range, NewOutput>): ScaleTime<Range, NewOutput, Unknown>;\n\n    /**\n     * Returns representative dates from the scale’s domain. The returned tick values are uniformly-spaced (mostly),\n     * have sensible values (such as every day at midnight), and are guaranteed to be within the extent of the domain.\n     * Ticks are often used to display reference lines, or tick marks, in conjunction with the visualized data.\n     *\n     * An optional count may be specified to affect how many ticks are generated. If count is not specified, it defaults to 10.\n     * The specified count is only a hint; the scale may return more or fewer values depending on the domain.\n     *\n     * @param count Expected number of ticks.\n     */\n    ticks(count?: number): Date[];\n    /**\n     * Returns representative dates from the scale’s domain. The returned tick values are uniformly-spaced (mostly),\n     * have sensible values (such as every day at midnight), and are guaranteed to be within the extent of the domain.\n     * Ticks are often used to display reference lines, or tick marks, in conjunction with the visualized data.\n     *\n     * The specified time interval controls the ticks generated and returned. To prune the generated ticks for a given time interval,\n     * use interval.every(...) or interval.filter(...).\n     *\n     * @param interval A time interval to specify the expected ticks.\n     */\n    ticks(interval: TimeInterval): Date[];\n\n    /**\n     * Returns a time format function suitable for displaying tick values.\n     *\n     * The default multi-scale time format chooses a human-readable representation based on the specified date as follows:\n     *\n     *  - %Y - for year boundaries, such as 2011.\n     *  - %B - for month boundaries, such as February.\n     *  - %b %d - for week boundaries, such as Feb 06.\n     *  - %a %d - for day boundaries, such as Mon 07.\n     *  - %I %p - for hour boundaries, such as 01 AM.\n     *  - %I:%M - for minute boundaries, such as 01:23.\n     *  - :%S - for second boundaries, such as :45.\n     *  - .%L - milliseconds for all other times, such as .012.\n     *\n     * Although somewhat unusual, this default behavior has the benefit of providing both local and global context:\n     * for example, formatting a sequence of ticks as [11 PM, Mon 07, 01 AM] reveals information about hours, dates, and day simultaneously,\n     * rather than just the hours [11 PM, 12 AM, 01 AM].\n     *\n     * The specified count is currently ignored, but is accepted for consistency with other scales such as continuous.tickFormat.\n     *\n     * @param count Expected number of ticks. (Currently ignored)\n     * @param specifier An optional valid date format specifier string (see d3-time-format).\n     */\n    tickFormat(count?: number, specifier?: string): (d: Date) => string;\n    /**\n     * Returns a time format function suitable for displaying tick values.\n     *\n     * The specified time interval is currently ignored, but is accepted for consistency with other scales such as continuous.tickFormat.\n     *\n     * @param interval A time interval to specify the expected ticks. (Currently ignored)\n     * @param specifier An optional valid date format specifier string (see d3-time-format).\n     */\n    tickFormat(interval: TimeInterval, specifier?: string): (d: Date) => string;\n\n    /**\n     * Extends the domain so that it starts and ends on nice round values.\n     * This method typically modifies the scale’s domain, and may only extend the bounds to the nearest round value.\n     *\n     * An optional count argument allows greater control over the step size used to extend the bounds, guaranteeing that the returned ticks will exactly cover the domain.\n     *\n     * Nicing is useful if the domain is computed from data, say using extent, and may be irregular.\n     * For example, for a domain of [2009-07-13T00:02, 2009-07-13T23:48], the nice domain is [2009-07-13, 2009-07-14].\n     * If the domain has more than two values, nicing the domain only affects the first and last value.\n     *\n     * @param count Expected number of ticks.\n     */\n    nice(count?: number): this;\n    /**\n     * Extends the domain so that it starts and ends on nice round values.\n     * This method typically modifies the scale’s domain, and may only extend the bounds to the nearest round value.\n     *\n     * A time interval may be specified to explicitly set the ticks.\n     * If an interval is specified, an optional step may also be specified to skip some ticks.\n     * For example, time.nice(d3.timeSecond.every(10)) will extend the domain to an even ten seconds (0, 10, 20, etc.).\n     * See time.ticks and interval.every for further detail.\n     *\n     * Nicing is useful if the domain is computed from data, say using extent, and may be irregular.\n     * For example, for a domain of [2009-07-13T00:02, 2009-07-13T23:48], the nice domain is [2009-07-13, 2009-07-14].\n     * If the domain has more than two values, nicing the domain only affects the first and last value.\n     *\n     * @param interval A time interval to specify the expected ticks.\n     */\n    nice(interval: CountableTimeInterval): this;\n\n    /**\n     * Returns an exact copy of this scale. Changes to this scale will not affect the returned scale, and vice versa.\n     */\n    copy(): this;\n\n    /**\n     * Returns the current unknown value, which defaults to undefined.\n     */\n    unknown(): UnknownReturnType<Unknown, undefined>;\n    /**\n     * Sets the output value of the scale for undefined (or NaN) input values and returns this scale.\n     *\n     * @param value The output value of the scale for undefined (or NaN) input values.\n     */\n    unknown<NewUnknown>(value: NewUnknown): ScaleTime<Range, Output, NewUnknown>;\n}\n\n/**\n * Constructs a new time scale with the specified range, the default interpolator and clamping disabled.\n * The domain defaults to [2000-01-01, 2000-01-02].\n * If range is not specified, it defaults to [0, 1].\n *\n * The first generic corresponds to the data type of the range elements.\n * The second generic corresponds to the data type of the output elements generated by the scale.\n * The third generic corresponds to the data type of the unknown value.\n *\n * If range element and output element type differ, the interpolator factory used with the scale must match this behavior and\n * convert the interpolated range element to a corresponding output element.\n *\n * The range must be set in accordance with the range element type.\n *\n * The interpolator factory may be set using the interpolate(...) method of the scale.\n *\n * @param range Array of range values.\n */\n// eslint-disable-next-line @definitelytyped/no-unnecessary-generics\nexport function scaleTime<Range = number, Output = Range, Unknown = never>(\n    range?: Iterable<Range>,\n): ScaleTime<Range, Output, Unknown>;\n/**\n * Constructs a new time scale with the specified domain and range, the default interpolator and clamping disabled.\n *\n * The first generic corresponds to the data type of the range elements.\n * The second generic corresponds to the data type of the output elements generated by the scale.\n * The third generic corresponds to the data type of the unknown value.\n *\n * If range element and output element type differ, the interpolator factory used with the scale must match this behavior and\n * convert the interpolated range element to a corresponding output element.\n *\n * The range must be set in accordance with the range element type.\n *\n * The interpolator factory may be set using the interpolate(...) method of the scale.\n *\n * @param domain Array of temporal domain values. Numeric values will be coerced to dates.\n * @param range Array of range values.\n */\n// eslint-disable-next-line @definitelytyped/no-unnecessary-generics\nexport function scaleTime<Range, Output = Range, Unknown = never>(\n    domain: Iterable<Date | NumberValue>,\n    range: Iterable<Range>,\n): ScaleTime<Range, Output, Unknown>;\n\n/**\n * Constructs a new time scale using Coordinated Universal Time (UTC) with the specified range, the default interpolator and clamping disabled.\n * The domain defaults to [2000-01-01, 2000-01-02].\n * If range is not specified, it defaults to [0, 1].\n *\n * The first generic corresponds to the data type of the range elements.\n * The second generic corresponds to the data type of the output elements generated by the scale.\n * The third generic corresponds to the data type of the unknown value.\n *\n * If range element and output element type differ, the interpolator factory used with the scale must match this behavior and\n * convert the interpolated range element to a corresponding output element.\n *\n * The range must be set in accordance with the range element type.\n *\n * The interpolator factory may be set using the interpolate(...) method of the scale.\n *\n * @param range Array of range values.\n */\n// eslint-disable-next-line @definitelytyped/no-unnecessary-generics\nexport function scaleUtc<Range = number, Output = Range, Unknown = never>(\n    range?: Iterable<Range>,\n): ScaleTime<Range, Output, Unknown>;\n/**\n * Constructs a new time scale using Coordinated Universal Time (UTC) with the specified domain and range, the default interpolator and clamping disabled.\n *\n * The first generic corresponds to the data type of the range elements.\n * The second generic corresponds to the data type of the output elements generated by the scale.\n * The third generic corresponds to the data type of the unknown value.\n *\n * If range element and output element type differ, the interpolator factory used with the scale must match this behavior and\n * convert the interpolated range element to a corresponding output element.\n *\n * The range must be set in accordance with the range element type.\n *\n * The interpolator factory may be set using the interpolate(...) method of the scale.\n *\n * @param domain Array of temporal domain values. Numeric values will be coerced to dates.\n * @param range Array of range values.\n */\n// eslint-disable-next-line @definitelytyped/no-unnecessary-generics\nexport function scaleUtc<Range, Output = Range, Unknown = never>(\n    domain: Iterable<NumberValue>,\n    range: Iterable<Range>,\n): ScaleTime<Range, Output, Unknown>;\n\n// -------------------------------------------------------------------------------\n// Sequential Scale Factory\n// -------------------------------------------------------------------------------\n\n/**\n * Sequential scales are similar to continuous scales in that they map a continuous, numeric input domain to a continuous output range.\n * However, unlike continuous scales, the input domain and output range of a sequential scale always has exactly two elements,\n * and the output range is typically specified as an interpolator rather than an array of values.\n * These scales do not expose invert and interpolate methods.\n *\n * The first generic corresponds to the data type of the output of the interpolator underlying the scale.\n *\n * The second generic corresponds to the data type of the unknown value.\n */\nexport interface ScaleSequentialBase<Output, Unknown = never> {\n    /**\n     * Given a value from the domain, returns the corresponding value from the output range, subject to interpolation.\n     *\n     * If the given value is outside the domain, and clamping is not enabled, the mapping may be extrapolated such that the returned value is outside the range.\n     *\n     * @param value A numeric value from the domain.\n     */\n    (value: NumberValue): Output | Unknown;\n\n    /**\n     * Returns a copy of the scale’s current domain.\n     */\n    domain(): [number, number];\n    /**\n     * Sets the scale’s domain to the specified array of numbers. The array must contain exactly two elements.\n     * If the elements in the given array are not numbers, they will be coerced to numbers\n     *\n     * @param domain A two-element array of numeric domain values.\n     */\n    domain(domain: Iterable<NumberValue>): this;\n\n    /**\n     * Returns whether or not the scale currently clamps values to within the range.\n     */\n    clamp(): boolean;\n    /**\n     * Enables or disables clamping, respectively. If clamping is disabled and the scale is passed a value outside the domain,\n     * the scale may return a value outside the range through extrapolation.\n     *\n     * If clamping is enabled, the return value of the scale is always within the scale’s range. Clamping similarly applies to the \"invert\" method.\n     *\n     * @param clamp A flag to enable (true) or disable (false) clamping.\n     */\n    clamp(clamp: boolean): this;\n\n    /**\n     * See continuous.range.\n     */\n    range(): [Output, Output];\n    /**\n     * See continuous.range.\n     * The given two-element array is converted to an interpolator function using d3.interpolate.\n     *\n     * @param range Range values.\n     */\n    range(range: Iterable<Output>): this;\n\n    /**\n     * See continuous.rangeRound.\n     * If range is specified, implicitly uses d3.interpolateRound as the interpolator.\n     *\n     * @param range Range values.\n     */\n    rangeRound(range: Iterable<NumberValue>): this;\n\n    /**\n     * Returns an exact copy of this scale. Changes to this scale will not affect the returned scale, and vice versa.\n     */\n    copy(): this;\n}\n\nexport interface ScaleSequential<Output, Unknown = never> extends ScaleSequentialBase<Output, Unknown> {\n    /**\n     * Returns the current interpolator underlying the scale.\n     */\n    interpolator(): (t: number) => Output;\n    /**\n     * Sets the scale’s interpolator to the specified function.\n     *\n     * @param interpolator An interpolator function mapping a value from the [0, 1] interval to an output value.\n     */\n    interpolator(interpolator: (t: number) => Output): this;\n    /**\n     * Sets the scale’s interpolator to the specified function.\n     *\n     * The generic corresponds to a the new output type of the scale. The output type of the scale is determined by the output type of the interpolator function.\n     *\n     * @param interpolator An interpolator function mapping a value from the [0, 1] interval to an output value.\n     */\n    interpolator<NewOutput>(interpolator: (t: number) => NewOutput): ScaleSequential<NewOutput, Unknown>;\n\n    /**\n     * Returns the current unknown value, which defaults to undefined.\n     */\n    unknown(): UnknownReturnType<Unknown, undefined>;\n    /**\n     * Sets the output value of the scale for undefined (or NaN) input values and returns this scale.\n     *\n     * @param value The output value of the scale for undefined (or NaN) input values.\n     */\n    unknown<NewUnknown>(value: NewUnknown): ScaleSequential<Output, NewUnknown>;\n}\n\n/**\n * Constructs a new sequential scale with the specified interpolator function or array.\n * The domain defaults to [0, 1].\n * If interpolator is not specified, it defaults to the identity function.\n * When the scale is applied, the interpolator will be invoked with a value typically in the range [0, 1], where 0 represents the minimum value and 1 represents the maximum value.\n *\n * If interpolator is an array, it represents the scale’s two-element output range and is converted to an interpolator function using d3.interpolate.\n *\n * The first generic corresponds to the data type of the output of the interpolator underlying the scale.\n * The second generic corresponds to the data type of the unknown value.\n *\n * @param interpolator The interpolator function or array to be used with the scale.\n */\n// eslint-disable-next-line @definitelytyped/no-unnecessary-generics\nexport function scaleSequential<Output = number, Unknown = never>(\n    interpolator?: ((t: number) => Output) | Iterable<Output>,\n): ScaleSequential<Output, Unknown>;\n/**\n * Constructs a new sequential scale with the specified domain and interpolator function or array.\n * When the scale is applied, the interpolator will be invoked with a value typically in the range [0, 1], where 0 represents the minimum value and 1 represents the maximum value.\n *\n * If interpolator is an array, it represents the scale’s two-element output range and is converted to an interpolator function using d3.interpolate.\n *\n * The first generic corresponds to the data type of the output of the interpolator underlying the scale.\n * The second generic corresponds to the data type of the unknown value.\n *\n * @param domain A two-element array of numeric domain values.\n * @param interpolator The interpolator function or array to be used with the scale.\n */\n// eslint-disable-next-line @definitelytyped/no-unnecessary-generics\nexport function scaleSequential<Output, Unknown = never>(\n    domain: Iterable<NumberValue>,\n    interpolator: ((t: number) => Output) | Iterable<Output>,\n): ScaleSequential<Output, Unknown>;\n\n/**\n * A sequential scale with a logarithmic transform, analogous to a log scale.\n *\n * The first generic corresponds to the data type of the output of the interpolator underlying the scale.\n * The second generic corresponds to the data type of the unknown value.\n *\n * @param interpolator The interpolator function to be used with the scale.\n */\n// eslint-disable-next-line @definitelytyped/no-unnecessary-generics\nexport function scaleSequentialLog<Output = number, Unknown = never>(\n    interpolator?: (t: number) => Output,\n): ScaleSequential<Output, Unknown>;\n/**\n * A sequential scale with a logarithmic transform, analogous to a log scale.\n *\n * The first generic corresponds to the data type of the output of the interpolator underlying the scale.\n * The second generic corresponds to the data type of the unknown value.\n *\n * @param domain A two-element array of numeric domain values.\n * @param interpolator The interpolator function to be used with the scale.\n */\n// eslint-disable-next-line @definitelytyped/no-unnecessary-generics\nexport function scaleSequentialLog<Output, Unknown = never>(\n    domain: Iterable<NumberValue>,\n    interpolator: (t: number) => Output,\n): ScaleSequential<Output, Unknown>;\n\n/**\n * A sequential scale with a exponential transform, analogous to a power scale.\n *\n * The first generic corresponds to the data type of the output of the interpolator underlying the scale.\n * The second generic corresponds to the data type of the unknown value.\n *\n * @param interpolator The interpolator function to be used with the scale.\n */\n// eslint-disable-next-line @definitelytyped/no-unnecessary-generics\nexport function scaleSequentialPow<Output = number, Unknown = never>(\n    interpolator?: (t: number) => Output,\n): ScaleSequential<Output, Unknown>;\n/**\n * A sequential scale with a exponential transform, analogous to a power scale.\n *\n * The first generic corresponds to the data type of the output of the interpolator underlying the scale.\n * The second generic corresponds to the data type of the unknown value.\n *\n * @param domain A two-element array of numeric domain values.\n * @param interpolator The interpolator function to be used with the scale.\n */\n// eslint-disable-next-line @definitelytyped/no-unnecessary-generics\nexport function scaleSequentialPow<Output, Unknown = never>(\n    domain: Iterable<NumberValue>,\n    interpolator: (t: number) => Output,\n): ScaleSequential<Output, Unknown>;\n\n/**\n * A sequential scale with a square-root transform, analogous to a d3.scaleSqrt.\n *\n * The first generic corresponds to the data type of the output of the interpolator underlying the scale.\n * The second third generic corresponds to the data type of the unknown value.\n *\n * @param interpolator The interpolator function to be used with the scale.\n */\n// eslint-disable-next-line @definitelytyped/no-unnecessary-generics\nexport function scaleSequentialSqrt<Output = number, Unknown = never>(\n    interpolator?: (t: number) => Output,\n): ScaleSequential<Output, Unknown>;\n/**\n * A sequential scale with a square-root transform, analogous to a d3.scaleSqrt.\n *\n * The first generic corresponds to the data type of the output of the interpolator underlying the scale.\n * The second generic corresponds to the data type of the unknown value.\n *\n * @param domain A two-element array of numeric domain values.\n * @param interpolator The interpolator function to be used with the scale.\n */\n// eslint-disable-next-line @definitelytyped/no-unnecessary-generics\nexport function scaleSequentialSqrt<Output, Unknown = never>(\n    domain: Iterable<NumberValue>,\n    interpolator: (t: number) => Output,\n): ScaleSequential<Output, Unknown>;\n\n/**\n * A sequential scale with a symmetric logarithmic transform, analogous to a symlog scale.\n *\n * The first generic corresponds to the data type of the output of the interpolator underlying the scale.\n * The second generic corresponds to the data type of the unknown value.\n *\n * @param interpolator The interpolator function to be used with the scale.\n */\n// eslint-disable-next-line @definitelytyped/no-unnecessary-generics\nexport function scaleSequentialSymlog<Output = number, Unknown = never>(\n    interpolator?: (t: number) => Output,\n): ScaleSequential<Output, Unknown>;\n/**\n * A sequential scale with a symmetric logarithmic transform, analogous to a symlog scale.\n *\n * The first generic corresponds to the data type of the output of the interpolator underlying the scale.\n * The second generic corresponds to the data type of the unknown value.\n *\n * @param domain A two-element array of numeric domain values.\n * @param interpolator The interpolator function to be used with the scale.\n */\n// eslint-disable-next-line @definitelytyped/no-unnecessary-generics\nexport function scaleSequentialSymlog<Output, Unknown = never>(\n    domain: Iterable<NumberValue>,\n    interpolator: (t: number) => Output,\n): ScaleSequential<Output, Unknown>;\n\nexport interface ScaleSequentialQuantile<Output, Unknown = never> extends ScaleSequentialBase<Output, Unknown> {\n    /**\n     * Returns an array of n + 1 quantiles.\n     * For example, if n = 4, returns an array of five numbers: the minimum value, the first quartile, the median, the third quartile, and the maximum.\n     */\n    quantiles(): number[];\n\n    /**\n     * Returns the current interpolator underlying the scale.\n     */\n    interpolator(): (t: number) => Output;\n    /**\n     * Sets the scale’s interpolator to the specified function.\n     *\n     * @param interpolator An interpolator function mapping a value from the [0, 1] interval to an output value.\n     */\n    interpolator(interpolator: (t: number) => Output): this;\n    /**\n     * Sets the scale’s interpolator to the specified function.\n     *\n     * The generic corresponds to a the new output type of the scale. The output type of the scale is determined by the output type of the interpolator function.\n     *\n     * @param interpolator An interpolator function mapping a value from the [0, 1] interval to an output value.\n     */\n    interpolator<NewOutput>(interpolator: (t: number) => NewOutput): ScaleSequentialQuantile<NewOutput, Unknown>;\n\n    /**\n     * Returns the current unknown value, which defaults to undefined.\n     */\n    unknown(): UnknownReturnType<Unknown, undefined>;\n    /**\n     * Sets the output value of the scale for undefined (or NaN) input values and returns this scale.\n     *\n     * @param value The output value of the scale for undefined (or NaN) input values.\n     */\n    unknown<NewUnknown>(value: NewUnknown): ScaleSequentialQuantile<Output, NewUnknown>;\n}\n\n/**\n * A sequential scale using a p-quantile transform, analogous to a quantile scale.\n *\n * The first generic corresponds to the data type of the output of the interpolator underlying the scale.\n * The second generic corresponds to the data type of the unknown value.\n *\n * @param interpolator The interpolator function to be used with the scale.\n */\n// eslint-disable-next-line @definitelytyped/no-unnecessary-generics\nexport function scaleSequentialQuantile<Output = number, Unknown = never>(\n    interpolator?: (t: number) => Output,\n): ScaleSequentialQuantile<Output, Unknown>;\n/**\n * A sequential scale using a p-quantile transform, analogous to a quantile scale.\n *\n * The first generic corresponds to the data type of the output of the interpolator underlying the scale.\n * The second generic corresponds to the data type of the unknown value.\n *\n * @param domain A two-element array of numeric domain values.\n * @param interpolator The interpolator function to be used with the scale.\n */\n// eslint-disable-next-line @definitelytyped/no-unnecessary-generics\nexport function scaleSequentialQuantile<Output, Unknown = never>(\n    domain: Iterable<NumberValue>,\n    interpolator: (t: number) => Output,\n): ScaleSequentialQuantile<Output, Unknown>;\n\n// -------------------------------------------------------------------------------\n// Diverging Scale Factory\n// -------------------------------------------------------------------------------\n\n/**\n * Diverging scales, like sequential scales, are similar to continuous scales in that they map a continuous, numeric input domain to a continuous output range.\n * However, unlike continuous scales, the input domain and output range of a diverging scale always has exactly three elements,\n * and the output range is typically specified as an interpolator rather than an array of values.\n * These scales do not expose invert and interpolate methods.\n *\n * The first generic corresponds to the data type of the interpolator return type.\n *\n * The second generic corresponds to the data type of the unknown value.\n */\nexport interface ScaleDiverging<Output, Unknown = never> {\n    /**\n     * Given a value from the domain, returns the corresponding value subject to interpolation.\n     *\n     * If the given value is outside the domain, and clamping is not enabled, the mapping may be extrapolated such that the returned value is outside the range.\n     *\n     * @param value A numeric value from the domain.\n     */\n    (value: NumberValue): Output | Unknown;\n\n    /**\n     * Returns a copy of the scale’s current domain.\n     */\n    domain(): [number, number, number];\n    /**\n     * Sets the scale’s domain to the specified array of numbers.\n     * The domain must be numeric and must contain exactly three values. The default domain is [0, 0.5, 1].\n     * If the elements in the given array are not numbers, they will be coerced to numbers\n     *\n     * @param domain Array of three numeric domain values.\n     */\n    domain(domain: Iterable<NumberValue>): this;\n\n    /**\n     * Returns whether or not the scale currently clamps values to within the range.\n     */\n    clamp(): boolean;\n    /**\n     * Enables or disables clamping, respectively. If clamping is disabled and the scale is passed a value outside the domain,\n     * the scale may return a value outside the range through extrapolation.\n     *\n     * If clamping is enabled, the return value of the scale is always within the interpolator scale’s range.\n     *\n     * @param clamp A flag to enable (true) or disable (false) clamping.\n     */\n    clamp(clamp: boolean): this;\n\n    /**\n     * Returns the scale’s current interpolator.\n     */\n    interpolator(): (t: number) => Output;\n    /**\n     * Sets the scale’s interpolator to the specified function.\n     *\n     * @param interpolator The scale’s interpolator.\n     */\n    interpolator(interpolator?: (t: number) => Output): this;\n\n    /**\n     * See continuous.range.\n     */\n    range(): [Output, Output, Output];\n    /**\n     * See continuous.range.\n     * The given two-element array is converted to an interpolator function using d3.interpolate and d3.piecewise.\n     *\n     * @param range Range values.\n     */\n    range(range: Iterable<Output>): this;\n\n    /**\n     * See continuous.rangeRound.\n     * If range is specified, implicitly uses d3.interpolateRound as the interpolator.\n     *\n     * @param range Range values.\n     */\n    rangeRound(range: Iterable<NumberValue>): this;\n\n    /**\n     * Returns an exact copy of this scale. Changes to this scale will not affect the returned scale, and vice versa.\n     */\n    copy(): this;\n\n    /**\n     * Returns the current unknown value, which defaults to undefined.\n     */\n    unknown(): UnknownReturnType<Unknown, undefined>;\n    /**\n     * Sets the output value of the scale for undefined (or NaN) input values and returns this scale.\n     *\n     * @param value The output value of the scale for undefined (or NaN) input values.\n     */\n    unknown<NewUnknown>(value: NewUnknown): ScaleDiverging<Output, NewUnknown>;\n}\n\n/**\n * Constructs a new diverging scale with the specified interpolator function or array.\n * The domain defaults to [0, 0.5, 1].\n * If interpolator is not specified, it defaults to the identity function.\n * When the scale is applied, the interpolator will be invoked with a value typically in the range [0, 1],\n * where 0 represents the extreme negative value, 0.5 represents the neutral value, and 1 represents the extreme positive value.\n *\n * If interpolator is an array, it represents the scale’s three-element output range and is converted to an interpolator function using d3.interpolate and d3.piecewise.\n *\n * The first generic corresponds to the data type of the interpolator return type.\n * The second generic corresponds to the data type of the unknown value.\n *\n * @param interpolator The scale’s interpolator function or array.\n */\n// eslint-disable-next-line @definitelytyped/no-unnecessary-generics\nexport function scaleDiverging<Output = number, Unknown = never>(\n    interpolator?: ((t: number) => Output) | Iterable<Output>,\n): ScaleDiverging<Output, Unknown>;\n/**\n * Constructs a new diverging scale with the specified domain and interpolator function or array.\n * When the scale is applied, the interpolator will be invoked with a value typically in the range [0, 1],\n * where 0 represents the extreme negative value, 0.5 represents the neutral value, and 1 represents the extreme positive value.\n *\n * If interpolator is an array, it represents the scale’s three-element output range and is converted to an interpolator function using d3.interpolate and d3.piecewise.\n *\n * The first generic corresponds to the data type of the interpolator return type.\n * The second generic corresponds to the data type of the unknown value.\n *\n * @param domain Array of three numeric domain values.\n * @param interpolator The scale’s interpolator function or array.\n */\n// eslint-disable-next-line @definitelytyped/no-unnecessary-generics\nexport function scaleDiverging<Output, Unknown = never>(\n    domain: Iterable<NumberValue>,\n    interpolator: ((t: number) => Output) | Iterable<Output>,\n): ScaleDiverging<Output, Unknown>;\n\n/**\n * A diverging scale with a logarithmic transform, analogous to a log scale.\n *\n * The first generic corresponds to the data type of the interpolator return type.\n * The second generic corresponds to the data type of the unknown value.\n *\n * @param interpolator The scale’s interpolator.\n */\n// eslint-disable-next-line @definitelytyped/no-unnecessary-generics\nexport function scaleDivergingLog<Output = number, Unknown = never>(\n    interpolator?: (t: number) => Output,\n): ScaleDiverging<Output, Unknown>;\n/**\n * A diverging scale with a logarithmic transform, analogous to a log scale.\n *\n * The first generic corresponds to the data type of the interpolator return type.\n * The second generic corresponds to the data type of the unknown value.\n *\n * @param domain Array of three numeric domain values.\n * @param interpolator The scale’s interpolator.\n */\n// eslint-disable-next-line @definitelytyped/no-unnecessary-generics\nexport function scaleDivergingLog<Output, Unknown = never>(\n    domain: Iterable<NumberValue>,\n    interpolator: (t: number) => Output,\n): ScaleDiverging<Output, Unknown>;\n\n/**\n * A diverging scale with a exponential transform, analogous to a power scale.\n *\n * The first generic corresponds to the data type of the interpolator return type.\n * The second generic corresponds to the data type of the unknown value.\n *\n * @param interpolator The scale’s interpolator.\n */\n// eslint-disable-next-line @definitelytyped/no-unnecessary-generics\nexport function scaleDivergingPow<Output = number, Unknown = never>(\n    interpolator?: (t: number) => Output,\n): ScaleDiverging<Output, Unknown>;\n/**\n * A diverging scale with a exponential transform, analogous to a power scale.\n *\n * The first generic corresponds to the data type of the interpolator return type.\n * The second generic corresponds to the data type of the unknown value.\n *\n * @param domain Array of three numeric domain values.\n * @param interpolator The scale’s interpolator.\n */\n// eslint-disable-next-line @definitelytyped/no-unnecessary-generics\nexport function scaleDivergingPow<Output, Unknown = never>(\n    domain: Iterable<NumberValue>,\n    interpolator: (t: number) => Output,\n): ScaleDiverging<Output, Unknown>;\n\n/**\n * A diverging scale with a square-root transform, analogous to a d3.scaleSqrt.\n *\n * The first generic corresponds to the data type of the interpolator return type.\n * The second generic corresponds to the data type of the unknown value.\n *\n * @param interpolator The scale’s interpolator.\n */\n// eslint-disable-next-line @definitelytyped/no-unnecessary-generics\nexport function scaleDivergingSqrt<Output = number, Unknown = never>(\n    interpolator?: (t: number) => Output,\n): ScaleDiverging<Output, Unknown>;\n/**\n * A diverging scale with a square-root transform, analogous to a d3.scaleSqrt.\n *\n * The first generic corresponds to the data type of the interpolator return type.\n * The second generic corresponds to the data type of the unknown value.\n *\n * @param domain Array of three numeric domain values.\n * @param interpolator The scale’s interpolator.\n */\n// eslint-disable-next-line @definitelytyped/no-unnecessary-generics\nexport function scaleDivergingSqrt<Output, Unknown = never>(\n    domain: Iterable<NumberValue>,\n    interpolator: (t: number) => Output,\n): ScaleDiverging<Output, Unknown>;\n\n/**\n * A diverging scale with a symmetric logarithmic transform, analogous to a symlog scale.\n *\n * The first generic corresponds to the data type of the interpolator return type.\n * The second generic corresponds to the data type of the unknown value.\n *\n * @param interpolator The scale’s interpolator.\n */\n// eslint-disable-next-line @definitelytyped/no-unnecessary-generics\nexport function scaleDivergingSymlog<Output = number, Unknown = never>(\n    interpolator?: (t: number) => Output,\n): ScaleDiverging<Output, Unknown>;\n/**\n * A diverging scale with a symmetric logarithmic transform, analogous to a symlog scale.\n *\n * The first generic corresponds to the data type of the interpolator return type.\n * The second generic corresponds to the data type of the unknown value.\n *\n * @param domain Array of three numeric domain values.\n * @param interpolator The scale’s interpolator.\n */\n// eslint-disable-next-line @definitelytyped/no-unnecessary-generics\nexport function scaleDivergingSymlog<Output, Unknown = never>(\n    domain: Iterable<NumberValue>,\n    interpolator: (t: number) => Output,\n): ScaleDiverging<Output, Unknown>;\n\n// -------------------------------------------------------------------------------\n// Quantize Scale Factory\n// -------------------------------------------------------------------------------\n\n/**\n * Quantize scales are similar to linear scales, except they use a discrete rather than continuous range.\n * The continuous input domain is divided into uniform segments based on the number of values in (i.e., the cardinality of) the output range.\n *\n * Each range value y can be expressed as a quantized linear function of the domain value x: y = m round(x) + b.\n *\n * The first generic corresponds to the data type of the range elements.\n *\n * The second generic corresponds to the data type of the unknown value.\n */\nexport interface ScaleQuantize<Range, Unknown = never> {\n    /**\n     * Given a value in the input domain, returns the corresponding value in the output range.\n     */\n    (value: NumberValue): Range | Unknown;\n    /**\n     * Returns the extent of values in the domain [x0, x1] for the corresponding value in the range: the inverse of quantize.\n     * This method is useful for interaction, say to determine the value in the domain that corresponds to the pixel location under the mouse.\n     *\n     * If an invalid range value is entered, returns [NaN, NaN].\n     *\n     * @param value A value from the range.\n     */\n    invertExtent(value: Range): [number, number];\n\n    /**\n     * Returns the scale’s current domain.\n     */\n    domain(): [number, number];\n\n    /**\n     * Sets the scale’s domain to the specified two-element array of numbers.\n     * If the elements in the given array are not numbers, they will be coerced to numbers.\n     *\n     * @param domain A two-element array of numeric values defining the domain.\n     */\n    domain(domain: Iterable<NumberValue>): this;\n\n    /**\n     * Returns the scale’s current range.\n     */\n    range(): Range[];\n    /**\n     * Sets the scale’s range to the specified array of values. The array may contain any number of discrete values.\n     *\n     * @param range Array of range values.\n     */\n    range(range: Iterable<Range>): this;\n\n    /**\n     * Returns approximately count representative values from the scale’s domain.\n     *\n     * If count is not specified, it defaults to 10.\n     *\n     * The returned tick values are uniformly spaced, have human-readable values (such as multiples of powers of 10),\n     * and are guaranteed to be within the extent of the domain. Ticks are often used to display reference lines, or tick marks, in conjunction with the visualized data.\n     * The specified count is only a hint; the scale may return more or fewer values depending on the domain. See also d3-array’s ticks.\n     *\n     * @param count Optional approximate number of ticks to be returned. If count is not specified, it defaults to 10.\n     */\n    ticks(count?: number): number[];\n\n    /**\n     * Returns a number format function suitable for displaying a tick value, automatically computing the appropriate precision based on the fixed interval between tick values.\n     * The specified count should have the same value as the count that is used to generate the tick values.\n     *\n     * @param count Approximate number of ticks to be used when calculating precision for the number format function.\n     * @param specifier An optional valid format specifier string which allows a custom format where the precision of the format is automatically set by the scale as appropriate for the tick interval.\n     * If specifier uses the format type \"s\", the scale will return a SI-prefix format based on the largest value in the domain.\n     * If the specifier already specifies a precision, this method is equivalent to locale.format.\n     */\n    tickFormat(count?: number, specifier?: string): (d: NumberValue) => string;\n\n    /**\n     * Extends the domain so that it starts and ends on nice round values.\n     * This method typically modifies the scale’s domain, and may only extend the bounds to the nearest round value.\n     *\n     * Nicing is useful if the domain is computed from data, say using extent, and may be irregular.\n     * For example, for a domain of [0.201479…, 0.996679…], a nice domain might be [0.2, 1.0].\n     *\n     * Nicing a scale only modifies the current domain; it does not automatically nice domains that are subsequently set using continuous.domain.\n     * You must re-nice the scale after setting the new domain, if desired.\n     *\n     * @param count An optional number of ticks expected to be used.\n     */\n    nice(count?: number): this;\n\n    /**\n     * Returns the current unknown value, which defaults to undefined.\n     */\n    unknown(): UnknownReturnType<Unknown, undefined>;\n    /**\n     * Sets the output value of the scale for undefined (or NaN) input values and returns this scale.\n     *\n     * @param value The output value of the scale for undefined (or NaN) input values.\n     */\n    unknown<NewUnknown>(value: NewUnknown): ScaleQuantize<Range, NewUnknown>;\n\n    /**\n     * Returns the array of computed thresholds within the domain.\n     */\n    thresholds(): number[];\n\n    /**\n     * Returns an exact copy of this scale. Changes to this scale will not affect the returned scale, and vice versa.\n     */\n    copy(): this;\n}\n\n/**\n * Constructs a new quantize scale with the specified range.\n * The domain defaults to [0, 1].\n * If range is not specified, it defaults to [0, 1].\n * Thus, the default quantize scale is equivalent to the Math.round function.\n *\n * The range must be set corresponding to the type of the range elements.\n *\n * The first generic corresponds to the data type of the range elements.\n * The second generic corresponds to the data type of the unknown value.\n *\n * @param range Array of range values.\n */\n// eslint-disable-next-line @definitelytyped/no-unnecessary-generics\nexport function scaleQuantize<Range = number, Unknown = never>(range?: Iterable<Range>): ScaleQuantize<Range, Unknown>;\n/**\n * Constructs a new quantize scale with the specified domain and range.\n * Thus, the default quantize scale is equivalent to the Math.round function.\n *\n * The range must be set corresponding to the type of the range elements.\n *\n * The first generic corresponds to the data type of the range elements.\n * The second generic corresponds to the data type of the unknown value.\n *\n * @param domain A two-element array of numeric values defining the domain.\n * @param range Array of range values.\n */\n// eslint-disable-next-line @definitelytyped/no-unnecessary-generics\nexport function scaleQuantize<Range, Unknown = never>(\n    domain: Iterable<NumberValue>,\n    range: Iterable<Range>,\n): ScaleQuantize<Range, Unknown>;\n\n// -------------------------------------------------------------------------------\n// Quantile Scale Factory\n// -------------------------------------------------------------------------------\n\n/**\n * Quantile scales map a sampled input domain to a discrete range.\n * The domain is considered continuous and thus the scale will accept any reasonable input value;\n * however, the domain is specified as a discrete set of sample values.\n * The number of values in (the cardinality of) the output range determines the number of quantiles that will be computed from the domain.\n * To compute the quantiles, the domain is sorted, and treated as a population of discrete values; see d3-array’s quantile.\n *\n * The first generic corresponds to the data type of range elements.\n *\n * The second generic corresponds to the data type of the unknown value.\n */\nexport interface ScaleQuantile<Range, Unknown = never> {\n    /**\n     * Given a value in the input domain, returns the corresponding value in the output range.\n     *\n     * @param value A numeric value in the input domain.\n     */\n    (value: NumberValue): Range | Unknown;\n\n    /**\n     * Returns the extent of values in the domain [x0, x1] for the corresponding value in the range: the inverse of quantile.\n     * This method is useful for interaction, say to determine the value in the domain that corresponds to the pixel location under the mouse.\n     *\n     * @param value A value from the range.\n     */\n    invertExtent(value: Range): [number, number];\n\n    /**\n     * Returns the scale’s current domain.\n     */\n    domain(): number[];\n    /**\n     * Sets the domain of the quantile scale to the specified set of discrete numeric values.\n     * The array must not be empty, and must contain at least one numeric value; NaN, null and undefined values are ignored and not considered part of the sample population.\n     *\n     * If the elements in the given array are not numbers, they will be coerced to numbers. A copy of the input array is sorted and stored internally.\n     *\n     * @param domain Array of domain values.\n     */\n    domain(domain: Iterable<NumberValue | null | undefined>): this;\n\n    /**\n     * Returns the current range.\n     */\n    range(): Range[];\n    /**\n     * Sets the discrete values in the range. The array must not be empty.\n     * The number of values in (the cardinality, or length, of) the range array determines the number of quantiles that are computed.\n     *\n     * For example, to compute quartiles, range must be an array of four elements such as [0, 1, 2, 3].\n     *\n     * @param range Array of range values.\n     */\n    range(range: Iterable<Range>): this;\n\n    /**\n     * Returns the quantile thresholds. If the range contains n discrete values, the returned array will contain n - 1 thresholds.\n     * Values less than the first threshold are considered in the first quantile;\n     * values greater than or equal to the first threshold but less than the second threshold are in the second quantile, and so on.\n     * Internally, the thresholds array is used with bisect to find the output quantile associated with the given input value.\n     */\n    quantiles(): number[];\n\n    /**\n     * Returns an exact copy of this scale. Changes to this scale will not affect the returned scale, and vice versa.\n     */\n    copy(): this;\n\n    /**\n     * Returns the current unknown value, which defaults to undefined.\n     */\n    unknown(): UnknownReturnType<Unknown, undefined>;\n    /**\n     * Sets the output value of the scale for undefined (or NaN) input values and returns this scale.\n     *\n     * @param value The output value of the scale for undefined (or NaN) input values.\n     */\n    unknown<NewUnknown>(value: NewUnknown): ScaleQuantile<Range, NewUnknown>;\n}\n\n/**\n * Constructs a new quantile scale with the specified range.\n * The domain defaults to the empty array.\n * If range is not specified, it defaults to the empty array.\n * The quantile scale is invalid until both a domain and range are specified.\n *\n * The first generic corresponds to the data type of range elements.\n * The second generic corresponds to the data type of the unknown value.\n *\n * @param range Array of range values.\n */\n// eslint-disable-next-line @definitelytyped/no-unnecessary-generics\nexport function scaleQuantile<Range = number, Unknown = never>(range?: Iterable<Range>): ScaleQuantile<Range, Unknown>;\n/**\n * Constructs a new quantile scale with the specified domain and range.\n * The quantile scale is invalid until both a domain and range are specified.\n *\n * The first generic corresponds to the data type of range elements.\n * The second generic corresponds to the data type of the unknown value.\n *\n * @param domain Array of domain values.\n * @param range Array of range values.\n */\n// eslint-disable-next-line @definitelytyped/no-unnecessary-generics\nexport function scaleQuantile<Range, Unknown = never>(\n    domain: Iterable<NumberValue | null | undefined>,\n    range: Iterable<Range>,\n): ScaleQuantile<Range, Unknown>;\n\n// -------------------------------------------------------------------------------\n// Threshold Scale Factory\n// -------------------------------------------------------------------------------\n\n/**\n * Threshold scales are similar to quantize scales, except they allow you to map arbitrary subsets of the domain to discrete values in the range.\n * The input domain is still continuous, and divided into slices based on a set of threshold values.\n *\n * If the number of values in the scale’s range is N+1, the number of values in the scale’s domain must be N.\n * If there are fewer than N elements in the domain, the additional values in the range are ignored.\n * If there are more than N elements in the domain, the scale may return undefined for some inputs.\n *\n * The first generic corresponds to the data type of domain values.\n * The second generic corresponds to the data type of range values.\n * The third generic corresponds to the data type of the unknown value.\n */\nexport interface ScaleThreshold<Domain extends number | string | Date, Range, Unknown = never> {\n    /**\n     * Given a value in the input domain, returns the corresponding value in the output range.\n     *\n     * @param value A domain value.\n     */\n    (value: Domain): Range | Unknown;\n\n    /**\n     * Returns the extent of values in the domain [x0, x1] for the corresponding value in the range, representing the inverse mapping from range to domain.\n     * This method is useful for interaction, say to determine the value in the domain that corresponds to the pixel location under the mouse.\n     *\n     * @param value A range value.\n     */\n    invertExtent(value: Range): [Domain | undefined, Domain | undefined];\n\n    /**\n     * Returns the scale’s current domain.\n     */\n    domain(): Domain[];\n    /**\n     * Sets the scale’s domain to the specified array of values. The values must be in sorted ascending order, or the behavior of the scale is undefined.\n     * The values are typically numbers, but any naturally ordered values (such as strings) will work; a threshold scale can be used to encode any type that is ordered.\n     * If the number of values in the scale’s range is N+1, the number of values in the scale’s domain must be N.\n     * If there are fewer than N elements in the domain, the additional values in the range are ignored.\n     * If there are more than N elements in the domain, the scale may return undefined for some inputs.\n     *\n     * @param domain Array of domain values.\n     */\n    domain(domain: Iterable<Domain>): this;\n\n    /**\n     * Returns the scale’s current range.\n     */\n    range(): Range[];\n    /**\n     * Sets the scale’s range to the specified array of values. If the number of values in the scale’s domain is N, the number of values in the scale’s range must be N+1.\n     * If there are fewer than N+1 elements in the range, the scale may return undefined for some inputs.\n     * If there are more than N+1 elements in the range, the additional values are ignored.\n     *\n     * @param range Array of range values.\n     */\n    range(range: Iterable<Range>): this;\n\n    /**\n     * Returns an exact copy of this scale. Changes to this scale will not affect the returned scale, and vice versa.\n     */\n    copy(): this;\n\n    /**\n     * Returns the current unknown value, which defaults to undefined.\n     */\n    unknown(): UnknownReturnType<Unknown, undefined>;\n    /**\n     * Sets the output value of the scale for undefined (or NaN) input values and returns this scale.\n     *\n     * @param value The output value of the scale for undefined (or NaN) input values.\n     */\n    unknown<NewUnknown>(value: NewUnknown): ScaleThreshold<Domain, Range, NewUnknown>;\n}\n\n/**\n * Constructs a new threshold scale with the specified range.\n * The domain defaults to [0.5].\n * If range is not specified, it defaults to [0, 1].\n * Thus, the default threshold scale is equivalent to the Math.round function for numbers; for example threshold(0.49) returns 0, and threshold(0.51) returns 1.\n *\n * The first generic corresponds to the data type of domain values.\n * The second generic corresponds to the data type of range values.\n * The third generic corresponds to the data type of the unknown value.\n *\n * @param range Array of range values.\n */\n// eslint-disable-next-line @definitelytyped/no-unnecessary-generics\nexport function scaleThreshold<Domain extends number | string | Date = number, Range = number, Unknown = never>(\n    range?: Iterable<Range>,\n): ScaleThreshold<Domain, Range, Unknown>;\n/**\n * Constructs a new threshold scale with the specified domain and range.\n * Thus, the default threshold scale is equivalent to the Math.round function for numbers; for example threshold(0.49) returns 0, and threshold(0.51) returns 1.\n *\n * The first generic corresponds to the data type of domain values.\n * The second generic corresponds to the data type of range values.\n * The third generic corresponds to the data type of the unknown value.\n *\n * @param domain Array of domain values.\n * @param range Array of range values.\n */\n// eslint-disable-next-line @definitelytyped/no-unnecessary-generics\nexport function scaleThreshold<Domain extends number | string | Date, Range, Unknown = never>(\n    domain: Iterable<Domain>,\n    range: Iterable<Range>,\n): ScaleThreshold<Domain, Range, Unknown>;\n\n// -------------------------------------------------------------------------------\n// Ordinal Scale Factory\n// -------------------------------------------------------------------------------\n\n/**\n * Unlike continuous scales, ordinal scales have a discrete domain and range. For example, an ordinal scale might map a set of named categories to a set of colors,\n * or determine the horizontal positions of columns in a column chart.\n *\n * The first element in the domain will be mapped to the first element in range, the second domain value to the second range value, and so on.\n * If there are fewer elements in the range than in the domain, the scale will reuse values from the start of the range.\n *\n * The first generic corresponds to the data type of domain values.\n * The second generic corresponds to the data type of range values.\n * The third generic corresponds to the data type of the unknown value.\n */\nexport interface ScaleOrdinal<Domain extends { toString(): string }, Range, Unknown = never> {\n    /**\n     * Given a value in the input domain, returns the corresponding value in the output range.\n     * If the given value is not in the scale’s domain, returns the unknown; or, if the unknown value is implicit (the default),\n     * then the value is implicitly added to the domain and the next-available value in the range is assigned to value,\n     * such that this and subsequent invocations of the scale given the same input value return the same output value.\n     *\n     * @param x A value from the domain.\n     */\n    (x: Domain): Range | Unknown;\n\n    /**\n     * Returns the scale's current domain.\n     */\n    domain(): Domain[];\n    /**\n     * Sets the domain to the specified array of values.\n     *\n     * The first element in domain will be mapped to the first element in the range,\n     * the second domain value to the second range value, and so on.\n     *\n     * Domain values are stored internally in an InternMap from primitive value to index; the resulting index is then used to retrieve a value from the range.\n     * Thus, an ordinal scale’s values must be coercible to a primitive value, and the primitive domain value uniquely identifies the corresponding range value.\n     *\n     * Setting the domain on an ordinal scale is optional if the unknown value is implicit (the default).\n     * In this case, the domain will be inferred implicitly from usage by assigning each unique value passed to the scale a new value from the range.\n     * Note that an explicit domain is recommended to ensure deterministic behavior, as inferring the domain from usage will be dependent on ordering.\n     *\n     * @param domain Array of domain values.\n     */\n    domain(domain: Iterable<Domain>): this;\n\n    /**\n     * Returns the scale's current range.\n     */\n    range(): Range[];\n    /**\n     * Sets the range of the ordinal scale to the specified array of values.\n     *\n     * The first element in the domain will be mapped to the first element in range, the second domain value to the second range value, and so on.\n     *\n     * If there are fewer elements in the range than in the domain, the scale will reuse values from the start of the range.\n     *\n     * @param range Array of range values.\n     */\n    range(range: Iterable<Range>): this;\n\n    /**\n     * Returns the current unknown value, which defaults to \"implicit\".\n     */\n    unknown(): UnknownReturnType<Unknown, { name: \"implicit\" }>;\n    /**\n     * Sets the output value of the scale for unknown input values and returns this scale.\n     * The implicit value enables implicit domain construction. scaleImplicit can be used as a convenience to set the implicit value.\n     *\n     * @param value Unknown value to be used or scaleImplicit to set implicit scale generation.\n     */\n    unknown<NewUnknown>(\n        value: NewUnknown,\n    ): NewUnknown extends { name: \"implicit\" } ? ScaleOrdinal<Domain, Range>\n        : ScaleOrdinal<Domain, Range, NewUnknown>;\n\n    /**\n     * Returns an exact copy of this ordinal scale. Changes to this scale will not affect the returned scale, and vice versa.\n     */\n    copy(): this;\n}\n\n/**\n * Constructs a new ordinal scale with the specified range.\n * The domain defaults to the empty array.\n * If range is not specified, it defaults to the empty array; an ordinal scale always returns undefined until a non-empty range is defined.\n *\n * The generic corresponds to the data type of range elements.\n *\n * @param range An optional array of range values to initialize the scale with.\n */\nexport function scaleOrdinal<Range>(range?: Iterable<Range>): ScaleOrdinal<string, Range>;\n/**\n * Constructs a new ordinal scale with the specified range.\n * The domain defaults to the empty array.\n * If range is not specified, it defaults to the empty array; an ordinal scale always returns undefined until a non-empty range is defined.\n *\n * The first generic corresponds to the data type of domain elements.\n * The second generic corresponds to the data type of range elements.\n * The third generic corresponds to the data type of the unknown value.\n *\n * @param range An optional array of range values to initialize the scale with.\n */\n// eslint-disable-next-line @definitelytyped/no-unnecessary-generics\nexport function scaleOrdinal<Domain extends { toString(): string }, Range, Unknown = never>(\n    range?: Iterable<Range>,\n): ScaleOrdinal<Domain, Range, Unknown>;\n/**\n * Constructs a new ordinal scale with the specified domain and range.\n *\n * The first generic corresponds to the data type of domain elements.\n * The second generic corresponds to the data type of range elements.\n * The third generic corresponds to the data type of the unknown value.\n *\n * @param domain Array of domain values.\n * @param range An optional array of range values to initialize the scale with.\n */\n// eslint-disable-next-line @definitelytyped/no-unnecessary-generics\nexport function scaleOrdinal<Domain extends { toString(): string }, Range, Unknown = never>(\n    domain: Iterable<Domain>,\n    range: Iterable<Range>,\n): ScaleOrdinal<Domain, Range, Unknown>;\n\n/**\n * A special value for ordinal.unknown that enables implicit domain construction: unknown values are implicitly added to the domain.\n */\nexport const scaleImplicit: { name: \"implicit\" };\n\n// -------------------------------------------------------------------------------\n// Band Scale Factory\n// -------------------------------------------------------------------------------\n\n/**\n * Band scales are like ordinal scales except the output range is continuous and numeric.\n * Discrete output values are automatically computed by the scale by dividing the continuous range into uniform bands.\n * Band scales are typically used for bar charts with an ordinal or categorical dimension.\n * The unknown value of a band scale is effectively undefined: they do not allow implicit domain construction.\n *\n * The generic corresponds to the data type of domain elements.\n */\nexport interface ScaleBand<Domain extends { toString(): string }> {\n    /**\n     * Given a value in the input domain, returns the start of the corresponding band derived from the output range.\n     * If the given value is not in the scale’s domain, returns undefined.\n     *\n     * @param x  A value from the domain.\n     */\n    (x: Domain): number | undefined;\n\n    /**\n     * Returns to scale's current domain\n     */\n    domain(): Domain[];\n    /**\n     * Sets the domain to the specified array of values. The first element in domain will be mapped to the first band, the second domain value to the second band, and so on.\n     * Domain values are stored internally in an InternMap from primitive value to index; the resulting index is then used to determine the band.\n     * Thus, a band scale’s values must be coercible to a primitive value, and the primitive domain value uniquely identifies the corresponding band.\n     *\n     * @param domain Array of domain values.\n     */\n    domain(domain: Iterable<Domain>): this;\n\n    /**\n     * Returns the scale’s current range, which defaults to [0, 1].\n     */\n    range(): [number, number];\n    /**\n     * Sets the scale’s range to the specified two-element array of numbers. If the elements in the given array are not numbers, they will be coerced to numbers.\n     * The default range is [0, 1].\n     *\n     * @param range A two-element array of numeric values.\n     */\n    range(range: Iterable<NumberValue>): this;\n\n    /**\n     * Sets the scale’s range to the specified two-element array of numbers while also enabling rounding.\n     * If the elements in the given array are not numbers, they will be coerced to numbers.\n     *\n     * Rounding is sometimes useful for avoiding antialiasing artifacts, though also consider the shape-rendering “crispEdges” styles.\n     *\n     * @param range A two-element array of numeric values.\n     */\n    rangeRound(range: Iterable<NumberValue>): this;\n\n    /**\n     * Returns the current rounding status for the scale: enabled (= true) or disabled (= false).\n     */\n    round(): boolean;\n    /**\n     * Enables or disables rounding accordingly. If rounding is enabled, the start and stop of each band will be integers.\n     * Rounding is sometimes useful for avoiding antialiasing artifacts, though also consider the shape-rendering “crispEdges” styles.\n     * Note that if the width of the domain is not a multiple of the cardinality of the range, there may be leftover unused space, even without padding!\n     * Use band.align to specify how the leftover space is distributed.\n     *\n     * @param round Enable rounding (= true), disable rounding (= false).\n     */\n    round(round: boolean): this;\n\n    /**\n     * Returns the current inner padding which defaults to 0.\n     */\n    paddingInner(): number;\n    /**\n     * Sets the inner padding to the specified value which must be in the range [0, 1].\n     * The inner padding determines the ratio of the range that is reserved for blank space between bands.\n     *\n     * The default setting is 0.\n     *\n     * @param padding Value for inner padding in [0, 1] interval.\n     */\n    paddingInner(padding: number): this;\n\n    /**\n     * Returns the current outer padding which defaults to 0.\n     */\n    paddingOuter(): number;\n    /**\n     * Sets the outer padding to the specified value which must be in the range [0, 1].\n     * The outer padding determines the ratio of the range that is reserved for blank space before the first band and after the last band.\n     *\n     * The default setting is 0.\n     *\n     * @param padding Value for outer padding in [0, 1] interval.\n     */\n    paddingOuter(padding: number): this;\n\n    /**\n     * Returns the inner padding.\n     */\n    padding(): number;\n    /**\n     * A convenience method for setting the inner and outer padding to the same padding value.\n     *\n     * @param padding Value for inner and outer padding in [0, 1] interval.\n     */\n    padding(padding: number): this;\n\n    /**\n     * Returns the current alignment which defaults to 0.5.\n     */\n    align(): number;\n    /**\n     * Sets the alignment to the specified value which must be in the range [0, 1].\n     *\n     * The default is 0.5.\n     *\n     * The alignment determines how any leftover unused space in the range is distributed.\n     * A value of 0.5 indicates that the outer patter should be equally distributed before the first band and after the last band;\n     * i.e., the bands should be centered within the range. A value of 0 or 1 may be used to shift the bands to one side, say to position them adjacent to an axis.\n     *\n     * @param align Value for alignment setting in [0, 1] interval.\n     */\n    align(align: number): this;\n\n    /**\n     * Returns the width of each band.\n     */\n    bandwidth(): number;\n\n    /**\n     * Returns the distance between the starts of adjacent bands.\n     */\n    step(): number;\n\n    /**\n     * Returns an exact copy of this scale. Changes to this scale will not affect the returned scale, and vice versa.\n     */\n    copy(): this;\n}\n\n/**\n * Constructs a new band scale with the specified range, no padding, no rounding and center alignment.\n * The domain defaults to the empty domain.\n * If range is not specified, it defaults to the unit range [0, 1].\n *\n * The generic corresponds to the data type of domain elements.\n *\n * @param range A two-element array of numeric values.\n */\n// eslint-disable-next-line @definitelytyped/no-unnecessary-generics\nexport function scaleBand<Domain extends { toString(): string } = string>(\n    range?: Iterable<NumberValue>,\n): ScaleBand<Domain>;\n/**\n * Constructs a new band scale with the specified domain and range, no padding, no rounding and center alignment.\n *\n * The generic corresponds to the data type of domain elements.\n *\n * @param domain Array of domain values.\n * @param range A two-element array of numeric values.\n */\nexport function scaleBand<Domain extends { toString(): string }>(\n    domain: Iterable<Domain>,\n    range: Iterable<NumberValue>,\n): ScaleBand<Domain>;\n\n// -------------------------------------------------------------------------------\n// Point Scale Factory\n// -------------------------------------------------------------------------------\n\n/**\n * Point scales are a variant of band scales with the bandwidth fixed to zero.\n * Point scales are typically used for scatterplots with an ordinal or categorical dimension.\n * The unknown value of a point scale is always undefined: they do not allow implicit domain construction.\n *\n * The generic corresponds to the data type of domain elements.\n */\nexport interface ScalePoint<Domain extends { toString(): string }> {\n    /**\n     * Given a value in the input domain, returns the corresponding point derived from the output range.\n     * If the given value is not in the scale’s domain, returns undefined.\n     *\n     * @param x  A value from the domain.\n     */\n    (x: Domain): number | undefined;\n\n    /**\n     * Returns the scale's current domain.\n     */\n    domain(): Domain[];\n    /**\n     * Sets the domain to the specified array of values. The first element in domain will be mapped to the first point, the second domain value to the second point, and so on.\n     * Domain values are stored internally in an InternMap from primitive value to index; the resulting index is then used to determine the point.\n     * Thus, a point scale’s values must be coercible to a primitive value, and the primitive domain value uniquely identifies the corresponding point.\n     *\n     * @param domain Array of domain values.\n     */\n    domain(domain: Iterable<Domain>): this;\n\n    /**\n     * Returns the scale’s current range, which defaults to [0, 1].\n     */\n    range(): [number, number];\n    /**\n     * Sets the scale’s range to the specified two-element array of numbers.\n     * If the elements in the given array are not numbers, they will be coerced to numbers.\n     * The default range is [0, 1].\n     *\n     * @param range A two-element array of numeric values.\n     */\n    range(range: Iterable<NumberValue>): this;\n\n    /**\n     * Sets the scale’s range to the specified two-element array of numbers while also enabling rounding.\n     * If the elements in the given array are not numbers, they will be coerced to numbers.\n     *\n     * Rounding is sometimes useful for avoiding antialiasing artifacts, though also consider the shape-rendering “crispEdges” styles.\n     *\n     * @param range A two-element array of numeric values.\n     */\n    rangeRound(range: Iterable<NumberValue>): this;\n\n    /**\n     * Returns the current rounding status for the scale: enabled (= true) or disabled (= false).\n     */\n    round(): boolean;\n    /**\n     * Enables or disables rounding accordingly. If rounding is enabled, the position of each point will be integers.\n     * Rounding is sometimes useful for avoiding antialiasing artifacts, though also consider the shape-rendering “crispEdges” styles.\n     * Note that if the width of the domain is not a multiple of the cardinality of the range, there may be leftover unused space, even without padding!\n     * Use point.align to specify how the leftover space is distributed.\n     *\n     * @param round Enable rounding (= true), disable rounding (= false).\n     */\n    round(round: boolean): this;\n\n    /**\n     * Returns the current outer padding which defaults to 0.\n     * The outer padding determines the ratio of the range that is reserved for blank space\n     * before the first point and after the last point.\n     */\n    padding(): number;\n    /**\n     * Sets the outer padding to the specified value which must be in the range [0, 1].\n     * The outer padding determines the ratio of the range that is reserved for blank space\n     * before the first point and after the last point.\n     *\n     * The default is 0.\n     *\n     * @param padding Value for outer padding in [0, 1] interval.\n     */\n    padding(padding: number): this;\n\n    /**\n     * Returns the current alignment which defaults to 0.5.\n     */\n    align(): number;\n    /**\n     * Sets the alignment to the specified value which must be in the range [0, 1].\n     *\n     * The alignment determines how any leftover unused space in the range is distributed.\n     * A value of 0.5 indicates that the leftover space should be equally distributed before the first point and after the last point;\n     * i.e., the points should be centered within the range. A value of 0 or 1 may be used to shift the points to one side, say to position them adjacent to an axis.\n     *\n     * The default value is 0.5.\n     *\n     * @param align Value for alignment setting in [0, 1] interval.\n     */\n    align(align: number): this;\n\n    /**\n     * Return 0.\n     */\n    bandwidth(): number;\n\n    /**\n     * Returns the distance between the starts of adjacent points.\n     */\n    step(): number;\n\n    /**\n     * Returns an exact copy of this scale. Changes to this scale will not affect the returned scale, and vice versa.\n     */\n    copy(): this;\n}\n\n/**\n * Constructs a new point scale with the specified range, no padding, no rounding and center alignment.\n * The domain defaults to the empty domain.\n * If range is not specified, it defaults to the unit range [0, 1].\n *\n * The generic corresponds to the data type of domain elements.\n *\n * @param range A two-element array of numeric values.\n */\n// eslint-disable-next-line @definitelytyped/no-unnecessary-generics\nexport function scalePoint<Domain extends { toString(): string } = string>(\n    range?: Iterable<NumberValue>,\n): ScalePoint<Domain>;\n/**\n * Constructs a new point scale with the specified domain and range, no padding, no rounding and center alignment.\n * The domain defaults to the empty domain.\n *\n * The generic corresponds to the data type of domain elements.\n *\n * @param domain Array of domain values.\n * @param range A two-element array of numeric values.\n */\nexport function scalePoint<Domain extends { toString(): string }>(\n    domain: Iterable<Domain>,\n    range: Iterable<NumberValue>,\n): ScalePoint<Domain>;\n" },
  { path: "node_modules/d3-hierarchy/package.json", content: "{\"name\":\"d3-hierarchy\",\"types\":\"./index.d.ts\"}" },
  { path: "node_modules/d3-hierarchy/index.d.ts", content: "// Last module patch version validated against: 3.1.2\n\n// -----------------------------------------------------------------------\n// Hierarchy\n// -----------------------------------------------------------------------\n\nexport interface HierarchyLink<Datum> {\n    /**\n     * The source of the link.\n     */\n    source: HierarchyNode<Datum>;\n\n    /**\n     * The target of the link.\n     */\n    target: HierarchyNode<Datum>;\n}\n\nexport interface HierarchyNode<Datum> {\n    new(data: Datum): this;\n\n    /**\n     * The associated data, as specified to the constructor.\n     */\n    data: Datum;\n\n    /**\n     * Zero for the root node, and increasing by one for each descendant generation.\n     */\n    readonly depth: number;\n\n    /**\n     * Zero for leaf nodes, and the greatest distance from any descendant leaf for internal nodes.\n     */\n    readonly height: number;\n\n    /**\n     * The parent node, or null for the root node.\n     */\n    parent: this | null;\n\n    /**\n     * An array of child nodes, if any; undefined for leaf nodes.\n     */\n    children?: this[] | undefined;\n\n    /**\n     * Aggregated numeric value as calculated by `sum(value)` or `count()`, if previously invoked.\n     */\n    readonly value?: number | undefined;\n\n    /**\n     * Optional node id string set by `StratifyOperator`, if hierarchical data was created from tabular data using stratify().\n     */\n    readonly id?: string | undefined;\n\n    /**\n     * The x position of this node. Set after a tree has been laid out by `tree` or `cluster`.\n     *\n     * ```\n     * const root = d3.hierarchy(datum);\n     * const treeLayout = d3.tree();\n     * treeLayout(root);\n     * // x and y are now set on root and its descendants\n     * ```\n     */\n    x?: number | undefined;\n\n    /**\n     * The y position of this node. Set after a tree has been laid out by `tree` or `cluster`.\n     *\n     * ```\n     * const root = d3.hierarchy(datum);\n     * const treeLayout = d3.tree();\n     * treeLayout(root);\n     * // x and y are now set on root and its descendants\n     * ```\n     */\n    y?: number | undefined;\n\n    /**\n     * Returns the array of ancestors nodes, starting with this node, then followed by each parent up to the root.\n     */\n    ancestors(): this[];\n\n    /**\n     * Returns the array of descendant nodes, starting with this node, then followed by each child in topological order.\n     */\n    descendants(): this[];\n\n    /**\n     * Returns the array of leaf nodes in traversal order; leaves are nodes with no children.\n     */\n    leaves(): this[];\n\n    /**\n     * Returns the first node in the hierarchy from this node for which the specified filter returns a truthy value. undefined if no such node is found.\n     * @param filter Filter.\n     */\n    find(filter: (node: this) => boolean): this | undefined;\n\n    /**\n     * Returns the shortest path through the hierarchy from this node to the specified target node.\n     * The path starts at this node, ascends to the least common ancestor of this node and the target node, and then descends to the target node.\n     *\n     * @param target The target node.\n     */\n    path(target: this): this[];\n\n    /**\n     * Returns an array of links for this node, where each link is an object that defines source and target properties.\n     * The source of each link is the parent node, and the target is a child node.\n     */\n    links(): Array<HierarchyLink<Datum>>;\n\n    /**\n     * Evaluates the specified value function for this node and each descendant in post-order traversal, and returns this node.\n     * The `node.value` property of each node is set to the numeric value returned by the specified function plus the combined value of all descendants.\n     *\n     * @param value The value function is passed the node’s data, and must return a non-negative number.\n     */\n    sum(value: (d: Datum) => number): this;\n\n    /**\n     * Computes the number of leaves under this node and assigns it to `node.value`, and similarly for every descendant of node.\n     * If this node is a leaf, its count is one. Returns this node.\n     */\n    count(): this;\n\n    /**\n     * Sorts the children of this node, if any, and each of this node’s descendants’ children,\n     * in pre-order traversal using the specified compare function, and returns this node.\n     *\n     * @param compare The compare function is passed two nodes a and b to compare.\n     * If a should be before b, the function must return a value less than zero;\n     * if b should be before a, the function must return a value greater than zero;\n     * otherwise, the relative order of a and b are not specified. See `array.sort` for more.\n     */\n    sort(compare: (a: this, b: this) => number): this;\n\n    /**\n     * Returns an iterator over the node’s descendants in breadth-first order.\n     */\n    [Symbol.iterator](): Iterator<this>;\n\n    /**\n     * Invokes the specified function for node and each descendant in breadth-first order,\n     * such that a given node is only visited if all nodes of lesser depth have already been visited,\n     * as well as all preceding nodes of the same depth.\n     *\n     * @param func The specified function is passed the current descendant, the zero-based traversal index, and this node.\n     * @param that If that is specified, it is the this context of the callback.\n     */\n    each<T = undefined>(func: (this: T, node: this, index: number, thisNode: this) => void, that?: T): this;\n\n    /**\n     * Invokes the specified function for node and each descendant in post-order traversal,\n     * such that a given node is only visited after all of its descendants have already been visited.\n     *\n     * @param func The specified function is passed the current descendant, the zero-based traversal index, and this node.\n     * @param that If that is specified, it is the this context of the callback.\n     */\n    eachAfter<T = undefined>(func: (this: T, node: this, index: number, thisNode: this) => void, that?: T): this;\n\n    /**\n     * Invokes the specified function for node and each descendant in pre-order traversal,\n     * such that a given node is only visited after all of its ancestors have already been visited.\n     *\n     * @param func The specified function is passed the current descendant, the zero-based traversal index, and this node.\n     * @param that If that is specified, it is the this context of the callback.\n     */\n    eachBefore<T = undefined>(func: (this: T, node: this, index: number, thisNode: this) => void, that?: T): this;\n\n    /**\n     * Return a deep copy of the subtree starting at this node. The returned deep copy shares the same data, however.\n     * The returned node is the root of a new tree; the returned node’s parent is always null and its depth is always zero.\n     */\n    copy(): this;\n}\n\n/**\n * Constructs a root node from the specified hierarchical data.\n *\n * @param data The root specified data.\n * If *data* is a Map, it is implicitly converted to the entry [undefined, *data*],\n * and the children accessor instead defaults to `(d) => Array.isArray(d) ? d[1] : null;`.\n * @param children The specified children accessor function is invoked for each datum, starting with the root data,\n * and must return an iterable of data representing the children, if any.\n * If children is not specified, it defaults to: `(d) => d.children`.\n */\nexport function hierarchy<Datum>(\n    data: Datum,\n    children?: (d: Datum) => Iterable<Datum> | null | undefined,\n): HierarchyNode<Datum>;\n\n// -----------------------------------------------------------------------\n// Stratify\n// -----------------------------------------------------------------------\n\nexport interface StratifyOperator<Datum> {\n    /**\n     * Generates a new hierarchy from the specified tabular data. Each node in the returned object has a shallow copy of the properties\n     * from the corresponding data object, excluding the following reserved properties: id, parentId, children.\n     *\n     * @param data The root specified data.\n     * @throws Error on missing id, ambiguous id, cycle, multiple roots or no root.\n     */\n    (data: Datum[]): HierarchyNode<Datum>;\n\n    /**\n     * Returns the current id accessor, which defaults to: `(d) => d.id`.\n     */\n    id(): (d: Datum, i: number, data: Datum[]) => string | null | \"\" | undefined;\n    /**\n     * Sets the id accessor to the given function.\n     * The id accessor is invoked for each element in the input data passed to the stratify operator.\n     * The returned string is then used to identify the node's relationships in conjunction with the parent id.\n     * For leaf nodes, the id may be undefined, null or the empty string; otherwise, the id must be unique.\n     *\n     * @param id The id accessor.\n     */\n    id(id: (d: Datum, i: number, data: Datum[]) => string | null | \"\" | undefined): this;\n\n    /**\n     * Returns the current parent id accessor, which defaults to: `(d) => d.parentId`.\n     */\n    parentId(): (d: Datum, i: number, data: Datum[]) => string | null | \"\" | undefined;\n    /**\n     * Sets the parent id accessor to the given function.\n     * The parent id accessor is invoked for each element in the input data passed to the stratify operator.\n     * The returned string is then used to identify the node's relationships in conjunction with the id.\n     * For the root node, the parent id should be undefined, null or the empty string.\n     * There must be exactly one root node in the input data, and no circular relationships.\n     *\n     * @param parentId The parent id accessor.\n     */\n    parentId(parentId: (d: Datum, i: number, data: Datum[]) => string | null | \"\" | undefined): this;\n\n    /**\n     * Returns the current path accessor, which defaults to undefined.\n     */\n    path(): ((d: Datum, i: number, data: Datum[]) => string) | null | undefined;\n    /**\n     * If path is specified, sets the path accessor to the given function and returns this stratify operator.\n     * Otherwise, returns the current path accessor, which defaults to undefined.\n     * If a path accessor is set, the id and parentId arguments are ignored,\n     * and a unix-like hierarchy is computed on the slash-delimited strings\n     * returned by the path accessor, imputing parent nodes and ids as necessary.\n     *\n     * @param path The path accessor.\n     */\n    path(path: ((d: Datum, i: number, data: Datum[]) => string) | null | undefined): this;\n}\n\n/**\n * Constructs a new stratify operator with the default settings.\n */\n// eslint-disable-next-line @definitelytyped/no-unnecessary-generics\nexport function stratify<Datum>(): StratifyOperator<Datum>;\n\n// -----------------------------------------------------------------------\n// Cluster\n// -----------------------------------------------------------------------\n\nexport interface HierarchyPointLink<Datum> {\n    /**\n     * The source of the link.\n     */\n    source: HierarchyPointNode<Datum>;\n\n    /**\n     * The target of the link.\n     */\n    target: HierarchyPointNode<Datum>;\n}\n\nexport interface HierarchyPointNode<Datum> extends HierarchyNode<Datum> {\n    /**\n     * The x-coordinate of the node.\n     */\n    x: number;\n\n    /**\n     * The y-coordinate of the node.\n     */\n    y: number;\n\n    /**\n     * Returns an array of links for this node, where each link is an object that defines source and target properties.\n     * The source of each link is the parent node, and the target is a child node.\n     */\n    links(): Array<HierarchyPointLink<Datum>>;\n}\n\nexport interface ClusterLayout<Datum> {\n    /**\n     * Lays out the specified root hierarchy.\n     * You may want to call `root.sort` before passing the hierarchy to the cluster layout.\n     *\n     * @param root The specified root hierarchy.\n     */\n    (root: HierarchyNode<Datum>): HierarchyPointNode<Datum>;\n\n    /**\n     * Returns the current layout size, which defaults to [1, 1]. A layout size of null indicates that a node size will be used instead.\n     */\n    size(): [number, number] | null;\n    /**\n     * Sets this cluster layout’s size to the specified [width, height] array and returns the cluster layout.\n     * The size represent an arbitrary coordinate system; for example, to produce a radial layout,\n     * a size of [360, radius] corresponds to a breadth of 360° and a depth of radius.\n     *\n     * @param size The specified two-element size array.\n     */\n    size(size: [number, number]): this;\n\n    /**\n     * Returns the current node size, which defaults to null. A node size of null indicates that a layout size will be used instead.\n     */\n    nodeSize(): [number, number] | null;\n    /**\n     * Sets this cluster layout’s node size to the specified [width, height] array and returns this cluster layout.\n     * When a node size is specified, the root node is always positioned at <0, 0>.\n     *\n     * @param size The specified two-element size array.\n     */\n    nodeSize(size: [number, number]): this;\n\n    /**\n     * Returns the current separation accessor, which defaults to: `(a, b) => a.parent == b.parent ? 1 : 2`.\n     */\n    separation(): (a: HierarchyPointNode<Datum>, b: HierarchyPointNode<Datum>) => number;\n    /**\n     * Sets the separation accessor to the specified function and returns this cluster layout.\n     * The separation accessor is used to separate neighboring leaves.\n     *\n     * @param separation The separation function is passed two leaves a and b, and must return the desired separation.\n     * The nodes are typically siblings, though the nodes may be more distantly related if the layout decides to place such nodes adjacent.\n     */\n    separation(separation: (a: HierarchyPointNode<Datum>, b: HierarchyPointNode<Datum>) => number): this;\n}\n\n/**\n * Creates a new cluster layout with default settings.\n */\n// eslint-disable-next-line @definitelytyped/no-unnecessary-generics\nexport function cluster<Datum>(): ClusterLayout<Datum>;\n\n// -----------------------------------------------------------------------\n// Tree\n// -----------------------------------------------------------------------\n\nexport interface TreeLayout<Datum> {\n    /**\n     * Lays out the specified root hierarchy.\n     * You may want to call `root.sort` before passing the hierarchy to the tree layout.\n     *\n     * @param root The specified root hierarchy.\n     */\n    (root: HierarchyNode<Datum>): HierarchyPointNode<Datum>;\n\n    /**\n     * Returns the current layout size, which defaults to [1, 1]. A layout size of null indicates that a node size will be used instead.\n     */\n    size(): [number, number] | null;\n    /**\n     * Sets this tree layout’s size to the specified [width, height] array and returns the tree layout.\n     * The size represent an arbitrary coordinate system; for example, to produce a radial layout,\n     * a size of [360, radius] corresponds to a breadth of 360° and a depth of radius.\n     *\n     * @param size The specified two-element size array.\n     */\n    size(size: [number, number]): this;\n\n    /**\n     * Returns the current node size, which defaults to null. A node size of null indicates that a layout size will be used instead.\n     */\n    nodeSize(): [number, number] | null;\n    /**\n     * Sets this tree layout’s node size to the specified [width, height] array and returns this tree layout.\n     * When a node size is specified, the root node is always positioned at <0, 0>.\n     *\n     * @param size The specified two-element size array.\n     */\n    nodeSize(size: [number, number]): this;\n\n    /**\n     * Returns the current separation accessor, which defaults to: `(a, b) => a.parent == b.parent ? 1 : 2`.\n     */\n    separation(): (a: HierarchyPointNode<Datum>, b: HierarchyPointNode<Datum>) => number;\n    /**\n     * Sets the separation accessor to the specified function and returns this tree layout.\n     * The separation accessor is used to separate neighboring nodes.\n     *\n     * @param separation The separation function is passed two nodes a and b, and must return the desired separation.\n     * The nodes are typically siblings, though the nodes may be more distantly related if the layout decides to place such nodes adjacent.\n     */\n    separation(separation: (a: HierarchyPointNode<Datum>, b: HierarchyPointNode<Datum>) => number): this;\n}\n\n/**\n * Creates a new tree layout with default settings.\n */\n// eslint-disable-next-line @definitelytyped/no-unnecessary-generics\nexport function tree<Datum>(): TreeLayout<Datum>;\n\n// -----------------------------------------------------------------------\n// Treemap\n// -----------------------------------------------------------------------\n\nexport interface HierarchyRectangularLink<Datum> {\n    /**\n     * The source of the link.\n     */\n    source: HierarchyRectangularNode<Datum>;\n\n    /**\n     * The target of the link.\n     */\n    target: HierarchyRectangularNode<Datum>;\n}\n\nexport interface HierarchyRectangularNode<Datum> extends HierarchyNode<Datum> {\n    /**\n     * The left edge of the rectangle.\n     */\n    x0: number;\n\n    /**\n     * The top edge of the rectangle\n     */\n    y0: number;\n\n    /**\n     * The right edge of the rectangle.\n     */\n    x1: number;\n\n    /**\n     * The bottom edge of the rectangle.\n     */\n    y1: number;\n\n    /**\n     * Returns an array of links for this node, where each link is an object that defines source and target properties.\n     * The source of each link is the parent node, and the target is a child node.\n     */\n    links(): Array<HierarchyRectangularLink<Datum>>;\n}\n\nexport interface TreemapLayout<Datum> {\n    /**\n     * Lays out the specified root hierarchy.\n     * You must call `root.sum` before passing the hierarchy to the treemap layout.\n     * You probably also want to call `root.sort` to order the hierarchy before computing the layout.\n     *\n     * @param root The specified root hierarchy.\n     */\n    (root: HierarchyNode<Datum>): HierarchyRectangularNode<Datum>;\n\n    /**\n     * Returns the current tiling method, which defaults to `d3.treemapSquarify` with the golden ratio.\n     */\n    tile(): (node: HierarchyRectangularNode<Datum>, x0: number, y0: number, x1: number, y1: number) => void;\n    /**\n     * Sets the tiling method to the specified function and returns this treemap layout.\n     *\n     * @param tile The specified tiling function.\n     */\n    tile(tile: (node: HierarchyRectangularNode<Datum>, x0: number, y0: number, x1: number, y1: number) => void): this;\n\n    /**\n     * Returns the current size, which defaults to [1, 1].\n     */\n    size(): [number, number];\n    /**\n     * Sets this treemap layout’s size to the specified [width, height] array and returns this treemap layout.\n     *\n     * @param size The specified two-element size array.\n     */\n    size(size: [number, number]): this;\n\n    /**\n     * Returns the current rounding state, which defaults to false.\n     */\n    round(): boolean;\n    /**\n     * Enables or disables rounding according to the given boolean and returns this treemap layout.\n     *\n     * @param round The specified boolean flag.\n     */\n    round(round: boolean): this;\n\n    /**\n     * Returns the current inner padding function.\n     */\n    padding(): (node: HierarchyRectangularNode<Datum>) => number;\n    /**\n     * Sets the inner and outer padding to the specified number and returns this treemap layout.\n     *\n     * @param padding The specified padding value.\n     */\n    padding(padding: number): this;\n    /**\n     * Sets the inner and outer padding to the specified function and returns this treemap layout.\n     *\n     * @param padding The specified padding function.\n     */\n    padding(padding: (node: HierarchyRectangularNode<Datum>) => number): this;\n\n    /**\n     * Returns the current inner padding function, which defaults to the constant zero.\n     */\n    paddingInner(): (node: HierarchyRectangularNode<Datum>) => number;\n    /**\n     * Sets the inner padding to the specified number and returns this treemap layout.\n     * The inner padding is used to separate a node’s adjacent children.\n     *\n     * @param padding The specified inner padding value.\n     */\n    paddingInner(padding: number): this;\n    /**\n     * Sets the inner padding to the specified function and returns this treemap layout.\n     * The function is invoked for each node with children, being passed the current node.\n     * The inner padding is used to separate a node’s adjacent children.\n     *\n     * @param padding The specified inner padding function.\n     */\n    paddingInner(padding: (node: HierarchyRectangularNode<Datum>) => number): this;\n\n    /**\n     * Returns the current top padding function.\n     */\n    paddingOuter(): (node: HierarchyRectangularNode<Datum>) => number;\n    /**\n     * Sets the top, right, bottom and left padding to the specified function and returns this treemap layout.\n     *\n     * @param padding The specified padding outer value.\n     */\n    paddingOuter(padding: number): this;\n    /**\n     * Sets the top, right, bottom and left padding to the specified function and returns this treemap layout.\n     *\n     * @param padding The specified padding outer function.\n     */\n    paddingOuter(padding: (node: HierarchyRectangularNode<Datum>) => number): this;\n\n    /**\n     * Returns the current top padding function, which defaults to the constant zero.\n     */\n    paddingTop(): (node: HierarchyRectangularNode<Datum>) => number;\n    /**\n     * Sets the top padding to the specified number and returns this treemap layout.\n     * The top padding is used to separate the top edge of a node from its children.\n     *\n     * @param padding The specified top padding value.\n     */\n    paddingTop(padding: number): this;\n    /**\n     * Sets the top padding to the specified function and returns this treemap layout.\n     * The function is invoked for each node with children, being passed the current node.\n     * The top padding is used to separate the top edge of a node from its children.\n     *\n     * @param padding The specified top padding function.\n     */\n    paddingTop(padding: (node: HierarchyRectangularNode<Datum>) => number): this;\n\n    /**\n     * Returns the current right padding function, which defaults to the constant zero.\n     */\n    paddingRight(): (node: HierarchyRectangularNode<Datum>) => number;\n    /**\n     * Sets the right padding to the specified number and returns this treemap layout.\n     * The right padding is used to separate the right edge of a node from its children.\n     *\n     * @param padding The specified right padding value.\n     */\n    paddingRight(padding: number): this;\n    /**\n     * Sets the right padding to the specified function and returns this treemap layout.\n     * The function is invoked for each node with children, being passed the current node.\n     * The right padding is used to separate the right edge of a node from its children.\n     *\n     * @param padding The specified right padding function.\n     */\n    paddingRight(padding: (node: HierarchyRectangularNode<Datum>) => number): this;\n\n    /**\n     * Returns the current bottom padding function, which defaults to the constant zero.\n     */\n    paddingBottom(): (node: HierarchyRectangularNode<Datum>) => number;\n    /**\n     * Sets the bottom padding to the specified number and returns this treemap layout.\n     * The bottom padding is used to separate the bottom edge of a node from its children.\n     *\n     * @param padding The specified bottom padding value.\n     */\n    paddingBottom(padding: number): this;\n    /**\n     * Sets the bottom padding to the specified function and returns this treemap layout.\n     * The function is invoked for each node with children, being passed the current node.\n     * The bottom padding is used to separate the bottom edge of a node from its children.\n     *\n     * @param padding The specified bottom padding function.\n     */\n    paddingBottom(padding: (node: HierarchyRectangularNode<Datum>) => number): this;\n\n    /**\n     * Returns the current left padding function, which defaults to the constant zero.\n     */\n    paddingLeft(): (node: HierarchyRectangularNode<Datum>) => number;\n    /**\n     * Sets the left padding to the specified number and returns this treemap layout.\n     * The left padding is used to separate the left edge of a node from its children.\n     *\n     * @param padding The specified left padding value.\n     */\n    paddingLeft(padding: number): this;\n    /**\n     * Sets the left padding to the specified function and returns this treemap layout.\n     * The function is invoked for each node with children, being passed the current node.\n     * The left padding is used to separate the left edge of a node from its children.\n     *\n     * @param padding The specified left padding function.\n     */\n    paddingLeft(padding: (node: HierarchyRectangularNode<Datum>) => number): this;\n}\n\n/**\n * Creates a new treemap layout with default settings.\n */\n// eslint-disable-next-line @definitelytyped/no-unnecessary-generics\nexport function treemap<Datum>(): TreemapLayout<Datum>;\n\n// Tiling functions ------------------------------------------------------\n\n/**\n * Recursively partitions the specified nodes into an approximately-balanced binary tree,\n * choosing horizontal partitioning for wide rectangles and vertical partitioning for tall rectangles.\n */\nexport function treemapBinary(\n    node: HierarchyRectangularNode<any>,\n    x0: number,\n    y0: number,\n    x1: number,\n    y1: number,\n): void;\n\n/**\n * Divides the rectangular area specified by x0, y0, x1, y1 horizontally according the value of each of the specified node’s children.\n * The children are positioned in order, starting with the left edge (x0) of the given rectangle.\n * If the sum of the children’s values is less than the specified node’s value (i.e., if the specified node has a non-zero internal value),\n * the remaining empty space will be positioned on the right edge (x1) of the given rectangle.\n */\nexport function treemapDice(node: HierarchyRectangularNode<any>, x0: number, y0: number, x1: number, y1: number): void;\n\n/**\n * Divides the rectangular area specified by x0, y0, x1, y1 vertically according the value of each of the specified node’s children.\n * The children are positioned in order, starting with the top edge (y0) of the given rectangle.\n * If the sum of the children’s values is less than the specified node’s value (i.e., if the specified node has a non-zero internal value),\n * the remaining empty space will be positioned on the bottom edge (y1) of the given rectangle.\n */\nexport function treemapSlice(node: HierarchyRectangularNode<any>, x0: number, y0: number, x1: number, y1: number): void;\n\n/**\n * If the specified node has odd depth, delegates to treemapSlice; otherwise delegates to treemapDice.\n */\nexport function treemapSliceDice(\n    node: HierarchyRectangularNode<any>,\n    x0: number,\n    y0: number,\n    x1: number,\n    y1: number,\n): void;\n\n// TODO: Test Factory code\nexport interface RatioSquarifyTilingFactory {\n    (node: HierarchyRectangularNode<any>, x0: number, y0: number, x1: number, y1: number): void;\n\n    /**\n     * Specifies the desired aspect ratio of the generated rectangles.\n     * Note that the orientation of the generated rectangles (tall or wide) is not implied by the ratio.\n     * Furthermore, the rectangles ratio are not guaranteed to have the exact specified aspect ratio.\n     * If not specified, the aspect ratio defaults to the golden ratio, φ = (1 + sqrt(5)) / 2, per Kong et al.\n     *\n     * @param ratio The specified ratio value greater than or equal to one.\n     */\n    ratio(ratio: number): RatioSquarifyTilingFactory;\n}\n\n/**\n * Implements the squarified treemap algorithm by Bruls et al., which seeks to produce rectangles of a given aspect ratio.\n */\nexport const treemapSquarify: RatioSquarifyTilingFactory;\n\n/**\n * Like `d3.treemapSquarify`, except preserves the topology (node adjacencies) of the previous layout computed by `d3.treemapResquarify`,\n * if there is one and it used the same target aspect ratio. This tiling method is good for animating changes to treemaps because\n * it only changes node sizes and not their relative positions, thus avoiding distracting shuffling and occlusion.\n * The downside of a stable update, however, is a suboptimal layout for subsequent updates: only the first layout uses the Bruls et al. squarified algorithm.\n */\nexport const treemapResquarify: RatioSquarifyTilingFactory;\n\n// -----------------------------------------------------------------------\n// Partition\n// -----------------------------------------------------------------------\n\nexport interface PartitionLayout<Datum> {\n    /**\n     * Lays out the specified root hierarchy.\n     * You must call `root.sum` before passing the hierarchy to the partition layout.\n     * You probably also want to call `root.sort` to order the hierarchy before computing the layout.\n     *\n     * @param root The specified root hierarchy.\n     */\n    (root: HierarchyNode<Datum>): HierarchyRectangularNode<Datum>;\n\n    /**\n     * Returns the current size, which defaults to [1, 1].\n     */\n    size(): [number, number];\n    /**\n     * Sets this partition layout’s size to the specified [width, height] array and returns this partition layout.\n     *\n     * @param size The specified two-element size array.\n     */\n    size(size: [number, number]): this;\n\n    /**\n     * Returns the current rounding state, which defaults to false.\n     */\n    round(): boolean;\n    /**\n     * Enables or disables rounding according to the given boolean and returns this partition layout.\n     *\n     * @param round The specified boolean flag.\n     */\n    round(round: boolean): this;\n\n    /**\n     * Returns the current padding, which defaults to zero.\n     */\n    padding(): number;\n    /**\n     * Sets the padding to the specified number and returns this partition layout.\n     * The padding is used to separate a node’s adjacent children.\n     *\n     * @param padding The specified padding value.\n     */\n    padding(padding: number): this;\n}\n\n/**\n * Creates a new partition layout with the default settings.\n */\n// eslint-disable-next-line @definitelytyped/no-unnecessary-generics\nexport function partition<Datum>(): PartitionLayout<Datum>;\n\n// -----------------------------------------------------------------------\n// Pack\n// -----------------------------------------------------------------------\n\nexport interface HierarchyCircularLink<Datum> {\n    /**\n     * The source of the link.\n     */\n    source: HierarchyCircularNode<Datum>;\n\n    /**\n     * The target of the link.\n     */\n    target: HierarchyCircularNode<Datum>;\n}\n\nexport interface HierarchyCircularNode<Datum> extends HierarchyNode<Datum> {\n    /**\n     * The x-coordinate of the circle’s center.\n     */\n    x: number;\n\n    /**\n     * The y-coordinate of the circle’s center.\n     */\n    y: number;\n\n    /**\n     * The radius of the circle.\n     */\n    r: number;\n\n    /**\n     * Returns an array of links for this node, where each link is an object that defines source and target properties.\n     * The source of each link is the parent node, and the target is a child node.\n     */\n    links(): Array<HierarchyCircularLink<Datum>>;\n}\n\nexport interface PackLayout<Datum> {\n    /**\n     * Lays out the specified root hierarchy.\n     * You must call `root.sum` before passing the hierarchy to the pack layout.\n     * You probably also want to call `root.sort` to order the hierarchy before computing the layout.\n     *\n     * @param root The specified root hierarchy.\n     */\n    (root: HierarchyNode<Datum>): HierarchyCircularNode<Datum>;\n\n    /**\n     * Returns the current radius accessor, which defaults to null.\n     */\n    radius(): null | ((node: HierarchyCircularNode<Datum>) => number);\n    /**\n     * Sets the pack layout’s radius accessor to the specified function and returns this pack layout.\n     * If the radius accessor is null, the radius of each leaf circle is derived from the leaf `node.value` (computed by `node.sum`);\n     * the radii are then scaled proportionally to fit the layout size.\n     * If the radius accessor is not null, the radius of each leaf circle is specified exactly by the function.\n     *\n     * @param radius The specified radius accessor.\n     */\n    radius(radius: null | ((node: HierarchyCircularNode<Datum>) => number)): this;\n\n    /**\n     * Returns the current size, which defaults to [1, 1].\n     */\n    size(): [number, number];\n    /**\n     * Sets this pack layout’s size to the specified [width, height] array and returns this pack layout.\n     *\n     * @param size The specified two-element size array.\n     */\n    size(size: [number, number]): this;\n\n    /**\n     * Returns the current padding accessor, which defaults to the constant zero.\n     */\n    padding(): (node: HierarchyCircularNode<Datum>) => number;\n    /**\n     * Sets this pack layout’s padding accessor to the specified number and returns this pack layout.\n     * Returns the current padding accessor, which defaults to the constant zero.\n     *\n     * When siblings are packed, tangent siblings will be separated by approximately the specified padding;\n     * the enclosing parent circle will also be separated from its children by approximately the specified padding.\n     * If an explicit radius is not specified, the padding is approximate because a two-pass algorithm\n     * is needed to fit within the layout size: the circles are first packed without padding;\n     * a scaling factor is computed and applied to the specified padding; and lastly the circles are re-packed with padding.\n     *\n     * @param padding The specified padding value.\n     */\n    padding(padding: number): this;\n    /**\n     * Sets this pack layout’s padding accessor to the specified function and returns this pack layout.\n     * Returns the current padding accessor, which defaults to the constant zero.\n     *\n     * When siblings are packed, tangent siblings will be separated by approximately the specified padding;\n     * the enclosing parent circle will also be separated from its children by approximately the specified padding.\n     * If an explicit radius is not specified, the padding is approximate because a two-pass algorithm\n     * is needed to fit within the layout size: the circles are first packed without padding;\n     * a scaling factor is computed and applied to the specified padding; and lastly the circles are re-packed with padding.\n     *\n     * @param padding The specified padding function.\n     */\n    padding(padding: (node: HierarchyCircularNode<Datum>) => number): this;\n}\n\n/**\n * Creates a new pack layout with the default settings.\n */\n// eslint-disable-next-line @definitelytyped/no-unnecessary-generics\nexport function pack<Datum>(): PackLayout<Datum>;\n\n// -----------------------------------------------------------------------\n// Pack Siblings and Enclosure\n// -----------------------------------------------------------------------\n\nexport interface PackRadius {\n    /**\n     * The radius of the circle.\n     */\n    r: number;\n\n    /**\n     * The x-coordinate of the circle’s center.\n     */\n    x?: number | undefined;\n\n    /**\n     * The y-coordinate of the circle’s center.\n     */\n    y?: number | undefined;\n}\n\nexport interface PackCircle {\n    /**\n     * The radius of the circle.\n     */\n    r: number;\n\n    /**\n     * The x-coordinate of the circle’s center.\n     */\n    x: number;\n\n    /**\n     * The y-coordinate of the circle’s center.\n     */\n    y: number;\n}\n\n// TODO: Since packSiblings manipulates the circles array in place, technically the x and y properties\n// are optional on invocation, but will be created after execution for each entry.\n\n/**\n * Packs the specified array of circles, each of which must have a `circle.r` property specifying the circle’s radius.\n * The circles are positioned according to the front-chain packing algorithm by Wang et al.\n *\n * @param circles The specified array of circles to pack.\n */\nexport function packSiblings<Datum extends PackRadius>(circles: Datum[]): Array<Datum & PackCircle>;\n\n/**\n * Computes the smallest circle that encloses the specified array of circles, each of which must have\n * a `circle.r` property specifying the circle’s radius, and `circle.x` and `circle.y` properties specifying the circle’s center.\n * The enclosing circle is computed using the Matoušek-Sharir-Welzl algorithm. (See also Apollonius’ Problem.)\n *\n * @param circles The specified array of circles to pack.\n */\n// eslint-disable-next-line @definitelytyped/no-unnecessary-generics\nexport function packEnclose<Datum extends PackCircle>(circles: Datum[]): PackCircle;\n" },
  { path: "node_modules/simplex-noise/package.json", content: "{\"name\":\"simplex-noise\",\"types\":\"./dist/esm/simplex-noise.d.ts\"}" },
  { path: "node_modules/simplex-noise/dist/esm/simplex-noise.d.ts", content: "/**\n * A random() function, must return a number in the interval [0,1), just like Math.random().\n */\nexport declare type RandomFn = () => number;\n/**\n * Samples the noise field in two dimensions\n *\n * Coordinates should be finite, bigger than -2^31 and smaller than 2^31.\n * @param x\n * @param y\n * @returns a number in the interval [-1, 1]\n */\nexport declare type NoiseFunction2D = (x: number, y: number) => number;\n/**\n * Creates a 2D noise function\n * @param random the random function that will be used to build the permutation table\n * @returns {NoiseFunction2D}\n */\nexport declare function createNoise2D(random?: RandomFn): NoiseFunction2D;\n/**\n * Samples the noise field in three dimensions\n *\n * Coordinates should be finite, bigger than -2^31 and smaller than 2^31.\n * @param x\n * @param y\n * @param z\n * @returns a number in the interval [-1, 1]\n */\nexport declare type NoiseFunction3D = (x: number, y: number, z: number) => number;\n/**\n * Creates a 3D noise function\n * @param random the random function that will be used to build the permutation table\n * @returns {NoiseFunction3D}\n */\nexport declare function createNoise3D(random?: RandomFn): NoiseFunction3D;\n/**\n * Samples the noise field in four dimensions\n *\n * Coordinates should be finite, bigger than -2^31 and smaller than 2^31.\n * @param x\n * @param y\n * @param z\n * @param w\n * @returns a number in the interval [-1, 1]\n */\nexport declare type NoiseFunction4D = (x: number, y: number, z: number, w: number) => number;\n/**\n * Creates a 4D noise function\n * @param random the random function that will be used to build the permutation table\n * @returns {NoiseFunction4D}\n */\nexport declare function createNoise4D(random?: RandomFn): NoiseFunction4D;\n/**\n * Builds a random permutation table.\n * This is exported only for (internal) testing purposes.\n * Do not rely on this export.\n * @private\n */\nexport declare function buildPermutationTable(random: RandomFn): Uint8Array;\n" },
  { path: "node_modules/chroma-js/package.json", content: "{\"name\":\"chroma-js\",\"types\":\"./index.d.ts\"}" },
  { path: "node_modules/chroma-js/index.d.ts", content: "/**\n * Chroma.js is a tiny library for all kinds of color conversions and color scales.\n */\ndeclare namespace chroma {\n    interface ColorSpaces {\n        rgb: [number, number, number];\n        rgba: [number, number, number, number];\n        hsl: [number, number, number];\n        hsv: [number, number, number];\n        hsi: [number, number, number];\n        lab: [number, number, number];\n        oklab: [number, number, number];\n        lch: [number, number, number];\n        oklch: [number, number, number];\n        hcl: [number, number, number];\n        cmyk: [number, number, number, number];\n        gl: [number, number, number, number];\n    }\n\n    type InterpolationMode = \"rgb\" | \"hsl\" | \"hsv\" | \"hsi\" | \"lab\" | \"oklab\" | \"lch\" | \"oklch\" | \"hcl\" | \"lrgb\";\n\n    interface ChromaStatic {\n        /**\n         * Creates a color from a string representation (as supported in CSS).\n         * Creates a color from a number representation [0; 16777215]\n         *\n         * @param color The string to convert to a color.\n         * @return the color object.\n         */\n        (color: string | number | Color): Color;\n\n        /**\n         * Create a color in the specified color space using a, b and c as values.\n         *\n         * @param colorSpace The color space to use. Defaults to \"rgb\".\n         * @return the color object.\n         */\n        (a: number, b: number, c: number, colorSpace?: keyof ColorSpaces): Color;\n\n        (a: number, b: number, c: number, d: number, colorSpace?: keyof ColorSpaces): Color;\n\n        /**\n         * Create a color in the specified color space using values.\n         *\n         * @param values An array of values (e.g. [r, g, b, a?]).\n         * @param colorSpace The color space to use. Defaults to \"rgb\".\n         * @return the color object.\n         */\n        (values: number[], colorSpace?: keyof ColorSpaces): Color;\n\n        /**\n         * Create a color from a hex or string representation (as supported in CSS).\n         *\n         * This is an alias of chroma.css().\n         *\n         * @param color The string to convert to a color.\n         * @return the color object.\n         */\n        hex(color: string): Color;\n\n        valid(color: any, mode?: string): boolean;\n\n        hsl(h: number, s: number, l: number, alpha?: number): Color;\n\n        hsv(h: number, s: number, v: number, alpha?: number): Color;\n\n        lab(lightness: number, a: number, b: number, alpha?: number): Color;\n\n        oklab(lightness: number, a: number, b: number, alpha?: number): Color;\n\n        lch(l: number, c: number, h: number, alpha?: number): Color;\n\n        oklch(l: number, c: number, h: number, alpha?: number): Color;\n\n        /**\n         * Same meaning as lch(), but in different order.\n         */\n        hcl(h: number, c: number, l: number, alpha?: number): Color;\n\n        rgb(r: number, g: number, b: number, alpha?: number): Color;\n\n        /**\n         * GL is a variant of RGB(A), with the only difference that the components are normalized to the range of 0..1.\n         */\n        gl(red: number, green: number, blue: number, alpha?: number): Color;\n\n        /**\n         * Returns a color from the color temperature scale.\n         * light 2000K, bright sunlight 6000K.\n         * Based on Neil Bartlett's implementation.\n         * https://github.com/neilbartlett/color-temperature\n         */\n        temperature(t: number): Color;\n\n        /**\n         * Mixes two colors. The mix ratio is a value between 0 and 1.\n         * The color mixing produces different results based the color space used for interpolation. Defaults to LRGB.\n         * @example chroma.mix('red', 'blue', 0.25) // => #bf0040\n         * @example chroma.mix('red', 'blue', 0.5, 'hsl') // => #ff00ff\n         */\n        mix(color1: string | Color, color2: string | Color, f?: number, colorSpace?: InterpolationMode): Color;\n\n        /**\n         * Alias for {@see mix}.\n         */\n        interpolate(color1: string | Color, color2: string | Color, f?: number, colorSpace?: InterpolationMode): Color;\n\n        /**\n         * Similar to {@link mix}, but accepts more than two colors. Simple averaging of R,G,B components and the alpha\n         * channel.\n         */\n        average(colors: Array<string | Color>, colorSpace?: InterpolationMode, weights?: number[]): Color;\n\n        /**\n         * Blends two colors using RGB channel-wise blend functions.\n         */\n        blend(\n            color1: string | Color,\n            color2: string | Color,\n            blendMode: \"multiply\" | \"darken\" | \"lighten\" | \"screen\" | \"overlay\" | \"burn\" | \"dodge\",\n        ): Color;\n\n        /**\n         * Returns a random color.\n         */\n        random(): Color;\n\n        /**\n         * Computes the WCAG contrast ratio between two colors.\n         * A minimum contrast of 4.5:1 is recommended {@link https://www.w3.org/TR/WCAG20-TECHS/G18.html}\n         * to ensure that text is still readable against a background color.\n         */\n        contrast(color1: string | Color, color2: string | Color): number;\n\n        /**\n         * Computes the eucledian distance between two colors in a given color space (default is 'lab').\n         * {@link https://en.wikipedia.org/wiki/Euclidean_distance#Three_dimensions}\n         */\n        distance(color1: string | Color, color2: string | Color, colorSpace?: keyof ColorSpaces): number;\n\n        /**\n         * Computes color difference {@link https://en.wikipedia.org/wiki/Color_difference#CMC_l:c_.281984.29} as\n         * developed by the Colour Measurement Committee of the Society of Dyers and Colourists (CMC) in 1984.\n         * The implementation is adapted from Bruce Lindbloom.\n         * {@link https://web.archive.org/web/20160306044036/http://www.brucelindbloom.com/javascript/ColorDiff.js}\n         * The parameters L (default 1) and C (default 1) are weighting factors for lightness and chromacity.\n         */\n        deltaE(color1: string | Color, color2: string | Color, L?: number, C?: number): number;\n\n        /**\n         * chroma.brewer is an map of ColorBrewer scales that are included in chroma.js for convenience.\n         * chroma.scale uses the colors to construct.\n         */\n        brewer: {\n            OrRd: string[];\n            PuBu: string[];\n            BuPu: string[];\n            Oranges: string[];\n            BuGn: string[];\n            YlOrBr: string[];\n            YlGn: string[];\n            Reds: string[];\n            RdPu: string[];\n            Greens: string[];\n            YlGnBu: string[];\n            Purples: string[];\n            GnBu: string[];\n            Greys: string[];\n            YlOrRd: string[];\n            PuRd: string[];\n            Blues: string[];\n            PuBuGn: string[];\n            Viridis: string[];\n            Spectral: string[];\n            RdYlGn: string[];\n            RdBu: string[];\n            PiYG: string[];\n            PRGn: string[];\n            RdYlBu: string[];\n            BrBG: string[];\n            RdGy: string[];\n            PuOr: string[];\n            Set2: string[];\n            Accent: string[];\n            Set1: string[];\n            Set3: string[];\n            Dark2: string[];\n            Paired: string[];\n            Pastel2: string[];\n            Pastel1: string[];\n        };\n\n        /**\n         * Helper function that computes class breaks based on data.\n         * Mode:\n         *  <li>equidistant <code>'e'</code> breaks are computed by dividing the total range of the data into n groups\n         *  of equal size.\n         *  <li>quantile <code>'q'</code> input domain is divided by quantile ranges.\n         *  <li>logarithmic <code>'l'</code> breaks are equidistant breaks but on a logarithmic scale.\n         *  <li>k-means <code>'k'</code> breaks use the 1-dimensional\n         *  [k-means clustering algorithm]{@link https://en.wikipedia.org/wiki/K-means_clustering} to find (roughly) n\n         *  groups of \"similar\" values. Note that this k-means implementation does not guarantee to find exactly n groups.\n         */\n        limits(data: number[], mode: \"e\" | \"q\" | \"l\" | \"k\", c: number): number[];\n\n        /**\n         * Returns a function that\n         * [bezier-interpolates]{@link https://www.vis4.net/blog/posts/mastering-multi-hued-color-scales/} between\n         * colors in Lab space. The input range of the function is [0..1].\n         * You can convert it to a scale instance by calling <code>chroma.bezier(...).scale()</code>\n         */\n        bezier(colors: string[]): { (t: number): Color; scale(): Scale };\n\n        scale(name: string | Color): Scale;\n\n        scale(colors?: Array<string | Color>): Scale;\n\n        cubehelix(): Cubehelix;\n\n        cmyk(c: number, m: number, y: number, k: number): Color;\n\n        css(col: string): Color;\n    }\n\n    interface Color {\n        /**\n         * Get and set the color opacity.\n         */\n        alpha(a: number): Color;\n        alpha(): number;\n\n        darken(f?: number): Color;\n\n        mix(targetColor: string | Color, f?: number, colorSpace?: keyof ColorSpaces): Color;\n\n        brighten(f?: number): Color;\n\n        /**\n         * Changes the saturation of a color by manipulating the Lch chromacity.\n         */\n        saturate(s?: number): Color;\n\n        /**\n         * Similar to saturate, but the opposite direction.\n         */\n        desaturate(s?: number): Color;\n\n        /**\n         * Changes a single channel and returns the result a new chroma object.\n         * @example\n         * // half Lab lightness\n         * chroma('orangered').set('lab.l', '*0.5')\n         * @example\n         * // double Lch saturation\n         * chroma('darkseagreen').set('lch.c', '*2')\n         */\n        set(modechan: string, v: number | string): Color;\n\n        /**\n         * Returns a single channel value.\n         * Also @see set\n         */\n        get(modechan: string): number;\n\n        /**\n         * Relative brightness, according to the\n         * [WCAG]{@link http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef} definition. Normalized to\n         * 0 for darkest black and 1 for lightest white.\n         */\n        luminance(): number;\n\n        /**\n         * Set luminance of color. The source color will be interpolated with black or white until the correct luminance is found.\n         * The color space used defaults to RGB.\n         */\n        luminance(l: number, colorSpace?: InterpolationMode): Color;\n\n        /**\n         * Get color as hexadecimal string.\n         *\n         * @param mode `auto` - string will include alpha channel only if it's less than 1.\n         *             `rgb`  - string will not include alpha channel.\n         *             `rgba` - string will include alpha channel.\n         *\n         * @example\n         * chroma('orange').hex() === '#ffa500'\n         * chroma('orange').alpha(0.5).hex() === '#ffa50080'\n         * chroma('orange').alpha(0.5).hex('rgb') === '#ffa500'\n         */\n        hex(mode?: \"auto\" | \"rgb\" | \"rgba\"): string;\n\n        /**\n         * Returns the named color. Falls back to hexadecimal RGB string, if the color isn't present.\n         */\n        name(): string;\n\n        /**\n         * Returns a RGB() or HSL() string representation that can be used as CSS-color definition.\n         * mode defaults to <code>'rgb'</code>\n         */\n        css(mode?: \"hsl\"): string;\n\n        /**\n         * Estimate the temperature in Kelvin of any given color, though this makes the only sense for colors from the\n         * [temperature gradient]{@link ChromaStatic.temperature} above.\n         */\n        temperature(): number;\n\n        /**\n         * Returns the numeric representation of the hexadecimal RGB color.\n         *\n         * @example\n         * chroma('#000000').num() === 0\n         * chroma('#0000ff').num() === 255\n         * chroma('#00ff00').num() === 65280\n         * chroma('#ff0000').num() === 16711680\n         */\n        num(): number;\n\n        /**\n         * Returns an array with the red, green, and blue component, each as\n         * number within the range 0..255. Chroma internally stores RGB\n         * channels as floats but rounds the numbers before returning them.\n         * You can pass false to prevent the rounding.\n         *\n         * @example\n         * chroma('orange').rgb() === [255,165,0]\n         * chroma('orange').darken().rgb() === [198,118,0]\n         * chroma('orange').darken().rgb(false) === [198.05,118.11,0]\n         */\n        rgb: (round?: boolean) => ColorSpaces[\"rgb\"];\n\n        /**\n         * Just like color.rgb but adds the alpha channel to the returned array.\n         *\n         * @example\n         * chroma('orange').rgba() === [255,165,0,1]\n         * chroma('hsla(20, 100%, 40%, 0.5)').rgba() === [204,68,0,0.5]\n         */\n        rgba: (round?: boolean) => ColorSpaces[\"rgba\"];\n\n        /**\n         * Returns an array with the `hue`, `saturation`, and `lightness`\n         * component. Hue is the color angle in degree (`0..360`), saturation\n         * and lightness are within `0..1`. Note that for hue-less colors\n         * (black, white, and grays), the hue component will be NaN.\n         *\n         * @example\n         * chroma('orange').hsl() === [38.82,1,0.5,1]\n         * chroma('white').hsl() === [NaN,0,1,1]\n         */\n        hsl: () => ColorSpaces[\"hsl\"];\n\n        /**\n         * Returns an array with the `hue`, `saturation`, and `value`\n         * components. Hue is the color angle in degree (`0..360`),\n         * saturation and value are within `0..1`. Note that for hue-less\n         * colors (black, white, and grays), the hue component will be NaN.\n         *\n         * @example\n         * chroma('orange').hsv() === [38.82,1,1]\n         * chroma('white').hsv() === [NaN,0,1]\n         */\n        hsv: () => ColorSpaces[\"hsv\"];\n\n        /**\n         * Returns an array with the `hue`, `saturation`, and `intensity`\n         * components, each as number between 0 and 255. Note that for hue-less\n         *  colors (black, white, and grays), the hue component will be NaN.\n         *\n         * @example\n         * chroma('orange').hsi() === [39.64,1,0.55]\n         * chroma('white').hsi() === [NaN,0,1]\n         */\n        hsi: () => ColorSpaces[\"hsi\"];\n\n        /**\n         * Returns an array with the **L**, **a**, and **b** components.\n         *\n         * @example\n         * chroma('orange').lab() === [74.94,23.93,78.95]\n         */\n        lab: () => ColorSpaces[\"lab\"];\n\n        /**\n         * Returns an array with the **L**, **a**, and **b** components.\n         *\n         * @example\n         * chroma('orange').oklab() === [0.7927,0.0566,0.1614]\n         */\n        oklab: () => ColorSpaces[\"oklab\"];\n\n        /**\n         * Returns an array with the **Lightness**, **chroma**, and **hue**\n         * components.\n         *\n         * @example\n         * chroma('skyblue').lch() === [79.21,25.94,235.11]\n         */\n        lch: () => ColorSpaces[\"lch\"];\n\n        /**\n         * Returns an array with the **Lightness**, **chroma**, and **hue**\n         * components.\n         *\n         * @example\n         * chroma('skyblue').oklch() === [0.8148,0.0819,225.8]\n         */\n        oklch: () => ColorSpaces[\"oklch\"];\n\n        /**\n         * Alias of [lch](#color-lch), but with the components in reverse\n         * order.\n         *\n         * @example\n         * chroma('skyblue').hcl() === [235.11,25.94,79.21]\n         */\n        hcl: () => ColorSpaces[\"hcl\"];\n\n        /**\n         * Just like color.rgb but adds the alpha channel to the returned\n         * array.\n         *\n         * @example\n         * chroma('orange').rgba() === [255,165,0,1]\n         * chroma('hsla(20, 100%, 40%, 0.5)').rgba() === [204,68,0,0.5]\n         */\n        cmyk: () => ColorSpaces[\"cmyk\"];\n\n        /**\n         * Returns an array with the cyan, magenta, yellow, and key (black)\n         * components, each as a normalized value between 0 and 1.\n         *\n         * @example\n         * chroma('33cc00').gl() === [0.2,0.8,0,1]\n         */\n        gl: () => ColorSpaces[\"gl\"];\n\n        /**\n         * Test if a color has been clipped or not.\n         * Colors generated from CIELab color space may have their RGB\n         * channels clipped to the range of [0..255].\n         * Colors outside that range may exist in nature but are not\n         * displayable on RGB monitors (such as ultraviolet).\n         *\n         * @example\n         * chroma.hcl(50, 40, 20).clipped() === true\n         */\n        clipped: () => boolean;\n\n        /**\n         * The unclipped RGB components.\n         *\n         * @example\n         * chroma.hcl(50, 40, 100)._rgb._unclipped === [322.65,235.24,196.7,1]\n         */\n        _rgb: { _unclipped: ColorSpaces[\"rgba\"] };\n    }\n\n    interface Scale<OutType = Color> {\n        (c: string[]): Scale;\n\n        (value: number | null | undefined): OutType;\n\n        domain(d?: number[], n?: number, mode?: string): this;\n\n        mode(mode: InterpolationMode): this;\n\n        gamma(g: number): this;\n\n        cache(use: boolean): boolean;\n\n        correctLightness(enable?: boolean): this;\n\n        padding(p: number | number[]): this;\n\n        /**\n         * You can call scale.colors(n) to quickly grab `c` equi-distant colors from a color scale. If called with no\n         * arguments, scale.colors returns the original array of colors used to create the scale.\n         */\n        colors(\n            c: number | undefined,\n            format: undefined | null | \"alpha\" | \"darken\" | \"brighten\" | \"saturate\" | \"desaturate\",\n        ): Color[];\n        colors(c: number | undefined, format: \"luminance\" | \"temperature\"): number[];\n        colors<K extends keyof ColorSpaces>(c: number | undefined, format: K): Array<ColorSpaces[K]>;\n        colors(c: number | undefined, format?: \"hex\" | \"name\"): string[];\n\n        /**\n         * If you want the scale function to return a distinct set of colors instead of a continuous gradient, you can\n         * use scale.classes. If you pass a number the scale will broken into equi-distant classes.\n         * You can also define custom class breaks by passing them as array\n         */\n        classes(c: number | number[]): this;\n\n        /**\n         * Set out format for scale() call. Passing null will result in a scale which outputs colors.\n         */\n        out(format: null): Scale;\n        out<K extends keyof ColorSpaces>(format: K): Scale<ColorSpaces[K]>;\n        out(format: \"hex\"): Scale<string>;\n    }\n\n    interface Cubehelix {\n        /**\n         * Set start color for hue rotation, default=300\n         */\n        start(s: number): Cubehelix;\n\n        /**\n         * number (and direction) of hue rotations (e.g. 1=360°, 1.5=`540°``), default=-1.5\n         */\n        rotations(r: number): Cubehelix;\n\n        /**\n         * gamma factor can be used to emphasise low or high intensity values, default=1\n         */\n        gamma(g: number): Cubehelix;\n\n        /**\n         * lightness range: default: [0,1] (black -> white)\n         */\n        lightness(l: number[]): Cubehelix;\n\n        /**\n         * You can call cubehelix.scale() to use the cube-helix through the chroma.scale interface.\n         */\n        scale(): Scale;\n    }\n}\n\ndeclare var chroma: chroma.ChromaStatic;\n\nexport = chroma;\nexport as namespace chroma;\n" }
];
